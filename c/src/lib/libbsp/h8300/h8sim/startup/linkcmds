/*
 *  $Id$
 */

/*
 * Declare some sizes.
 */
_RamBase = DEFINED(_RamBase) ? _RamBase : 0x0;
_RamSize = DEFINED(_RamSize) ? _RamSize : 1M;
_HeapSize = DEFINED(_HeapSize) ? _HeapSize : 0x10000;
_StackSize = DEFINED(_StackSize) ? _StackSize : 0x1000;

ENTRY("_start")
/* The memory size is 256KB to coincide with the simulator.
   Don't change either without considering the other.  */
MEMORY
{
  /* 0xc4 is a magic entry.  We should have the linker just
  skip over it one day... */
  vectors : o = 0x0000, l = 0xc4
  magicvectors : o = 0xc4, l = 0x3c
  /* We still only use 256k as the main ram size.  */
  ram    : o = 0x0100, l = 0x3fefc
  /* The stack starts at the top of main ram.  */
  topram : o = 0x3fffc, l = 0x4
  /* This holds variables in the "tiny" sections.  */
  tiny   : o = 0xff8000, l = 0x7f00
  /* At the very top of the address space is the 8-bit area.  */
  eight  : o = 0xffff00, l = 0x100
}


SECTIONS
{ 
   .vectors :
   {
        *(.vectors)
   }  > vectors

    .text : 
    { 
	 CREATE_OBJECT_SYMBOLS
	*(.text) 
	 _etext = .;
	
/*
	___CTOR_LIST__ = .;
	LONG((___CTOR_END__ - ___CTOR_LIST__) / 4 - 2)
	*(.ctors)
	LONG(0)
	___CTOR_END__ = .;
	___DTOR_LIST__ = .;
	LONG((___DTOR_END__ - ___DTOR_LIST__) / 4 - 2)
	*(.dtors)
	LONG(0)
	___DTOR_END__ = .;
*/
    }  >ram
    .data SIZEOF(.text) + ADDR(.text):
    { 
 	*(.data) 
	CONSTRUCTORS
	 _edata = .;
    }  >ram
    .bss SIZEOF(.data) + ADDR(.data):
    { 
	 _bss_start = .;
	*(.bss)	 
	*(COMMON) 
	. = ALIGN (64);
	. += _StackSize;
	_stack_init = .;
	_clear_end = .;
	_WorkspaceBase = .;
	. += 512K;	/* reserve some memory for workspace */
	_HeapBase = .;
	. += _HeapSize;	/* reserve some memory for heap */
	 _end = .;
	 __end = .;
    } >ram
    .tiny : {
        *(.tiny)
    }  > tiny
    .eight : {
        *(.eight)
    }  > eight
    .stab 0 (NOLOAD) : {
        [ .stab ]
    }
    .stabstr 0 (NOLOAD) : {
        [ .stabstr ]
    }

} 
