diff -Naur newlib-1.16.0.orig/newlib/libc/include/getopt.h newlib-1.16.0/newlib/libc/include/getopt.h
--- newlib-1.16.0.orig/newlib/libc/include/getopt.h	2006-01-04 22:21:52.000000000 +0100
+++ newlib-1.16.0/newlib/libc/include/getopt.h	2008-03-03 08:36:14.000000000 +0100
@@ -89,31 +89,40 @@
 
 /* include files needed by this include file */
 
-/* macros defined by this include file */
-#define NO_ARG          0
-#define REQUIRED_ARG    1
-#define OPTIONAL_ARG    2
-
-/* types defined by this include file */
-
-struct option
-{
-  char *name;                   /* the name of the long option */
-  int has_arg;                  /* one of the above macros */
-  int *flag;                    /* determines if getopt_long() returns a
-                                 * value for a long option; if it is
-                                 * non-NULL, 0 is returned as a function
-                                 * value and the value of val is stored in
-                                 * the area pointed to by flag.  Otherwise,
-                                 * val is returned. */
-  int val;                      /* determines the value to return if flag is
-                                 * NULL. */
-};
+  /* These #defines are to keep the namespace clear... */
+#define getopt_r		__getopt_r
+#define getopt_long_r		__getopt_long_r
+#define getopt_long_only_r	__getopt_long_only_r
 
 #ifdef __cplusplus
 extern "C"
 {
-#endif
+
+#endif				/* __cplusplus */
+
+/* types defined by this include file */
+  struct option
+  {
+    char *name;			/* the name of the long option */
+    int has_arg;		/* one of the above macros */
+    int *flag;			/* determines if getopt_long() returns a
+				 * value for a long option; if it is
+				 * non-NULL, 0 is returned as a function
+				 * value and the value of val is stored in
+				 * the area pointed to by flag.  Otherwise,
+				 * val is returned. */
+    int val;			/* determines the value to return if flag is
+				 * NULL. */
+
+  };
+
+  /* The getopt_data structure is for reentrancy. Its members are similar to
+     the externally-defined variables.  */
+  typedef struct getopt_data
+  {
+    char *optarg;
+    int optind, opterr, optopt, optwhere;
+  } getopt_data;
 
   /* externally-defined variables */
   extern char *optarg;
@@ -122,14 +131,35 @@
   extern int optopt;
 
   /* function prototypes */
-  int _EXFUN (getopt, (int __argc, char *const __argv[], const char *__optstring));
-  int _EXFUN (getopt_long, (int __argc, char *const __argv[], const char *__shortopts, const struct option *__longopts, int *__longind));
-  int _EXFUN (getopt_long_only, (int __argc, char *const __argv[], const char *__shortopts, const struct option *__longopts, int *__longind));
+  int _EXFUN (getopt,
+	      (int __argc, char *const __argv[], const char *__optstring));
+
+  int _EXFUN (getopt_long,
+	      (int __argc, char *const __argv[], const char *__shortopts,
+	       const struct option * __longopts, int *__longind));
+
+  int _EXFUN (getopt_long_only,
+	      (int __argc, char *const __argv[], const char *__shortopts,
+	       const struct option * __longopts, int *__longind));
+
+  int _EXFUN (__getopt_r,
+	      (int __argc, char *const __argv[], const char *__optstring,
+	       struct getopt_data * __data));
+
+  int _EXFUN (__getopt_long_r,
+	      (int __argc, char *const __argv[], const char *__shortopts,
+	       const struct option * __longopts, int *__longind,
+	       struct getopt_data * __data));
+
+  int _EXFUN (__getopt_long_only_r,
+	      (int __argc, char *const __argv[], const char *__shortopts,
+	       const struct option * __longopts, int *__longind,
+	       struct getopt_data * __data));
 
 #ifdef __cplusplus
 };
 
-#endif
+#endif /* __cplusplus  */
 
 #endif /* GETOPT_H */
 
diff -Naur newlib-1.16.0.orig/newlib/libc/include/inttypes.h newlib-1.16.0/newlib/libc/include/inttypes.h
--- newlib-1.16.0.orig/newlib/libc/include/inttypes.h	2005-12-16 20:03:12.000000000 +0100
+++ newlib-1.16.0/newlib/libc/include/inttypes.h	2008-03-03 08:36:14.000000000 +0100
@@ -242,9 +242,12 @@
 #define SCNxMAX		__SCNMAX(x)
 
 /* ptr types */
-#if __have_longlong64
-#define __PRIPTR(x) __STRINGIFY(ll##x)
-#define __SCNPTR(x) __STRINGIFY(ll##x)
+#if __ptrint_t_long_defined
+#define __PRIPTR(x) __STRINGIFY(l##x)
+#define __SCNPTR(x) __STRINGIFY(l##x)
+#elif __ptrint_t_int_defined
+#define __PRIPTR(x) __STRINGIFY(x)
+#define __SCNPTR(x) __STRINGIFY(x)
 #elif __have_long64
 #define __PRIPTR(x) __STRINGIFY(l##x)
 #define __SCNPTR(x) __STRINGIFY(l##x)
diff -Naur newlib-1.16.0.orig/newlib/libc/include/machine/setjmp.h newlib-1.16.0/newlib/libc/include/machine/setjmp.h
--- newlib-1.16.0.orig/newlib/libc/include/machine/setjmp.h	2007-11-07 22:42:24.000000000 +0100
+++ newlib-1.16.0/newlib/libc/include/machine/setjmp.h	2008-03-03 08:36:14.000000000 +0100
@@ -27,7 +27,7 @@
 
 /* necv70 was 9 as well. */
 
-#ifdef __mc68000__
+#if defined(__m68k__) || defined(__mc68000__)
 /*
  * onsstack,sigmask,sp,pc,psl,d2-d7,a2-a6,
  * fp2-fp7	for 68881.
@@ -268,6 +268,12 @@
 # define _CYGWIN_WORKING_SIGSETJMP
 #endif
 
+#ifdef _POSIX_THREADS
+#define __SIGMASK_FUNC pthread_sigmask
+#else
+#define __SIGMASK_FUNC sigprocmask
+#endif
+
 #if defined(__GNUC__)
 
 #define sigsetjmp(env, savemask) \
@@ -275,7 +281,7 @@
             ({ \
               sigjmp_buf *_sjbuf = &(env); \
               ((*_sjbuf)[_SAVEMASK] = savemask,\
-              sigprocmask (SIG_SETMASK, 0, (sigset_t *)((*_sjbuf) + _SIGMASK)),\
+              __SIGMASK_FUNC (SIG_SETMASK, 0, (sigset_t *)((*_sjbuf) + _SIGMASK)),\
               setjmp (*_sjbuf)); \
             })
 
@@ -284,7 +290,7 @@
             ({ \
               sigjmp_buf *_sjbuf = &(env); \
               ((((*_sjbuf)[_SAVEMASK]) ? \
-               sigprocmask (SIG_SETMASK, (sigset_t *)((*_sjbuf) + _SIGMASK), 0)\
+               __SIGMASK_FUNC (SIG_SETMASK, (sigset_t *)((*_sjbuf) + _SIGMASK), 0)\
                : 0), \
                longjmp (*_sjbuf, val)); \
             })
@@ -292,15 +298,21 @@
 #else /* !__GNUC__ */
 
 #define sigsetjmp(env, savemask) ((env)[_SAVEMASK] = savemask,\
-               sigprocmask (SIG_SETMASK, 0, (sigset_t *) ((env) + _SIGMASK)),\
+               __SIGMASK_FUNC (SIG_SETMASK, 0, (sigset_t *) ((env) + _SIGMASK)),\
                setjmp (env))
 
 #define siglongjmp(env, val) ((((env)[_SAVEMASK])?\
-               sigprocmask (SIG_SETMASK, (sigset_t *) ((env) + _SIGMASK), 0):0),\
+               __SIGMASK_FUNC (SIG_SETMASK, (sigset_t *) ((env) + _SIGMASK), 0):0),\
                longjmp (env, val))
 
 #endif
 
+/* POSIX _setjmp/_longjmp macros, maintained for XSI compatibility.  These
+   are equivalent to sigsetjmp/siglongjmp when not saving the signal mask.
+   New applications should use sigsetjmp/siglongjmp instead. */
+#define _setjmp(env)		sigsetjmp ((env), 0)
+#define _longjmp(env, val)	siglongjmp ((env), (val))
+
 #ifdef __cplusplus
 }
 #endif
diff -Naur newlib-1.16.0.orig/newlib/libc/include/pthread.h newlib-1.16.0/newlib/libc/include/pthread.h
--- newlib-1.16.0.orig/newlib/libc/include/pthread.h	2006-09-14 00:09:27.000000000 +0200
+++ newlib-1.16.0/newlib/libc/include/pthread.h	2008-03-03 08:36:14.000000000 +0100
@@ -283,14 +283,6 @@
 int	_EXFUN(pthread_getcpuclockid,
 	(pthread_t __pthread_id, clockid_t *__clock_id));
  
-/* CPU-time Clock Thread Creation Attribute, P1003.4b/D8, p. 59 */
-
-int	_EXFUN(pthread_attr_setcputime,
-	(pthread_attr_t *__attr, int __clock_allowed));
-
-int	_EXFUN(pthread_attr_getcputime,
-	(pthread_attr_t *__attr, int *__clock_allowed));
-
 #endif /* defined(_POSIX_THREAD_CPUTIME) */
 
 
diff -Naur newlib-1.16.0.orig/newlib/libc/include/stdint.h newlib-1.16.0/newlib/libc/include/stdint.h
--- newlib-1.16.0.orig/newlib/libc/include/stdint.h	2006-08-16 23:39:43.000000000 +0200
+++ newlib-1.16.0/newlib/libc/include/stdint.h	2008-03-03 08:36:14.000000000 +0100
@@ -393,6 +393,9 @@
 #define UINTMAX_C(x)	x##UL
 #endif
 
+#ifdef __rtems__
+#include <machine/stdint.h>
+#endif
 
 #ifdef __cplusplus
 }
diff -Naur newlib-1.16.0.orig/newlib/libc/include/sys/features.h newlib-1.16.0/newlib/libc/include/sys/features.h
--- newlib-1.16.0.orig/newlib/libc/include/sys/features.h	2007-12-19 19:51:19.000000000 +0100
+++ newlib-1.16.0/newlib/libc/include/sys/features.h	2008-03-03 08:36:14.000000000 +0100
@@ -38,6 +38,7 @@
 #define _POSIX_MEMLOCK_RANGE		1
 #define _POSIX_MEMORY_PROTECTION	1
 #define _POSIX_MESSAGE_PASSING		1
+#define _POSIX_MONOTONIC_CLOCK		200112L
 #define _POSIX_PRIORITIZED_IO		1
 #define _POSIX_PRIORITY_SCHEDULING	1
 #define _POSIX_REALTIME_SIGNALS		1
diff -Naur newlib-1.16.0.orig/newlib/libc/include/sys/_types.h newlib-1.16.0/newlib/libc/include/sys/_types.h
--- newlib-1.16.0.orig/newlib/libc/include/sys/_types.h	2007-09-18 22:05:17.000000000 +0200
+++ newlib-1.16.0/newlib/libc/include/sys/_types.h	2008-03-03 08:36:14.000000000 +0100
@@ -84,4 +84,7 @@
 typedef void *_iconv_t;
 #endif
 
+typedef long * __intptr_t;
+typedef unsigned long* __uintptr_t;
+
 #endif	/* _SYS__TYPES_H */
diff -Naur newlib-1.16.0.orig/newlib/libc/include/sys/unistd.h newlib-1.16.0/newlib/libc/include/sys/unistd.h
--- newlib-1.16.0.orig/newlib/libc/include/sys/unistd.h	2007-11-08 17:20:12.000000000 +0100
+++ newlib-1.16.0/newlib/libc/include/sys/unistd.h	2008-03-03 08:36:14.000000000 +0100
@@ -219,13 +219,11 @@
 char *	_EXFUN(mktemp, (char *));
 #endif
 
-#if defined(__CYGWIN__) || defined(__SPU__)
+#if defined(__CYGWIN__) || defined(__SPU__) || defined(__rtems__)
 void    _EXFUN(sync, (void));
-#elif defined(__rtems__)
-int     _EXFUN(sync, (void));
 #endif
 
-int     _EXFUN(readlink, (const char *__path, char *__buf, int __buflen));
+ssize_t _EXFUN(readlink, (const char *__path, char *__buf, size_t __buflen));
 int     _EXFUN(symlink, (const char *__name1, const char *__name2));
 
 #define	F_OK	0
diff -Naur newlib-1.16.0.orig/newlib/libc/include/_syslist.h newlib-1.16.0/newlib/libc/include/_syslist.h
--- newlib-1.16.0.orig/newlib/libc/include/_syslist.h	2005-08-22 23:13:35.000000000 +0200
+++ newlib-1.16.0/newlib/libc/include/_syslist.h	2008-03-03 08:36:14.000000000 +0100
@@ -11,6 +11,7 @@
 #define _fstat fstat
 #define _getpid getpid
 #define _gettimeofday gettimeofday
+#define _isatty isatty
 #define _kill kill
 #define _link link
 #define _lseek lseek
diff -Naur newlib-1.16.0.orig/newlib/libc/include/time.h newlib-1.16.0/newlib/libc/include/time.h
--- newlib-1.16.0.orig/newlib/libc/include/time.h	2005-11-18 16:57:24.000000000 +0100
+++ newlib-1.16.0/newlib/libc/include/time.h	2008-03-03 08:36:14.000000000 +0100
@@ -226,6 +226,16 @@
 
 #endif
 
+#if defined(_POSIX_MONOTONIC_CLOCK)
+
+/*  The identifier for the system-wide monotonic clock, which is defined
+    as a clock whose value cannot be set via clock_settime() and which 
+    cannot have backward clock jumps. */
+
+#define CLOCK_MONOTONIC (clockid_t)4
+
+#endif
+
 #if defined(_POSIX_CPUTIME)
 
 /* Accessing a Process CPU-time CLock, P1003.4b/D8, p. 55 */
diff -Naur newlib-1.16.0.orig/newlib/libc/machine/arm/machine/endian.h newlib-1.16.0/newlib/libc/machine/arm/machine/endian.h
--- newlib-1.16.0.orig/newlib/libc/machine/arm/machine/endian.h	2004-05-07 22:29:24.000000000 +0200
+++ newlib-1.16.0/newlib/libc/machine/arm/machine/endian.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-/* ARM configuration file */
-
-#ifndef _MACHINE_ENDIAN_H
-# define _MACHINE_ENDIAN_H
-
-#ifdef __ARMEB__
-#define BYTE_ORDER BIG_ENDIAN
-#else
-#define BYTE_ORDER LITTLE_ENDIAN
-#endif
-
-#endif
diff -Naur newlib-1.16.0.orig/newlib/libc/search/db_local.h newlib-1.16.0/newlib/libc/search/db_local.h
--- newlib-1.16.0.orig/newlib/libc/search/db_local.h	2002-06-25 01:05:08.000000000 +0200
+++ newlib-1.16.0/newlib/libc/search/db_local.h	2008-03-03 08:36:14.000000000 +0100
@@ -50,7 +50,7 @@
 #define	MAX_PAGE_NUMBER	0xffffffff	/* >= # of pages in a file */
 typedef __uint32_t	pgno_t;
 #define	MAX_PAGE_OFFSET	65535		/* >= # of bytes in a page */
-typedef __uint16_t	indx_t;
+typedef __uint_least16_t	indx_t;
 #define	MAX_REC_NUMBER	0xffffffff	/* >= # of records in a tree */
 typedef __uint32_t	recno_t;
 
@@ -191,12 +191,12 @@
  *	P_16_COPY	swap from one location to another
  */
 #define	M_16_SWAP(a) {							\
-	__uint16_t _tmp = a;						\
+	__uint_least16_t _tmp = a;						\
 	((char *)&a)[0] = ((char *)&_tmp)[1];				\
 	((char *)&a)[1] = ((char *)&_tmp)[0];				\
 }
 #define	P_16_SWAP(a) {							\
-	__uint16_t _tmp = *(__uint16_t *)a;				\
+	__uint_least16_t _tmp = *(__uint_least16_t *)a;				\
 	((char *)a)[0] = ((char *)&_tmp)[1];				\
 	((char *)a)[1] = ((char *)&_tmp)[0];				\
 }
diff -Naur newlib-1.16.0.orig/newlib/libc/search/extern.h newlib-1.16.0/newlib/libc/search/extern.h
--- newlib-1.16.0.orig/newlib/libc/search/extern.h	2002-06-20 21:51:31.000000000 +0200
+++ newlib-1.16.0/newlib/libc/search/extern.h	2008-03-03 08:36:14.000000000 +0100
@@ -48,7 +48,7 @@
 int	 __delpair(HTAB *, BUFHEAD *, int);
 int	 __expand_table(HTAB *);
 int	 __find_bigpair(HTAB *, BUFHEAD *, int, char *, int);
-__uint16_t	 __find_last_page(HTAB *, BUFHEAD **);
+__uint_least16_t	 __find_last_page(HTAB *, BUFHEAD **);
 void	 __free_ovflpage(HTAB *, BUFHEAD *);
 BUFHEAD	*__get_buf(HTAB *, __uint32_t, BUFHEAD *, int);
 int	 __get_page(HTAB *, char *, __uint32_t, int, int, int);
diff -Naur newlib-1.16.0.orig/newlib/libc/search/hash_bigkey.c newlib-1.16.0/newlib/libc/search/hash_bigkey.c
--- newlib-1.16.0.orig/newlib/libc/search/hash_bigkey.c	2006-06-07 21:22:59.000000000 +0200
+++ newlib-1.16.0/newlib/libc/search/hash_bigkey.c	2008-03-03 08:36:14.000000000 +0100
@@ -92,13 +92,13 @@
 	BUFHEAD *bufp;
 	const DBT *key, *val;
 {
-	__uint16_t *p;
+	__uint_least16_t *p;
 	int key_size, n, val_size;
-	__uint16_t space, move_bytes, off;
+	__uint_least16_t space, move_bytes, off;
 	char *cp, *key_data, *val_data;
 
 	cp = bufp->page;		/* Character pointer of p. */
-	p = (__uint16_t *)cp;
+	p = (__uint_least16_t *)cp;
 
 	key_data = (char *)key->data;
 	key_size = key->size;
@@ -136,7 +136,7 @@
 				OFFSET(p) = off;
 			} else
 				p[n - 2] = FULL_KEY;
-		p = (__uint16_t *)bufp->page;
+		p = (__uint_least16_t *)bufp->page;
 		cp = bufp->page;
 		bufp->flags |= BUF_MOD;
 	}
@@ -166,7 +166,7 @@
 			if (!bufp)
 				return (-1);
 			cp = bufp->page;
-			p = (__uint16_t *)cp;
+			p = (__uint_least16_t *)cp;
 		} else
 			p[n] = FULL_KEY_DATA;
 		bufp->flags |= BUF_MOD;
@@ -191,12 +191,12 @@
 	BUFHEAD *bufp;
 {
 	BUFHEAD *last_bfp, *rbufp;
-	__uint16_t *bp, pageno;
+	__uint_least16_t *bp, pageno;
 	int key_done, n;
 
 	rbufp = bufp;
 	last_bfp = NULL;
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	pageno = 0;
 	key_done = 0;
 
@@ -219,7 +219,7 @@
 		last_bfp = rbufp;
 		if (!rbufp)
 			return (-1);		/* Error. */
-		bp = (__uint16_t *)rbufp->page;
+		bp = (__uint_least16_t *)rbufp->page;
 	}
 
 	/*
@@ -234,7 +234,7 @@
 	pageno = bp[n - 1];
 
 	/* Now, bp is the first page of the pair. */
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	if (n > 2) {
 		/* There is an overflow page. */
 		bp[1] = pageno;
@@ -272,13 +272,13 @@
 	char *key;
 	int size;
 {
-	__uint16_t *bp;
+	__uint_least16_t *bp;
 	char *p;
 	int ksize;
-	__uint16_t bytes;
+	__uint_least16_t bytes;
 	char *kkey;
 
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	p = bufp->page;
 	ksize = size;
 	kkey = key;
@@ -294,7 +294,7 @@
 		if (!bufp)
 			return (-3);
 		p = bufp->page;
-		bp = (__uint16_t *)p;
+		bp = (__uint_least16_t *)p;
 		ndx = 1;
 	}
 
@@ -316,17 +316,17 @@
  * of the pair; 0 if there isn't any (i.e. big pair is the last key in the
  * bucket)
  */
-extern __uint16_t
+extern __uint_least16_t
 __find_last_page(hashp, bpp)
 	HTAB *hashp;
 	BUFHEAD **bpp;
 {
 	BUFHEAD *bufp;
-	__uint16_t *bp, pageno;
+	__uint_least16_t *bp, pageno;
 	int n;
 
 	bufp = *bpp;
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	for (;;) {
 		n = bp[0];
 
@@ -343,7 +343,7 @@
 		bufp = __get_buf(hashp, pageno, bufp, 0);
 		if (!bufp)
 			return (0);	/* Need to indicate an error! */
-		bp = (__uint16_t *)bufp->page;
+		bp = (__uint_least16_t *)bufp->page;
 	}
 
 	*bpp = bufp;
@@ -366,15 +366,15 @@
 	int set_current;
 {
 	BUFHEAD *save_p;
-	__uint16_t *bp, len, off, save_addr;
+	__uint_least16_t *bp, len, off, save_addr;
 	char *tp;
 
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	while (bp[ndx + 1] == PARTIAL_KEY) {
 		bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 		if (!bufp)
 			return (-1);
-		bp = (__uint16_t *)bufp->page;
+		bp = (__uint_least16_t *)bufp->page;
 		ndx = 1;
 	}
 
@@ -382,7 +382,7 @@
 		bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 		if (!bufp)
 			return (-1);
-		bp = (__uint16_t *)bufp->page;
+		bp = (__uint_least16_t *)bufp->page;
 		save_p = bufp;
 		save_addr = save_p->addr;
 		off = bp[1];
@@ -403,7 +403,7 @@
 			bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 			if (!bufp)
 				return (-1);
-			bp = (__uint16_t *)bufp->page;
+			bp = (__uint_least16_t *)bufp->page;
 		} else {
 			/* The data is all on one page. */
 			tp = (char *)bp;
@@ -422,7 +422,7 @@
 					if (!hashp->cpage)
 						return (-1);
 					hashp->cndx = 1;
-					if (!((__uint16_t *)
+					if (!((__uint_least16_t *)
 					    hashp->cpage->page)[0]) {
 						hashp->cbucket++;
 						hashp->cpage = NULL;
@@ -454,14 +454,14 @@
 	BUFHEAD *bufp;
 	int len, set;
 {
-	__uint16_t *bp;
+	__uint_least16_t *bp;
 	char *p;
 	BUFHEAD *xbp;
-	__uint16_t save_addr;
+	__uint_least16_t save_addr;
 	int mylen, totlen;
 
 	p = bufp->page;
-	bp = (__uint16_t *)p;
+	bp = (__uint_least16_t *)p;
 	mylen = hashp->BSIZE - bp[1];
 	save_addr = bufp->addr;
 
@@ -481,7 +481,7 @@
 				    __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 				if (!hashp->cpage)
 					return (-1);
-				else if (!((__uint16_t *)hashp->cpage->page)[0]) {
+				else if (!((__uint_least16_t *)hashp->cpage->page)[0]) {
 					hashp->cbucket++;
 					hashp->cpage = NULL;
 				}
@@ -533,10 +533,10 @@
 	BUFHEAD *xbp;
 	char *p;
 	int mylen, totlen;
-	__uint16_t *bp, save_addr;
+	__uint_least16_t *bp, save_addr;
 
 	p = bufp->page;
-	bp = (__uint16_t *)p;
+	bp = (__uint_least16_t *)p;
 	mylen = hashp->BSIZE - bp[1];
 
 	save_addr = bufp->addr;
@@ -579,11 +579,11 @@
 	SPLIT_RETURN *ret;
 {
 	BUFHEAD *tmpp;
-	__uint16_t *tp;
+	__uint_least16_t *tp;
 	BUFHEAD *bp;
 	DBT key, val;
 	__uint32_t change;
-	__uint16_t free_space, n, off;
+	__uint_least16_t free_space, n, off;
 
 	bp = big_keyp;
 
@@ -615,14 +615,14 @@
 	    (tmpp->ovfl ? tmpp->ovfl->addr : 0), (bp ? bp->addr : 0));
 #endif
 	tmpp->ovfl = bp;	/* one of op/np point to big_keyp */
-	tp = (__uint16_t *)tmpp->page;
+	tp = (__uint_least16_t *)tmpp->page;
 #ifdef DEBUG
 	assert(FREESPACE(tp) >= OVFLSIZE);
 #endif
 	n = tp[0];
 	off = OFFSET(tp);
 	free_space = FREESPACE(tp);
-	tp[++n] = (__uint16_t)addr;
+	tp[++n] = (__uint_least16_t)addr;
 	tp[++n] = OVFLPAGE;
 	tp[0] = n;
 	OFFSET(tp) = off;
@@ -638,7 +638,7 @@
 	ret->newp = np;
 	ret->oldp = op;
 
-	tp = (__uint16_t *)big_keyp->page;
+	tp = (__uint_least16_t *)big_keyp->page;
 	big_keyp->flags |= BUF_MOD;
 	if (tp[0] > 2) {
 		/*
diff -Naur newlib-1.16.0.orig/newlib/libc/search/hash_buf.c newlib-1.16.0/newlib/libc/search/hash_buf.c
--- newlib-1.16.0.orig/newlib/libc/search/hash_buf.c	2004-05-26 19:57:10.000000000 +0200
+++ newlib-1.16.0/newlib/libc/search/hash_buf.c	2008-03-03 08:36:14.000000000 +0100
@@ -176,7 +176,7 @@
 	BUFHEAD *next_xbp;
 	SEGMENT segp;
 	int segment_ndx;
-	__uint16_t oaddr, *shortp;
+	__uint_least16_t oaddr, *shortp;
 
 	oaddr = 0;
 	bp = LRU;
@@ -212,7 +212,7 @@
 			 * Set oaddr before __put_page so that you get it
 			 * before bytes are swapped.
 			 */
-			shortp = (__uint16_t *)bp->page;
+			shortp = (__uint_least16_t *)bp->page;
 			if (shortp[0])
 				oaddr = shortp[shortp[0] - 1];
 			if ((bp->flags & BUF_MOD) && __put_page(hashp, bp->page,
@@ -255,7 +255,7 @@
 				    (oaddr != xbp->addr))
 					break;
 
-				shortp = (__uint16_t *)xbp->page;
+				shortp = (__uint_least16_t *)xbp->page;
 				if (shortp[0])
 					/* set before __put_page */
 					oaddr = shortp[shortp[0] - 1];
diff -Naur newlib-1.16.0.orig/newlib/libc/search/hash.c newlib-1.16.0/newlib/libc/search/hash.c
--- newlib-1.16.0.orig/newlib/libc/search/hash.c	2007-05-16 21:31:08.000000000 +0200
+++ newlib-1.16.0/newlib/libc/search/hash.c	2008-03-03 08:36:14.000000000 +0100
@@ -632,10 +632,10 @@
 {
 	BUFHEAD *rbufp;
 	BUFHEAD *bufp, *save_bufp;
-	__uint16_t *bp;
+	__uint_least16_t *bp;
 	int n, ndx, off, size;
 	char *kp;
-	__uint16_t pageno;
+	__uint_least16_t pageno;
 
 #ifdef HASH_STATISTICS
 	hash_accesses++;
@@ -651,7 +651,7 @@
 
 	/* Pin the bucket chain */
 	rbufp->flags |= BUF_PIN;
-	for (bp = (__uint16_t *)rbufp->page, n = *bp++, ndx = 1; ndx < n;)
+	for (bp = (__uint_least16_t *)rbufp->page, n = *bp++, ndx = 1; ndx < n;)
 		if (bp[1] >= REAL_KEY) {
 			/* Real key/data pair */
 			if (size == off - *bp &&
@@ -670,7 +670,7 @@
 				return (ERROR);
 			}
 			/* FOR LOOP INIT */
-			bp = (__uint16_t *)rbufp->page;
+			bp = (__uint_least16_t *)rbufp->page;
 			n = *bp++;
 			ndx = 1;
 			off = hashp->BSIZE;
@@ -692,7 +692,7 @@
 					return (ERROR);
 				}
 				/* FOR LOOP INIT */
-				bp = (__uint16_t *)rbufp->page;
+				bp = (__uint_least16_t *)rbufp->page;
 				n = *bp++;
 				ndx = 1;
 				off = hashp->BSIZE;
@@ -726,7 +726,7 @@
 		save_bufp->flags &= ~BUF_PIN;
 		return (ABNORMAL);
 	case HASH_GET:
-		bp = (__uint16_t *)rbufp->page;
+		bp = (__uint_least16_t *)rbufp->page;
 		if (bp[ndx + 1] < REAL_KEY) {
 			if (__big_return(hashp, rbufp, ndx, val, 0))
 				return (ERROR);
@@ -762,7 +762,7 @@
 	__uint32_t bucket;
 	BUFHEAD *bufp;
 	HTAB *hashp;
-	__uint16_t *bp, ndx;
+	__uint_least16_t *bp, ndx;
 
 	hashp = (HTAB *)dbp->internal;
 	if (flag && flag != R_FIRST && flag != R_NEXT) {
@@ -787,7 +787,7 @@
 				if (!bufp)
 					return (ERROR);
 				hashp->cpage = bufp;
-				bp = (__uint16_t *)bufp->page;
+				bp = (__uint_least16_t *)bufp->page;
 				if (bp[0])
 					break;
 			}
@@ -797,7 +797,7 @@
 				return (ABNORMAL);
 			}
 		} else
-			bp = (__uint16_t *)hashp->cpage->page;
+			bp = (__uint_least16_t *)hashp->cpage->page;
 
 #ifdef DEBUG
 		assert(bp);
@@ -808,7 +808,7 @@
 			    __get_buf(hashp, bp[hashp->cndx], bufp, 0);
 			if (!bufp)
 				return (ERROR);
-			bp = (__uint16_t *)(bufp->page);
+			bp = (__uint_least16_t *)(bufp->page);
 			hashp->cndx = 1;
 		}
 		if (!bp[0]) {
diff -Naur newlib-1.16.0.orig/newlib/libc/search/hash.h newlib-1.16.0/newlib/libc/search/hash.h
--- newlib-1.16.0.orig/newlib/libc/search/hash.h	2002-07-02 20:18:58.000000000 +0200
+++ newlib-1.16.0/newlib/libc/search/hash.h	2008-03-03 08:36:14.000000000 +0100
@@ -102,7 +102,7 @@
 #define NCACHED	32			/* number of bit maps and spare 
 					 * points */
 	int		spares[NCACHED];/* spare pages for overflow */
-	__uint16_t	bitmaps[NCACHED];	/* address of overflow page 
+	__uint_least16_t	bitmaps[NCACHED];	/* address of overflow page 
 						 * bitmaps */
 } HASHHDR;
 
diff -Naur newlib-1.16.0.orig/newlib/libc/search/hash_page.c newlib-1.16.0/newlib/libc/search/hash_page.c
--- newlib-1.16.0.orig/newlib/libc/search/hash_page.c	2002-09-19 23:28:51.000000000 +0200
+++ newlib-1.16.0/newlib/libc/search/hash_page.c	2008-03-03 08:36:14.000000000 +0100
@@ -77,16 +77,16 @@
 static __uint32_t	*fetch_bitmap(HTAB *, int);
 static __uint32_t	 first_free(__uint32_t);
 static int	 open_temp(HTAB *);
-static __uint16_t	 overflow_page(HTAB *);
+static __uint_least16_t	 overflow_page(HTAB *);
 static void	 putpair(char *, const DBT *, const DBT *);
-static void	 squeeze_key(__uint16_t *, const DBT *, const DBT *);
+static void	 squeeze_key(__uint_least16_t *, const DBT *, const DBT *);
 static int	 ugly_split
 (HTAB *, __uint32_t, BUFHEAD *, BUFHEAD *, int, int);
 
 #define	PAGE_INIT(P) { \
-	((__uint16_t *)(P))[0] = 0; \
-	((__uint16_t *)(P))[1] = hashp->BSIZE - 3 * sizeof(__uint16_t); \
-	((__uint16_t *)(P))[2] = hashp->BSIZE; \
+	((__uint_least16_t *)(P))[0] = 0; \
+	((__uint_least16_t *)(P))[1] = hashp->BSIZE - 3 * sizeof(__uint_least16_t); \
+	((__uint_least16_t *)(P))[2] = hashp->BSIZE; \
 }
 
 /*
@@ -99,9 +99,9 @@
 	char *p;
 	const DBT *key, *val;
 {
-	__uint16_t *bp, n, off;
+	__uint_least16_t *bp, n, off;
 
-	bp = (__uint16_t *)p;
+	bp = (__uint_least16_t *)p;
 
 	/* Enter the key first. */
 	n = bp[0];
@@ -117,7 +117,7 @@
 
 	/* Adjust page info. */
 	bp[0] = n;
-	bp[n + 1] = off - ((n + 3) * sizeof(__uint16_t));
+	bp[n + 1] = off - ((n + 3) * sizeof(__uint_least16_t));
 	bp[n + 2] = off;
 }
 
@@ -132,11 +132,11 @@
 	BUFHEAD *bufp;
 	int ndx;
 {
-	__uint16_t *bp, newoff;
+	__uint_least16_t *bp, newoff;
 	int n;
-	__uint16_t pairlen;
+	__uint_least16_t pairlen;
 
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	n = bp[0];
 
 	if (bp[ndx + 1] < REAL_KEY)
@@ -167,7 +167,7 @@
 	}
 	/* Finally adjust the page data */
 	bp[n] = OFFSET(bp) + pairlen;
-	bp[n - 1] = bp[n + 1] + pairlen + 2 * sizeof(__uint16_t);
+	bp[n - 1] = bp[n + 1] + pairlen + 2 * sizeof(__uint_least16_t);
 	bp[0] = n - 2;
 	hashp->NKEYS--;
 
@@ -185,15 +185,15 @@
 	__uint32_t obucket, nbucket;
 {
 	BUFHEAD *new_bufp, *old_bufp;
-	__uint16_t *ino;
+	__uint_least16_t *ino;
 	char *np;
 	DBT key, val;
 	int n, ndx, retval;
-	__uint16_t copyto, diff, off, moved;
+	__uint_least16_t copyto, diff, off, moved;
 	char *op;
 
-	copyto = (__uint16_t)hashp->BSIZE;
-	off = (__uint16_t)hashp->BSIZE;
+	copyto = (__uint_least16_t)hashp->BSIZE;
+	off = (__uint_least16_t)hashp->BSIZE;
 	old_bufp = __get_buf(hashp, obucket, NULL, 0);
 	if (old_bufp == NULL)
 		return (-1);
@@ -204,7 +204,7 @@
 	old_bufp->flags |= (BUF_MOD | BUF_PIN);
 	new_bufp->flags |= (BUF_MOD | BUF_PIN);
 
-	ino = (__uint16_t *)(op = old_bufp->page);
+	ino = (__uint_least16_t *)(op = old_bufp->page);
 	np = new_bufp->page;
 
 	moved = 0;
@@ -246,13 +246,13 @@
 
 	/* Now clean up the page */
 	ino[0] -= moved;
-	FREESPACE(ino) = copyto - sizeof(__uint16_t) * (ino[0] + 3);
+	FREESPACE(ino) = copyto - sizeof(__uint_least16_t) * (ino[0] + 3);
 	OFFSET(ino) = copyto;
 
 #ifdef DEBUG3
 	(void)fprintf(stderr, "split %d/%d\n",
-	    ((__uint16_t *)np)[0] / 2,
-	    ((__uint16_t *)op)[0] / 2);
+	    ((__uint_least16_t *)np)[0] / 2,
+	    ((__uint_least16_t *)op)[0] / 2);
 #endif
 	/* unpin both pages */
 	old_bufp->flags &= ~BUF_PIN;
@@ -284,22 +284,22 @@
 	int moved;		/* Number of pairs moved to new page. */
 {
 	BUFHEAD *bufp;		/* Buffer header for ino */
-	__uint16_t *ino;		/* Page keys come off of */
-	__uint16_t *np;		/* New page */
-	__uint16_t *op;		/* Page keys go on to if they aren't moving */
+	__uint_least16_t *ino;		/* Page keys come off of */
+	__uint_least16_t *np;		/* New page */
+	__uint_least16_t *op;		/* Page keys go on to if they aren't moving */
 
 	BUFHEAD *last_bfp;	/* Last buf header OVFL needing to be freed */
 	DBT key, val;
 	SPLIT_RETURN ret;
-	__uint16_t n, off, ov_addr, scopyto;
+	__uint_least16_t n, off, ov_addr, scopyto;
 	char *cino;		/* Character value of ino */
 
 	bufp = old_bufp;
-	ino = (__uint16_t *)old_bufp->page;
-	np = (__uint16_t *)new_bufp->page;
-	op = (__uint16_t *)old_bufp->page;
+	ino = (__uint_least16_t *)old_bufp->page;
+	np = (__uint_least16_t *)new_bufp->page;
+	op = (__uint_least16_t *)old_bufp->page;
 	last_bfp = NULL;
-	scopyto = (__uint16_t)copyto;	/* ANSI */
+	scopyto = (__uint_least16_t)copyto;	/* ANSI */
 
 	n = ino[0] - 1;
 	while (n < ino[0]) {
@@ -310,16 +310,16 @@
 			old_bufp = ret.oldp;
 			if (!old_bufp)
 				return (-1);
-			op = (__uint16_t *)old_bufp->page;
+			op = (__uint_least16_t *)old_bufp->page;
 			new_bufp = ret.newp;
 			if (!new_bufp)
 				return (-1);
-			np = (__uint16_t *)new_bufp->page;
+			np = (__uint_least16_t *)new_bufp->page;
 			bufp = ret.nextp;
 			if (!bufp)
 				return (0);
 			cino = (char *)bufp->page;
-			ino = (__uint16_t *)cino;
+			ino = (__uint_least16_t *)cino;
 			last_bfp = ret.nextp;
 		} else if (ino[n + 1] == OVFLPAGE) {
 			ov_addr = ino[n];
@@ -329,14 +329,14 @@
 			 */
 			ino[0] -= (moved + 2);
 			FREESPACE(ino) =
-			    scopyto - sizeof(__uint16_t) * (ino[0] + 3);
+			    scopyto - sizeof(__uint_least16_t) * (ino[0] + 3);
 			OFFSET(ino) = scopyto;
 
 			bufp = __get_buf(hashp, ov_addr, bufp, 0);
 			if (!bufp)
 				return (-1);
 
-			ino = (__uint16_t *)bufp->page;
+			ino = (__uint_least16_t *)bufp->page;
 			n = 1;
 			scopyto = hashp->BSIZE;
 			moved = 0;
@@ -364,7 +364,7 @@
 					    __add_ovflpage(hashp, old_bufp);
 					if (!old_bufp)
 						return (-1);
-					op = (__uint16_t *)old_bufp->page;
+					op = (__uint_least16_t *)old_bufp->page;
 					putpair((char *)op, &key, &val);
 				}
 				old_bufp->flags |= BUF_MOD;
@@ -377,7 +377,7 @@
 					    __add_ovflpage(hashp, new_bufp);
 					if (!new_bufp)
 						return (-1);
-					np = (__uint16_t *)new_bufp->page;
+					np = (__uint_least16_t *)new_bufp->page;
 					putpair((char *)np, &key, &val);
 				}
 				new_bufp->flags |= BUF_MOD;
@@ -402,10 +402,10 @@
 	BUFHEAD *bufp;
 	const DBT *key, *val;
 {
-	__uint16_t *bp, *sop;
+	__uint_least16_t *bp, *sop;
 	int do_expand;
 
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	do_expand = 0;
 	while (bp[0] && (bp[2] < REAL_KEY || bp[bp[0]] < REAL_KEY))
 		/* Exception case */
@@ -417,7 +417,7 @@
 			bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 			if (!bufp)
 				return (-1);
-			bp = (__uint16_t *)bufp->page;
+			bp = (__uint_least16_t *)bufp->page;
 		} else
 			/* Try to squeeze key on this page */
 			if (FREESPACE(bp) > PAIRSIZE(key, val)) {
@@ -427,7 +427,7 @@
 				bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 				if (!bufp)
 					return (-1);
-				bp = (__uint16_t *)bufp->page;
+				bp = (__uint_least16_t *)bufp->page;
 			}
 
 	if (PAIRFITS(bp, key, val))
@@ -437,7 +437,7 @@
 		bufp = __add_ovflpage(hashp, bufp);
 		if (!bufp)
 			return (-1);
-		sop = (__uint16_t *)bufp->page;
+		sop = (__uint_least16_t *)bufp->page;
 
 		if (PAIRFITS(sop, key, val))
 			putpair((char *)sop, key, val);
@@ -468,12 +468,12 @@
 	HTAB *hashp;
 	BUFHEAD *bufp;
 {
-	__uint16_t *sp;
-	__uint16_t ndx, ovfl_num;
+	__uint_least16_t *sp;
+	__uint_least16_t ndx, ovfl_num;
 #ifdef DEBUG1
 	int tmp1, tmp2;
 #endif
-	sp = (__uint16_t *)bufp->page;
+	sp = (__uint_least16_t *)bufp->page;
 
 	/* Check if we are dynamically determining the fill factor */
 	if (hashp->FFACTOR == DEF_FFACTOR) {
@@ -525,7 +525,7 @@
 {
 	int fd, page, size;
 	int rsize;
-	__uint16_t *bp;
+	__uint_least16_t *bp;
 
 	fd = hashp->fp;
 	size = hashp->BSIZE;
@@ -541,7 +541,7 @@
 	if ((lseek(fd, (off_t)page << hashp->BSHIFT, SEEK_SET) == -1) ||
 	    ((rsize = read(fd, p, size)) == -1))
 		return (-1);
-	bp = (__uint16_t *)p;
+	bp = (__uint_least16_t *)p;
 	if (!rsize)
 		bp[0] = 0;	/* We hit the EOF, so initialize a new page */
 	else
@@ -600,9 +600,9 @@
 			for (i = 0; i < max; i++)
 				M_32_SWAP(((int *)p)[i]);
 		} else {
-			max = ((__uint16_t *)p)[0] + 2;
+			max = ((__uint_least16_t *)p)[0] + 2;
 			for (i = 0; i <= max; i++)
-				M_16_SWAP(((__uint16_t *)p)[i]);
+				M_16_SWAP(((__uint_least16_t *)p)[i]);
 		}
 	}
 	if (is_bucket)
@@ -643,7 +643,7 @@
 	    hashp->BSIZE - clearbytes);
 	ip[clearints - 1] = ALL_SET << (nbits & BYTE_MASK);
 	SETBIT(ip, 0);
-	hashp->BITMAPS[ndx] = (__uint16_t)pnum;
+	hashp->BITMAPS[ndx] = (__uint_least16_t)pnum;
 	hashp->mapp[ndx] = ip;
 	return (0);
 }
@@ -663,13 +663,13 @@
 	return (i);
 }
 
-static __uint16_t
+static __uint_least16_t
 overflow_page(hashp)
 	HTAB *hashp;
 {
 	__uint32_t *freep;
 	int max_free, offset, splitnum;
-	__uint16_t addr;
+	__uint_least16_t addr;
 	int bit, first_page, free_bit, free_page, i, in_use_bits, j;
 #ifdef DEBUG2
 	int tmp1, tmp2;
@@ -816,16 +816,16 @@
 	HTAB *hashp;
 	BUFHEAD *obufp;
 {
-	__uint16_t addr;
+	__uint_least16_t addr;
 	__uint32_t *freep;
 	int bit_address, free_page, free_bit;
-	__uint16_t ndx;
+	__uint_least16_t ndx;
 
 	addr = obufp->addr;
 #ifdef DEBUG1
 	(void)fprintf(stderr, "Freeing %d\n", addr);
 #endif
-	ndx = (((__uint16_t)addr) >> SPLITSHIFT);
+	ndx = (((__uint_least16_t)addr) >> SPLITSHIFT);
 	bit_address =
 	    (ndx ? hashp->SPARES[ndx - 1] : 0) + (addr & SPLITMASK) - 1;
 	 if (bit_address < hashp->LAST_FREED)
@@ -883,11 +883,11 @@
  */
 static void
 squeeze_key(sp, key, val)
-	__uint16_t *sp;
+	__uint_least16_t *sp;
 	const DBT *key, *val;
 {
 	char *p;
-	__uint16_t free_space, n, off, pageno;
+	__uint_least16_t free_space, n, off, pageno;
 
 	p = (char *)sp;
 	n = sp[0];
diff -Naur newlib-1.16.0.orig/newlib/libc/search/page.h newlib-1.16.0/newlib/libc/search/page.h
--- newlib-1.16.0.orig/newlib/libc/search/page.h	2002-06-20 21:51:31.000000000 +0200
+++ newlib-1.16.0/newlib/libc/search/page.h	2008-03-03 08:36:14.000000000 +0100
@@ -74,20 +74,20 @@
  * You might as well do this up front.
  */
 
-#define	PAIRSIZE(K,D)	(2*sizeof(__uint16_t) + (K)->size + (D)->size)
-#define BIGOVERHEAD	(4*sizeof(__uint16_t))
-#define KEYSIZE(K)	(4*sizeof(__uint16_t) + (K)->size);
-#define OVFLSIZE	(2*sizeof(__uint16_t))
+#define	PAIRSIZE(K,D)	(2*sizeof(__uint_least16_t) + (K)->size + (D)->size)
+#define BIGOVERHEAD	(4*sizeof(__uint_least16_t))
+#define KEYSIZE(K)	(4*sizeof(__uint_least16_t) + (K)->size);
+#define OVFLSIZE	(2*sizeof(__uint_least16_t))
 #define FREESPACE(P)	((P)[(P)[0]+1])
 #define	OFFSET(P)	((P)[(P)[0]+2])
 #define PAIRFITS(P,K,D) \
 	(((P)[2] >= REAL_KEY) && \
 	    (PAIRSIZE((K),(D)) + OVFLSIZE) <= FREESPACE((P)))
-#define PAGE_META(N)	(((N)+3) * sizeof(__uint16_t))
+#define PAGE_META(N)	(((N)+3) * sizeof(__uint_least16_t))
 
 typedef struct {
 	BUFHEAD *newp;
 	BUFHEAD *oldp;
 	BUFHEAD *nextp;
-	__uint16_t next_addr;
+	__uint_least16_t next_addr;
 }       SPLIT_RETURN;
diff -Naur newlib-1.16.0.orig/newlib/libc/stdlib/getopt.c newlib-1.16.0/newlib/libc/stdlib/getopt.c
--- newlib-1.16.0.orig/newlib/libc/stdlib/getopt.c	2007-05-29 23:26:59.000000000 +0200
+++ newlib-1.16.0/newlib/libc/stdlib/getopt.c	2008-03-03 08:36:14.000000000 +0100
@@ -90,6 +90,9 @@
 #include <getopt.h>
 
 /* macros */
+#define NO_ARG          	0
+#define REQUIRED_ARG    	1
+#define OPTIONAL_ARG    	2
 
 /* types */
 typedef enum GETOPT_ORDERING_T
@@ -100,16 +103,19 @@
 } GETOPT_ORDERING_T;
 
 /* globally-defined variables */
-char *optarg = NULL;
+char *optarg = 0;
 int optind = 0;
 int opterr = 1;
 int optopt = '?';
 
+/* static variables */
+static int optwhere = 0;
+
 /* functions */
 
 /* reverse_argv_elements:  reverses num elements starting at argv */
 static void
-reverse_argv_elements (char ** argv, int num)
+reverse_argv_elements (char **argv, int num)
 {
   int i;
   char *tmp;
@@ -126,281 +132,346 @@
 static void
 permute (char *const argv[], int len1, int len2)
 {
-  reverse_argv_elements ((char **)argv, len1);
-  reverse_argv_elements ((char **)argv, len1 + len2);
-  reverse_argv_elements ((char **)argv, len2);
+  reverse_argv_elements ((char **) argv, len1);
+  reverse_argv_elements ((char **) argv, len1 + len2);
+  reverse_argv_elements ((char **) argv, len2);
 }
 
 /* is_option: is this argv-element an option or the end of the option list? */
 static int
 is_option (char *argv_element, int only)
 {
-  return ((argv_element == NULL)
-          || (argv_element[0] == '-') || (only && argv_element[0] == '+'));
+  return ((argv_element == 0)
+	  || (argv_element[0] == '-') || (only && argv_element[0] == '+'));
+}
+
+/* read_globals: read the values from the globals into a getopt_data 
+   structure */
+static void
+read_globals (struct getopt_data *data)
+{
+  data->optarg = optarg;
+  data->optind = optind;
+  data->opterr = opterr;
+  data->optopt = optopt;
+  data->optwhere = optwhere;
+}
+
+/* write_globals: write the values into the globals from a getopt_data
+   structure */
+static void
+write_globals (struct getopt_data *data)
+{
+  optarg = data->optarg;
+  optind = data->optind;
+  opterr = data->opterr;
+  optopt = data->optopt;
+  optwhere = data->optwhere;
 }
 
 /* getopt_internal:  the function that does all the dirty work */
 static int
 getopt_internal (int argc, char *const argv[], const char *shortopts,
-                 const struct option *longopts, int *longind, int only)
+		 const struct option *longopts, int *longind, int only,
+		 struct getopt_data *data)
 {
   GETOPT_ORDERING_T ordering = PERMUTE;
-  static size_t optwhere = 0;
   size_t permute_from = 0;
   int num_nonopts = 0;
   int optindex = 0;
   size_t match_chars = 0;
-  char *possible_arg = NULL;
+  char *possible_arg = 0;
   int longopt_match = -1;
   int has_arg = -1;
-  char *cp = NULL;
+  char *cp = 0;
   int arg_next = 0;
 
   /* first, deal with silly parameters and easy stuff */
-  if (argc == 0 || argv == NULL || (shortopts == NULL && longopts == NULL))
-    return EOF;
-  if (optind >= argc || argv[optind] == NULL)
+  if (argc == 0 || argv == 0 || (shortopts == 0 && longopts == 0)
+      || data->optind >= argc || argv[data->optind] == 0)
     return EOF;
-  if (strcmp (argv[optind], "--") == 0)
+  if (strcmp (argv[data->optind], "--") == 0)
     {
-      optind++;
+      data->optind++;
       return EOF;
     }
+
   /* if this is our first time through */
-  if (optind == 0)
-    optind = optwhere = 1;
+  if (data->optind == 0)
+    data->optind = data->optwhere = 1;
 
   /* define ordering */
-  if (shortopts != NULL && (*shortopts == '-' || *shortopts == '+'))
+  if (shortopts != 0 && (*shortopts == '-' || *shortopts == '+'))
     {
       ordering = (*shortopts == '-') ? RETURN_IN_ORDER : REQUIRE_ORDER;
       shortopts++;
     }
   else
-    ordering = (getenv ("POSIXLY_CORRECT") != NULL) ? REQUIRE_ORDER : PERMUTE;
+    ordering = (getenv ("POSIXLY_CORRECT") != 0) ? REQUIRE_ORDER : PERMUTE;
 
   /*
    * based on ordering, find our next option, if we're at the beginning of
    * one
    */
-  if (optwhere == 1)
+  if (data->optwhere == 1)
     {
       switch (ordering)
-        {
-        case PERMUTE:
-          permute_from = optind;
-          num_nonopts = 0;
-          while (!is_option (argv[optind], only))
-            {
-              optind++;
-              num_nonopts++;
-            }
-          if (argv[optind] == NULL)
-            {
-              /* no more options */
-              optind = permute_from;
-              return EOF;
-            }
-          else if (strcmp (argv[optind], "--") == 0)
-            {
-              /* no more options, but have to get `--' out of the way */
-              permute (argv + permute_from, num_nonopts, 1);
-              optind = permute_from + 1;
-              return EOF;
-            }
-          break;
-        case RETURN_IN_ORDER:
-          if (!is_option (argv[optind], only))
-            {
-              optarg = argv[optind++];
-              return (optopt = 1);
-            }
-          break;
-        case REQUIRE_ORDER:
-          if (!is_option (argv[optind], only))
-            return EOF;
-          break;
-        }
+	{
+	default:		/* shouldn't happen */
+	case PERMUTE:
+	  permute_from = data->optind;
+	  num_nonopts = 0;
+	  while (!is_option (argv[data->optind], only))
+	    {
+	      data->optind++;
+	      num_nonopts++;
+	    }
+	  if (argv[data->optind] == 0)
+	    {
+	      /* no more options */
+	      data->optind = permute_from;
+	      return EOF;
+	    }
+	  else if (strcmp (argv[data->optind], "--") == 0)
+	    {
+	      /* no more options, but have to get `--' out of the way */
+	      permute (argv + permute_from, num_nonopts, 1);
+	      data->optind = permute_from + 1;
+	      return EOF;
+	    }
+	  break;
+	case RETURN_IN_ORDER:
+	  if (!is_option (argv[data->optind], only))
+	    {
+	      data->optarg = argv[data->optind++];
+	      return (data->optopt = 1);
+	    }
+	  break;
+	case REQUIRE_ORDER:
+	  if (!is_option (argv[data->optind], only))
+	    return EOF;
+	  break;
+	}
     }
   /* we've got an option, so parse it */
 
   /* first, is it a long option? */
-  if (longopts != NULL
-      && (memcmp (argv[optind], "--", 2) == 0
-          || (only && argv[optind][0] == '+')) && optwhere == 1)
+  if (longopts != 0
+      && (memcmp (argv[data->optind], "--", 2) == 0
+	  || (only && argv[data->optind][0] == '+')) && data->optwhere == 1)
     {
       /* handle long options */
-      if (memcmp (argv[optind], "--", 2) == 0)
-        optwhere = 2;
+      if (memcmp (argv[data->optind], "--", 2) == 0)
+	data->optwhere = 2;
       longopt_match = -1;
-      possible_arg = strchr (argv[optind] + optwhere, '=');
-      if (possible_arg == NULL)
-        {
-          /* no =, so next argv might be arg */
-          match_chars = strlen (argv[optind]);
-          possible_arg = argv[optind] + match_chars;
-          match_chars = match_chars - optwhere;
-        }
+      possible_arg = strchr (argv[data->optind] + data->optwhere, '=');
+      if (possible_arg == 0)
+	{
+	  /* no =, so next argv might be arg */
+	  match_chars = strlen (argv[data->optind]);
+	  possible_arg = argv[data->optind] + match_chars;
+	  match_chars = match_chars - data->optwhere;
+	}
       else
-        match_chars = (possible_arg - argv[optind]) - optwhere;
-      for (optindex = 0; longopts[optindex].name != NULL; optindex++)
-        {
-          if (memcmp (argv[optind] + optwhere,
-                      longopts[optindex].name, match_chars) == 0)
-            {
-              /* do we have an exact match? */
-              if (match_chars == (int) (strlen (longopts[optindex].name)))
-                {
-                  longopt_match = optindex;
-                  break;
-                }
-              /* do any characters match? */
-              else
-                {
-                  if (longopt_match < 0)
-                    longopt_match = optindex;
-                  else
-                    {
-                      /* we have ambiguous options */
-                      if (opterr)
-                        fprintf (stderr, "%s: option `%s' is ambiguous "
-                                 "(could be `--%s' or `--%s')\n",
-                                 argv[0],
-                                 argv[optind],
-                                 longopts[longopt_match].name,
-                                 longopts[optindex].name);
-                      return (optopt = '?');
-                    }
-                }
-            }
-        }
+	match_chars = (possible_arg - argv[data->optind]) - data->optwhere;
+      for (optindex = 0; longopts[optindex].name != 0; ++optindex)
+	{
+	  if (memcmp
+	      (argv[data->optind] + data->optwhere, longopts[optindex].name,
+	       match_chars) == 0)
+	    {
+	      /* do we have an exact match? */
+	      if (match_chars == (int) (strlen (longopts[optindex].name)))
+		{
+		  longopt_match = optindex;
+		  break;
+		}
+	      /* do any characters match? */
+	      else
+		{
+		  if (longopt_match < 0)
+		    longopt_match = optindex;
+		  else
+		    {
+		      /* we have ambiguous options */
+		      if (data->opterr)
+			fprintf (stderr, "%s: option `%s' is ambiguous "
+				 "(could be `--%s' or `--%s')\n",
+				 argv[0],
+				 argv[data->optind],
+				 longopts[longopt_match].name,
+				 longopts[optindex].name);
+		      return (data->optopt = '?');
+		    }
+		}
+	    }
+	}
       if (longopt_match >= 0)
-        has_arg = longopts[longopt_match].has_arg;
+	has_arg = longopts[longopt_match].has_arg;
     }
+
   /* if we didn't find a long option, is it a short option? */
-  if (longopt_match < 0 && shortopts != NULL)
+  if (longopt_match < 0 && shortopts != 0)
     {
-      cp = strchr (shortopts, argv[optind][optwhere]);
-      if (cp == NULL)
-        {
-          /* couldn't find option in shortopts */
-          if (opterr)
-            fprintf (stderr,
-                     "%s: invalid option -- `-%c'\n",
-                     argv[0], argv[optind][optwhere]);
-          optwhere++;
-          if (argv[optind][optwhere] == '\0')
-            {
-              optind++;
-              optwhere = 1;
-            }
-          return (optopt = '?');
-        }
+      cp = strchr (shortopts, argv[data->optind][data->optwhere]);
+      if (cp == 0)
+	{
+	  /* couldn't find option in shortopts */
+	  if (data->opterr)
+	    fprintf (stderr,
+		     "%s: invalid option -- `-%c'\n",
+		     argv[0], argv[data->optind][data->optwhere]);
+	  data->optwhere++;
+	  if (argv[data->optind][data->optwhere] == '\0')
+	    {
+	      data->optind++;
+	      data->optwhere = 1;
+	    }
+	  return (data->optopt = '?');
+	}
       has_arg = ((cp[1] == ':')
-                 ? ((cp[2] == ':') ? OPTIONAL_ARG : REQUIRED_ARG) : NO_ARG);
-      possible_arg = argv[optind] + optwhere + 1;
-      optopt = *cp;
+		 ? ((cp[2] == ':') ? OPTIONAL_ARG : REQUIRED_ARG) : NO_ARG);
+      possible_arg = argv[data->optind] + data->optwhere + 1;
+      data->optopt = *cp;
     }
-  /* get argument and reset optwhere */
+
+  /* get argument and reset data->optwhere */
   arg_next = 0;
   switch (has_arg)
     {
     case OPTIONAL_ARG:
       if (*possible_arg == '=')
-        possible_arg++;
-      if (*possible_arg != '\0')
-        {
-          optarg = possible_arg;
-          optwhere = 1;
-        }
-      else
-        optarg = NULL;
+	possible_arg++;
+      data->optarg = (*possible_arg != '\0') ? possible_arg : 0;
+      data->optwhere = 1;
       break;
     case REQUIRED_ARG:
       if (*possible_arg == '=')
-        possible_arg++;
+	possible_arg++;
       if (*possible_arg != '\0')
-        {
-          optarg = possible_arg;
-          optwhere = 1;
-        }
-      else if (optind + 1 >= argc)
-        {
-          if (opterr)
-            {
-              fprintf (stderr, "%s: argument required for option `", argv[0]);
-              if (longopt_match >= 0)
-                fprintf (stderr, "--%s'\n", longopts[longopt_match].name);
-              else
-                fprintf (stderr, "-%c'\n", *cp);
-            }
-          optind++;
-          return (optopt = ':');
-        }
+	{
+	  data->optarg = possible_arg;
+	  data->optwhere = 1;
+	}
+      else if (data->optind + 1 >= argc)
+	{
+	  if (data->opterr)
+	    {
+	      fprintf (stderr, "%s: argument required for option `", argv[0]);
+	      if (longopt_match >= 0)
+		fprintf (stderr, "--%s'\n", longopts[longopt_match].name);
+	      else
+		fprintf (stderr, "-%c'\n", *cp);
+	    }
+	  data->optind++;
+	  return (data->optopt = ':');
+	}
       else
-        {
-          optarg = argv[optind + 1];
-          arg_next = 1;
-          optwhere = 1;
-        }
+	{
+	  data->optarg = argv[data->optind + 1];
+	  arg_next = 1;
+	  data->optwhere = 1;
+	}
       break;
+    default:			/* shouldn't happen */
     case NO_ARG:
       if (longopt_match < 0)
-        {
-          optwhere++;
-          if (argv[optind][optwhere] == '\0')
-            optwhere = 1;
-        }
+	{
+	  data->optwhere++;
+	  if (argv[data->optind][data->optwhere] == '\0')
+	    data->optwhere = 1;
+	}
       else
-        optwhere = 1;
-      optarg = NULL;
+	data->optwhere = 1;
+      data->optarg = 0;
       break;
     }
 
-  /* do we have to permute or otherwise modify optind? */
-  if (ordering == PERMUTE && optwhere == 1 && num_nonopts != 0)
+  /* do we have to permute or otherwise modify data->optind? */
+  if (ordering == PERMUTE && data->optwhere == 1 && num_nonopts != 0)
     {
       permute (argv + permute_from, num_nonopts, 1 + arg_next);
-      optind = permute_from + 1 + arg_next;
+      data->optind = permute_from + 1 + arg_next;
     }
-  else if (optwhere == 1)
-    optind = optind + 1 + arg_next;
+  else if (data->optwhere == 1)
+    data->optind = data->optind + 1 + arg_next;
 
   /* finally return */
   if (longopt_match >= 0)
     {
-      if (longind != NULL)
-        *longind = longopt_match;
-      if (longopts[longopt_match].flag != NULL)
-        {
-          *(longopts[longopt_match].flag) = longopts[longopt_match].val;
-          return 0;
-        }
+      if (longind != 0)
+	*longind = longopt_match;
+      if (longopts[longopt_match].flag != 0)
+	{
+	  *(longopts[longopt_match].flag) = longopts[longopt_match].val;
+	  return 0;
+	}
       else
-        return longopts[longopt_match].val;
+	return longopts[longopt_match].val;
     }
   else
-    return optopt;
+    return data->optopt;
 }
 
 int
 getopt (int argc, char *const argv[], const char *optstring)
 {
-  return getopt_internal (argc, argv, optstring, NULL, NULL, 0);
+  struct getopt_data data;
+  int r;
+
+  read_globals (&data);
+  r = getopt_internal (argc, argv, optstring, 0, 0, 0, &data);
+  write_globals (&data);
+  return r;
 }
 
 int
 getopt_long (int argc, char *const argv[], const char *shortopts,
-             const struct option *longopts, int *longind)
+	     const struct option *longopts, int *longind)
 {
-  return getopt_internal (argc, argv, shortopts, longopts, longind, 0);
+  struct getopt_data data;
+  int r;
+
+  read_globals (&data);
+  r = getopt_internal (argc, argv, shortopts, longopts, longind, 0, &data);
+  write_globals (&data);
+  return r;
 }
 
 int
 getopt_long_only (int argc, char *const argv[], const char *shortopts,
-                  const struct option *longopts, int *longind)
+		  const struct option *longopts, int *longind)
+{
+  struct getopt_data data;
+  int r;
+
+  read_globals (&data);
+  r = getopt_internal (argc, argv, shortopts, longopts, longind, 1, &data);
+  write_globals (&data);
+  return r;
+}
+
+int
+__getopt_r (int argc, char *const argv[], const char *optstring,
+	    struct getopt_data *data)
+{
+  return getopt_internal (argc, argv, optstring, 0, 0, 0, data);
+}
+
+int
+__getopt_long_r (int argc, char *const argv[], const char *shortopts,
+	         const struct option *longopts, int *longind,
+	         struct getopt_data *data)
+{
+  return getopt_internal (argc, argv, shortopts, longopts, longind, 0, data);
+}
+
+int
+__getopt_long_only_r (int argc, char *const argv[], const char *shortopts,
+		      const struct option *longopts, int *longind,
+		      struct getopt_data *data)
 {
-  return getopt_internal (argc, argv, shortopts, longopts, longind, 1);
+  return getopt_internal (argc, argv, shortopts, longopts, longind, 1, data);
 }
 
 /* end of file GETOPT.C */
diff -Naur newlib-1.16.0.orig/newlib/libc/sys/rtems/machine/stdint.h newlib-1.16.0/newlib/libc/sys/rtems/machine/stdint.h
--- newlib-1.16.0.orig/newlib/libc/sys/rtems/machine/stdint.h	1970-01-01 01:00:00.000000000 +0100
+++ newlib-1.16.0/newlib/libc/sys/rtems/machine/stdint.h	2008-03-03 08:36:14.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+ *
+ */
+#ifndef _MACHINE_STDINT_H
+#define _MACHINE_STDINT_H
+
+#ifndef _STDINT_H
+#error machine/stdint.h is an internal file and  must not be directly included
+#endif
+
+#if defined(__sparc__) \
+  || defined(__powerpc__) || defined(__PPC__) \
+  || defined(__mips__) \
+  || defined(__sh__) \
+  || defined(__AVR__) \
+  || defined(_C4x) || defined(_C3x) \
+  || defined(__H8300__)
+/* PTRDIFF_TYPE = int */
+#define __ptrint_t_int_defined 1
+#endif
+
+#if defined(__i386__) \
+  || defined(__m68k__) \
+  || defined(__bfin__) \
+  || defined(__arm__) \
+  || defined(__H8300S__) || defined(__H8300H__)
+/* PTRDIFF_TYPE = long */
+#define __ptrint_t_long_defined 1
+#endif
+
+#endif
diff -Naur newlib-1.16.0.orig/newlib/libc/sys/rtems/sys/param.h newlib-1.16.0/newlib/libc/sys/rtems/sys/param.h
--- newlib-1.16.0.orig/newlib/libc/sys/rtems/sys/param.h	2004-05-07 22:29:24.000000000 +0200
+++ newlib-1.16.0/newlib/libc/sys/rtems/sys/param.h	2008-03-03 08:36:14.000000000 +0100
@@ -93,7 +93,6 @@
 #include <sys/resource.h>
 #include <sys/ucred.h>
 #include <sys/uio.h>
-#include <sys/rtprio.h>
 
 #ifndef FALSE
 #define	FALSE	0
diff -Naur newlib-1.16.0.orig/newlib/Makefile.am newlib-1.16.0/newlib/Makefile.am
--- newlib-1.16.0.orig/newlib/Makefile.am	2007-05-24 19:33:29.000000000 +0200
+++ newlib-1.16.0/newlib/Makefile.am	2008-03-03 08:36:14.000000000 +0100
@@ -81,7 +81,7 @@
 	libc.a
 endif
 
-noinst_DATA = stmp-targ-include
+BUILT_SOURCES = stmp-targ-include
 
 toollib_DATA = $(CRT0) $(CRT1)
 
@@ -186,9 +186,6 @@
 
 $(CRT1_DIR)$(CRT1): ; @true
 
-
-all-recursive: stmp-targ-include
-
 # The targ-include directory just holds the includes files for the
 # particular system and machine we have been configured for.  It is
 # used while building.
diff -Naur newlib-1.16.0.orig/newlib/Makefile.in newlib-1.16.0/newlib/Makefile.in
--- newlib-1.16.0.orig/newlib/Makefile.in	2007-12-19 23:36:26.000000000 +0100
+++ newlib-1.16.0/newlib/Makefile.in	2008-03-03 08:36:14.000000000 +0100
@@ -105,7 +105,7 @@
 	pdf-recursive ps-recursive uninstall-info-recursive \
 	uninstall-recursive
 toollibDATA_INSTALL = $(INSTALL_DATA)
-DATA = $(noinst_DATA) $(toollib_DATA)
+DATA = $(toollib_DATA)
 ETAGS = etags
 CTAGS = ctags
 DEJATOOL = $(PACKAGE)
@@ -339,7 +339,7 @@
 @USE_LIBTOOL_FALSE@toollib_LIBRARIES = libm.a \
 @USE_LIBTOOL_FALSE@	libc.a
 
-noinst_DATA = stmp-targ-include
+BUILT_SOURCES = stmp-targ-include
 toollib_DATA = $(CRT0) $(CRT1)
 
 # The functions ldexp, frexp and modf are traditionally supplied in
@@ -398,7 +398,7 @@
 
 # dejagnu support
 RUNTESTFLAGS = 
-all: newlib.h
+all: $(BUILT_SOURCES) newlib.h
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
 .SUFFIXES:
@@ -703,14 +703,16 @@
 	done
 check-am:
 	$(MAKE) $(AM_MAKEFLAGS) check-DEJAGNU
-check: check-recursive
+check: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) check-recursive
 all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) $(DATA) newlib.h
 installdirs: installdirs-recursive
 installdirs-am:
 	for dir in "$(DESTDIR)$(toollibdir)" "$(DESTDIR)$(toollibdir)" "$(DESTDIR)$(toollibdir)"; do \
 	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
 	done
-install: install-recursive
+install: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) install-recursive
 install-exec: install-exec-recursive
 install-data: install-data-recursive
 uninstall: uninstall-recursive
@@ -735,6 +737,7 @@
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
 	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
 clean: clean-recursive
 
 clean-am: clean-generic clean-libtool clean-toollibLIBRARIES \
@@ -853,8 +856,6 @@
 
 $(CRT1_DIR)$(CRT1): ; @true
 
-all-recursive: stmp-targ-include
-
 # The targ-include directory just holds the includes files for the
 # particular system and machine we have been configured for.  It is
 # used while building.
