diff -uNr gcc-3.4.6.orig/gcc/collect2.c gcc-3.4.6/gcc/collect2.c
--- gcc-3.4.6.orig/gcc/collect2.c	2005-01-10 16:25:23.000000000 +0100
+++ gcc-3.4.6/gcc/collect2.c	2007-11-13 08:48:13.000000000 +0100
@@ -1534,7 +1534,7 @@
   if (redir)
     {
       /* Open response file.  */
-      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT);
+      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT, S_IWUSR | S_IRUSR);
 
       /* Duplicate the stdout and stderr file handles
 	 so they can be restored later.  */
diff -uNr gcc-3.4.6.orig/gcc/collect2.c.orig gcc-3.4.6/gcc/collect2.c.orig
--- gcc-3.4.6.orig/gcc/collect2.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/collect2.c.orig	2005-01-10 16:25:23.000000000 +0100
@@ -0,0 +1,2868 @@
+/* Collect static initialization info into data structures that can be
+   traversed by C++ initialization and finalization routines.
+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+   Contributed by Chris Smith (csmith@convex.com).
+   Heavily modified by Michael Meissner (meissner@cygnus.com),
+   Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+
+/* Build tables of static constructors and destructors and run ld.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include <signal.h>
+#if ! defined( SIGCHLD ) && defined( SIGCLD )
+#  define SIGCHLD SIGCLD
+#endif
+
+#ifdef vfork /* Autoconf may define this to fork for us.  */
+# define VFORK_STRING "fork"
+#else
+# define VFORK_STRING "vfork"
+#endif
+#ifdef HAVE_VFORK_H
+#include <vfork.h>
+#endif
+#ifdef VMS
+#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \
+               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
+#endif /* VMS */
+
+#ifndef LIBRARY_PATH_ENV
+#define LIBRARY_PATH_ENV "LIBRARY_PATH"
+#endif
+
+#define COLLECT
+
+#include "collect2.h"
+#include "demangle.h"
+#include "obstack.h"
+#include "intl.h"
+#include "version.h"
+
+/* On certain systems, we have code that works by scanning the object file
+   directly.  But this code uses system-specific header files and library
+   functions, so turn it off in a cross-compiler.  Likewise, the names of
+   the utilities are not correct for a cross-compiler; we have to hope that
+   cross-versions are in the proper directories.  */
+
+#ifdef CROSS_COMPILE
+#undef SUNOS4_SHARED_LIBRARIES
+#undef OBJECT_FORMAT_COFF
+#undef MD_EXEC_PREFIX
+#undef REAL_LD_FILE_NAME
+#undef REAL_NM_FILE_NAME
+#undef REAL_STRIP_FILE_NAME
+#endif
+
+/* If we cannot use a special method, use the ordinary one:
+   run nm to find what symbols are present.
+   In a cross-compiler, this means you need a cross nm,
+   but that is not quite as unpleasant as special headers.  */
+
+#if !defined (OBJECT_FORMAT_COFF)
+#define OBJECT_FORMAT_NONE
+#endif
+
+#ifdef OBJECT_FORMAT_COFF
+
+#include <a.out.h>
+#include <ar.h>
+
+#ifdef UMAX
+#include <sgs.h>
+#endif
+
+/* Many versions of ldfcn.h define these.  */
+#ifdef FREAD
+#undef FREAD
+#undef FWRITE
+#endif
+
+#include <ldfcn.h>
+
+/* Some systems have an ISCOFF macro, but others do not.  In some cases
+   the macro may be wrong.  MY_ISCOFF is defined in tm.h files for machines
+   that either do not have an ISCOFF macro in /usr/include or for those
+   where it is wrong.  */
+
+#ifndef MY_ISCOFF
+#define MY_ISCOFF(X) ISCOFF (X)
+#endif
+
+#endif /* OBJECT_FORMAT_COFF */
+
+#ifdef OBJECT_FORMAT_NONE
+
+/* Default flags to pass to nm.  */
+#ifndef NM_FLAGS
+#define NM_FLAGS "-n"
+#endif
+
+#endif /* OBJECT_FORMAT_NONE */
+
+/* Some systems use __main in a way incompatible with its use in gcc, in these
+   cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to
+   give the same symbol without quotes for an alternative entry point.  */
+#ifndef NAME__MAIN
+#define NAME__MAIN "__main"
+#endif
+
+/* This must match tree.h.  */
+#define DEFAULT_INIT_PRIORITY 65535
+
+#ifndef COLLECT_SHARED_INIT_FUNC
+#define COLLECT_SHARED_INIT_FUNC(STREAM, FUNC) \
+  fprintf ((STREAM), "void _GLOBAL__DI() {\n\t%s();\n}\n", (FUNC))
+#endif
+#ifndef COLLECT_SHARED_FINI_FUNC
+#define COLLECT_SHARED_FINI_FUNC(STREAM, FUNC) \
+  fprintf ((STREAM), "void _GLOBAL__DD() {\n\t%s();\n}\n", (FUNC))
+#endif
+
+#if defined (LDD_SUFFIX) || SUNOS4_SHARED_LIBRARIES
+#define SCAN_LIBRARIES
+#endif
+
+#ifdef USE_COLLECT2
+int do_collecting = 1;
+#else
+int do_collecting = 0;
+#endif
+
+#ifndef COLLECT_PARSE_FLAG
+#define COLLECT_PARSE_FLAG(FLAG)
+#endif
+
+/* Nonzero if we should suppress the automatic demangling of identifiers
+   in linker error messages.  Set from COLLECT_NO_DEMANGLE.  */
+int no_demangle;
+
+/* Linked lists of constructor and destructor names.  */
+
+struct id
+{
+  struct id *next;
+  int sequence;
+  char name[1];
+};
+
+struct head
+{
+  struct id *first;
+  struct id *last;
+  int number;
+};
+
+/* Enumeration giving which pass this is for scanning the program file.  */
+
+enum pass {
+  PASS_FIRST,				/* without constructors */
+  PASS_OBJ,				/* individual objects */
+  PASS_LIB,			        /* looking for shared libraries */
+  PASS_SECOND				/* with constructors linked in */
+};
+
+int vflag;				/* true if -v */
+static int rflag;			/* true if -r */
+static int strip_flag;			/* true if -s */
+#ifdef COLLECT_EXPORT_LIST
+static int export_flag;                 /* true if -bE */
+static int aix64_flag;			/* true if -b64 */
+static int aixrtl_flag;			/* true if -brtl */
+#endif
+
+int debug;				/* true if -debug */
+
+static int shared_obj;		        /* true if -shared */
+
+static const char *c_file;		/* <xxx>.c for constructor/destructor list.  */
+static const char *o_file;		/* <xxx>.o for constructor/destructor list.  */
+#ifdef COLLECT_EXPORT_LIST
+static const char *export_file;	        /* <xxx>.x for AIX export list.  */
+#endif
+const char *ldout;			/* File for ld errors.  */
+static const char *output_file;		/* Output file for ld.  */
+static const char *nm_file_name;	/* pathname of nm */
+#ifdef LDD_SUFFIX
+static const char *ldd_file_name;	/* pathname of ldd (or equivalent) */
+#endif
+static const char *strip_file_name;		/* pathname of strip */
+const char *c_file_name;	        /* pathname of gcc */
+static char *initname, *fininame;	/* names of init and fini funcs */
+
+static struct head constructors;	/* list of constructors found */
+static struct head destructors;		/* list of destructors found */
+#ifdef COLLECT_EXPORT_LIST
+static struct head exports;		/* list of exported symbols */
+#endif
+static struct head frame_tables;	/* list of frame unwind info tables */
+
+struct obstack temporary_obstack;
+char * temporary_firstobj;
+
+/* Holds the return value of pexecute and fork.  */
+int pid;
+
+/* Structure to hold all the directories in which to search for files to
+   execute.  */
+
+struct prefix_list
+{
+  const char *prefix;         /* String to prepend to the path.  */
+  struct prefix_list *next;   /* Next in linked list.  */
+};
+
+struct path_prefix
+{
+  struct prefix_list *plist;  /* List of prefixes to try */
+  int max_len;                /* Max length of a prefix in PLIST */
+  const char *name;           /* Name of this list (used in config stuff) */
+};
+
+#ifdef COLLECT_EXPORT_LIST
+/* Lists to keep libraries to be scanned for global constructors/destructors.  */
+static struct head libs;                    /* list of libraries */
+static struct path_prefix cmdline_lib_dirs; /* directories specified with -L */
+static struct path_prefix libpath_lib_dirs; /* directories in LIBPATH */
+static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,
+					  &libpath_lib_dirs, NULL};
+#endif
+
+static void handler (int);
+static int is_ctor_dtor (const char *);
+static char *find_a_file (struct path_prefix *, const char *);
+static void add_prefix (struct path_prefix *, const char *);
+static void prefix_from_env (const char *, struct path_prefix *);
+static void prefix_from_string (const char *, struct path_prefix *);
+static void do_wait (const char *);
+static void fork_execute (const char *, char **);
+static void maybe_unlink (const char *);
+static void add_to_list (struct head *, const char *);
+static int extract_init_priority (const char *);
+static void sort_ids (struct head *);
+static void write_list (FILE *, const char *, struct id *);
+#ifdef COLLECT_EXPORT_LIST
+static void dump_list (FILE *, const char *, struct id *);
+#endif
+#if 0
+static void dump_prefix_list (FILE *, const char *, struct prefix_list *);
+#endif
+static void write_list_with_asm (FILE *, const char *, struct id *);
+static void write_c_file (FILE *, const char *);
+static void write_c_file_stat (FILE *, const char *);
+#ifndef LD_INIT_SWITCH
+static void write_c_file_glob (FILE *, const char *);
+#endif
+static void scan_prog_file (const char *, enum pass);
+#ifdef SCAN_LIBRARIES
+static void scan_libraries (const char *);
+#endif
+#if LINK_ELIMINATE_DUPLICATE_LDIRECTORIES
+static int is_in_args (const char *, const char **, const char **);
+#endif
+#ifdef COLLECT_EXPORT_LIST
+#if 0
+static int is_in_list (const char *, struct id *);
+#endif
+static void write_aix_file (FILE *, struct id *);
+static char *resolve_lib_name (const char *);
+#endif
+static char *extract_string (const char **);
+
+#ifndef HAVE_DUP2
+static int
+dup2 (int oldfd, int newfd)
+{
+  int fdtmp[256];
+  int fdx = 0;
+  int fd;
+
+  if (oldfd == newfd)
+    return oldfd;
+  close (newfd);
+  while ((fd = dup (oldfd)) != newfd && fd >= 0) /* good enough for low fd's */
+    fdtmp[fdx++] = fd;
+  while (fdx > 0)
+    close (fdtmp[--fdx]);
+
+  return fd;
+}
+#endif /* ! HAVE_DUP2 */
+
+/* Delete tempfiles and exit function.  */
+
+void
+collect_exit (int status)
+{
+  if (c_file != 0 && c_file[0])
+    maybe_unlink (c_file);
+
+  if (o_file != 0 && o_file[0])
+    maybe_unlink (o_file);
+
+#ifdef COLLECT_EXPORT_LIST
+  if (export_file != 0 && export_file[0])
+    maybe_unlink (export_file);
+#endif
+
+  if (ldout != 0 && ldout[0])
+    {
+      dump_file (ldout);
+      maybe_unlink (ldout);
+    }
+
+  if (status != 0 && output_file != 0 && output_file[0])
+    maybe_unlink (output_file);
+
+  exit (status);
+}
+
+
+/* Notify user of a non-error.  */
+void
+notice (const char *msgid, ...)
+{
+  va_list ap;
+
+  va_start (ap, msgid);
+  vfprintf (stderr, _(msgid), ap);
+  va_end (ap);
+}
+
+/* Die when sys call fails.  */
+
+void
+fatal_perror (const char * msgid, ...)
+{
+  int e = errno;
+  va_list ap;
+
+  va_start (ap, msgid);
+  fprintf (stderr, "collect2: ");
+  vfprintf (stderr, _(msgid), ap);
+  fprintf (stderr, ": %s\n", xstrerror (e));
+  va_end (ap);
+
+  collect_exit (FATAL_EXIT_CODE);
+}
+
+/* Just die.  */
+
+void
+fatal (const char * msgid, ...)
+{
+  va_list ap;
+
+  va_start (ap, msgid);
+  fprintf (stderr, "collect2: ");
+  vfprintf (stderr, _(msgid), ap);
+  fprintf (stderr, "\n");
+  va_end (ap);
+
+  collect_exit (FATAL_EXIT_CODE);
+}
+
+/* Write error message.  */
+
+void
+error (const char * msgid, ...)
+{
+  va_list ap;
+
+  va_start (ap, msgid);
+  fprintf (stderr, "collect2: ");
+  vfprintf (stderr, _(msgid), ap);
+  fprintf (stderr, "\n");
+  va_end(ap);
+}
+
+/* In case obstack is linked in, and abort is defined to fancy_abort,
+   provide a default entry.  */
+
+void
+fancy_abort (void)
+{
+  fatal ("internal error");
+}
+
+static void
+handler (int signo)
+{
+  if (c_file != 0 && c_file[0])
+    maybe_unlink (c_file);
+
+  if (o_file != 0 && o_file[0])
+    maybe_unlink (o_file);
+
+  if (ldout != 0 && ldout[0])
+    maybe_unlink (ldout);
+
+#ifdef COLLECT_EXPORT_LIST
+  if (export_file != 0 && export_file[0])
+    maybe_unlink (export_file);
+#endif
+
+  signal (signo, SIG_DFL);
+  kill (getpid (), signo);
+}
+
+
+int
+file_exists (const char *name)
+{
+  return access (name, R_OK) == 0;
+}
+
+/* Parse a reasonable subset of shell quoting syntax.  */
+
+static char *
+extract_string (const char **pp)
+{
+  const char *p = *pp;
+  int backquote = 0;
+  int inside = 0;
+
+  for (;;)
+    {
+      char c = *p;
+      if (c == '\0')
+	break;
+      ++p;
+      if (backquote)
+	obstack_1grow (&temporary_obstack, c);
+      else if (! inside && c == ' ')
+	break;
+      else if (! inside && c == '\\')
+	backquote = 1;
+      else if (c == '\'')
+	inside = !inside;
+      else
+	obstack_1grow (&temporary_obstack, c);
+    }
+
+  obstack_1grow (&temporary_obstack, '\0');
+  *pp = p;
+  return obstack_finish (&temporary_obstack);
+}
+
+void
+dump_file (const char *name)
+{
+  FILE *stream = fopen (name, "r");
+
+  if (stream == 0)
+    return;
+  while (1)
+    {
+      int c;
+      while (c = getc (stream),
+	     c != EOF && (ISIDNUM (c) || c == '$' || c == '.'))
+	obstack_1grow (&temporary_obstack, c);
+      if (obstack_object_size (&temporary_obstack) > 0)
+	{
+	  const char *word, *p;
+	  char *result;
+	  obstack_1grow (&temporary_obstack, '\0');
+	  word = obstack_finish (&temporary_obstack);
+
+	  if (*word == '.')
+	    ++word, putc ('.', stderr);
+	  p = word;
+	  if (!strncmp (p, USER_LABEL_PREFIX, strlen (USER_LABEL_PREFIX)))
+	    p += strlen (USER_LABEL_PREFIX);
+
+	  if (no_demangle)
+	    result = 0;
+	  else
+	    result = cplus_demangle (p, DMGL_PARAMS | DMGL_ANSI | DMGL_VERBOSE);
+
+	  if (result)
+	    {
+	      int diff;
+	      fputs (result, stderr);
+
+	      diff = strlen (word) - strlen (result);
+	      while (diff > 0 && c == ' ')
+		--diff, putc (' ', stderr);
+	      while (diff < 0 && c == ' ')
+		++diff, c = getc (stream);
+
+	      free (result);
+	    }
+	  else
+	    fputs (word, stderr);
+
+	  fflush (stderr);
+	  obstack_free (&temporary_obstack, temporary_firstobj);
+	}
+      if (c == EOF)
+	break;
+      putc (c, stderr);
+    }
+  fclose (stream);
+}
+
+/* Decide whether the given symbol is: a constructor (1), a destructor
+   (2), a routine in a shared object that calls all the constructors
+   (3) or destructors (4), a DWARF exception-handling table (5), or
+   nothing special (0).  */
+
+static int
+is_ctor_dtor (const char *s)
+{
+  struct names { const char *const name; const int len; const int ret;
+    const int two_underscores; };
+
+  const struct names *p;
+  int ch;
+  const char *orig_s = s;
+
+  static const struct names special[] = {
+#ifndef NO_DOLLAR_IN_LABEL
+    { "GLOBAL__I$", sizeof ("GLOBAL__I$")-1, 1, 0 },
+    { "GLOBAL__D$", sizeof ("GLOBAL__D$")-1, 2, 0 },
+#else
+#ifndef NO_DOT_IN_LABEL
+    { "GLOBAL__I.", sizeof ("GLOBAL__I.")-1, 1, 0 },
+    { "GLOBAL__D.", sizeof ("GLOBAL__D.")-1, 2, 0 },
+#endif /* NO_DOT_IN_LABEL */
+#endif /* NO_DOLLAR_IN_LABEL */
+    { "GLOBAL__I_", sizeof ("GLOBAL__I_")-1, 1, 0 },
+    { "GLOBAL__D_", sizeof ("GLOBAL__D_")-1, 2, 0 },
+    { "GLOBAL__F_", sizeof ("GLOBAL__F_")-1, 5, 0 },
+    { "GLOBAL__FI_", sizeof ("GLOBAL__FI_")-1, 3, 0 },
+    { "GLOBAL__FD_", sizeof ("GLOBAL__FD_")-1, 4, 0 },
+    { NULL, 0, 0, 0 }
+  };
+
+  while ((ch = *s) == '_')
+    ++s;
+
+  if (s == orig_s)
+    return 0;
+
+  for (p = &special[0]; p->len > 0; p++)
+    {
+      if (ch == p->name[0]
+	  && (!p->two_underscores || ((s - orig_s) >= 2))
+	  && strncmp(s, p->name, p->len) == 0)
+	{
+	  return p->ret;
+	}
+    }
+  return 0;
+}
+
+/* We maintain two prefix lists: one from COMPILER_PATH environment variable
+   and one from the PATH variable.  */
+
+static struct path_prefix cpath, path;
+
+#ifdef CROSS_COMPILE
+/* This is the name of the target machine.  We use it to form the name
+   of the files to execute.  */
+
+static const char *const target_machine = TARGET_MACHINE;
+#endif
+
+/* Search for NAME using prefix list PPREFIX.  We only look for executable
+   files.
+
+   Return 0 if not found, otherwise return its name, allocated with malloc.  */
+
+static char *
+find_a_file (struct path_prefix *pprefix, const char *name)
+{
+  char *temp;
+  struct prefix_list *pl;
+  int len = pprefix->max_len + strlen (name) + 1;
+
+  if (debug)
+    fprintf (stderr, "Looking for '%s'\n", name);
+
+#ifdef HOST_EXECUTABLE_SUFFIX
+  len += strlen (HOST_EXECUTABLE_SUFFIX);
+#endif
+
+  temp = xmalloc (len);
+
+  /* Determine the filename to execute (special case for absolute paths).  */
+
+  if (*name == '/'
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+      || (*name && name[1] == ':')
+#endif
+      )
+    {
+      if (access (name, X_OK) == 0)
+	{
+	  strcpy (temp, name);
+
+	  if (debug)
+	    fprintf (stderr, "  - found: absolute path\n");
+
+	  return temp;
+	}
+
+#ifdef HOST_EXECUTABLE_SUFFIX
+	/* Some systems have a suffix for executable files.
+	   So try appending that.  */
+      strcpy (temp, name);
+	strcat (temp, HOST_EXECUTABLE_SUFFIX);
+
+	if (access (temp, X_OK) == 0)
+	  return temp;
+#endif
+
+      if (debug)
+	fprintf (stderr, "  - failed to locate using absolute path\n");
+    }
+  else
+    for (pl = pprefix->plist; pl; pl = pl->next)
+      {
+	struct stat st;
+
+	strcpy (temp, pl->prefix);
+	strcat (temp, name);
+
+	if (stat (temp, &st) >= 0
+	    && ! S_ISDIR (st.st_mode)
+	    && access (temp, X_OK) == 0)
+	  return temp;
+
+#ifdef HOST_EXECUTABLE_SUFFIX
+	/* Some systems have a suffix for executable files.
+	   So try appending that.  */
+	strcat (temp, HOST_EXECUTABLE_SUFFIX);
+
+	if (stat (temp, &st) >= 0
+	    && ! S_ISDIR (st.st_mode)
+	    && access (temp, X_OK) == 0)
+	  return temp;
+#endif
+      }
+
+  if (debug && pprefix->plist == NULL)
+    fprintf (stderr, "  - failed: no entries in prefix list\n");
+
+  free (temp);
+  return 0;
+}
+
+/* Add an entry for PREFIX to prefix list PPREFIX.  */
+
+static void
+add_prefix (struct path_prefix *pprefix, const char *prefix)
+{
+  struct prefix_list *pl, **prev;
+  int len;
+
+  if (pprefix->plist)
+    {
+      for (pl = pprefix->plist; pl->next; pl = pl->next)
+	;
+      prev = &pl->next;
+    }
+  else
+    prev = &pprefix->plist;
+
+  /* Keep track of the longest prefix.  */
+
+  len = strlen (prefix);
+  if (len > pprefix->max_len)
+    pprefix->max_len = len;
+
+  pl = xmalloc (sizeof (struct prefix_list));
+  pl->prefix = xstrdup (prefix);
+
+  if (*prev)
+    pl->next = *prev;
+  else
+    pl->next = (struct prefix_list *) 0;
+  *prev = pl;
+}
+
+/* Take the value of the environment variable ENV, break it into a path, and
+   add of the entries to PPREFIX.  */
+
+static void
+prefix_from_env (const char *env, struct path_prefix *pprefix)
+{
+  const char *p;
+  GET_ENVIRONMENT (p, env);
+
+  if (p)
+    prefix_from_string (p, pprefix);
+}
+
+static void
+prefix_from_string (const char *p, struct path_prefix *pprefix)
+{
+  const char *startp, *endp;
+  char *nstore = xmalloc (strlen (p) + 3);
+
+  if (debug)
+    fprintf (stderr, "Convert string '%s' into prefixes, separator = '%c'\n", p, PATH_SEPARATOR);
+
+  startp = endp = p;
+  while (1)
+    {
+      if (*endp == PATH_SEPARATOR || *endp == 0)
+	{
+	  strncpy (nstore, startp, endp-startp);
+	  if (endp == startp)
+	    {
+	      strcpy (nstore, "./");
+	    }
+	  else if (! IS_DIR_SEPARATOR (endp[-1]))
+	    {
+	      nstore[endp-startp] = DIR_SEPARATOR;
+	      nstore[endp-startp+1] = 0;
+	    }
+	  else
+	    nstore[endp-startp] = 0;
+
+	  if (debug)
+	    fprintf (stderr, "  - add prefix: %s\n", nstore);
+
+	  add_prefix (pprefix, nstore);
+	  if (*endp == 0)
+	    break;
+	  endp = startp = endp + 1;
+	}
+      else
+	endp++;
+    }
+}
+
+/* Main program.  */
+
+int
+main (int argc, char **argv)
+{
+  static const char *const ld_suffix	= "ld";
+  static const char *const real_ld_suffix = "real-ld";
+  static const char *const collect_ld_suffix = "collect-ld";
+  static const char *const nm_suffix	= "nm";
+  static const char *const gnm_suffix	= "gnm";
+#ifdef LDD_SUFFIX
+  static const char *const ldd_suffix	= LDD_SUFFIX;
+#endif
+  static const char *const strip_suffix = "strip";
+  static const char *const gstrip_suffix = "gstrip";
+
+#ifdef CROSS_COMPILE
+  /* If we look for a program in the compiler directories, we just use
+     the short name, since these directories are already system-specific.
+     But it we look for a program in the system directories, we need to
+     qualify the program name with the target machine.  */
+
+  const char *const full_ld_suffix =
+    concat(target_machine, "-", ld_suffix, NULL);
+  const char *const full_nm_suffix =
+    concat (target_machine, "-", nm_suffix, NULL);
+  const char *const full_gnm_suffix =
+    concat (target_machine, "-", gnm_suffix, NULL);
+#ifdef LDD_SUFFIX
+  const char *const full_ldd_suffix =
+    concat (target_machine, "-", ldd_suffix, NULL);
+#endif
+  const char *const full_strip_suffix =
+    concat (target_machine, "-", strip_suffix, NULL);
+  const char *const full_gstrip_suffix =
+    concat (target_machine, "-", gstrip_suffix, NULL);
+#else
+  const char *const full_ld_suffix	= ld_suffix;
+  const char *const full_nm_suffix	= nm_suffix;
+  const char *const full_gnm_suffix	= gnm_suffix;
+#ifdef LDD_SUFFIX
+  const char *const full_ldd_suffix	= ldd_suffix;
+#endif
+  const char *const full_strip_suffix	= strip_suffix;
+  const char *const full_gstrip_suffix	= gstrip_suffix;
+#endif /* CROSS_COMPILE */
+
+  const char *arg;
+  FILE *outf;
+#ifdef COLLECT_EXPORT_LIST
+  FILE *exportf;
+#endif
+  const char *ld_file_name;
+  const char *p;
+  char **c_argv;
+  const char **c_ptr;
+  char **ld1_argv;
+  const char **ld1;
+  char **ld2_argv;
+  const char **ld2;
+  char **object_lst;
+  const char **object;
+  int first_file;
+  int num_c_args	= argc+9;
+
+  no_demangle = !! getenv ("COLLECT_NO_DEMANGLE");
+
+  /* Suppress demangling by the real linker, which may be broken.  */
+  putenv (xstrdup ("COLLECT_NO_DEMANGLE="));
+
+#if defined (COLLECT2_HOST_INITIALIZATION)
+  /* Perform system dependent initialization, if necessary.  */
+  COLLECT2_HOST_INITIALIZATION;
+#endif
+
+#ifdef SIGCHLD
+  /* We *MUST* set SIGCHLD to SIG_DFL so that the wait4() call will
+     receive the signal.  A different setting is inheritable */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  gcc_init_libintl ();
+
+  /* Do not invoke xcalloc before this point, since locale needs to be
+     set first, in case a diagnostic is issued.  */
+
+  ld1 = (const char **)(ld1_argv = xcalloc(sizeof (char *), argc+3));
+  ld2 = (const char **)(ld2_argv = xcalloc(sizeof (char *), argc+10));
+  object = (const char **)(object_lst = xcalloc(sizeof (char *), argc));
+
+#ifdef DEBUG
+  debug = 1;
+#endif
+
+  /* Parse command line early for instances of -debug.  This allows
+     the debug flag to be set before functions like find_a_file()
+     are called.  */
+  {
+    int i;
+
+    for (i = 1; argv[i] != NULL; i ++)
+      {
+	if (! strcmp (argv[i], "-debug"))
+	  debug = 1;
+	COLLECT_PARSE_FLAG (argv[i]);
+      }
+    vflag = debug;
+  }
+
+#ifndef DEFAULT_A_OUT_NAME
+  output_file = "a.out";
+#else
+  output_file = DEFAULT_A_OUT_NAME;
+#endif
+
+  obstack_begin (&temporary_obstack, 0);
+  temporary_firstobj = obstack_alloc (&temporary_obstack, 0);
+
+  current_demangling_style = auto_demangling;
+  p = getenv ("COLLECT_GCC_OPTIONS");
+  while (p && *p)
+    {
+      const char *q = extract_string (&p);
+      if (*q == '-' && (q[1] == 'm' || q[1] == 'f'))
+	num_c_args++;
+    }
+  obstack_free (&temporary_obstack, temporary_firstobj);
+
+  /* -fno-profile-arcs -fno-test-coverage -fno-branch-probabilities
+     -fno-exceptions -w */
+  num_c_args += 5;
+
+  c_ptr = (const char **) (c_argv = xcalloc (sizeof (char *), num_c_args));
+
+  if (argc < 2)
+    fatal ("no arguments");
+
+#ifdef SIGQUIT
+  if (signal (SIGQUIT, SIG_IGN) != SIG_IGN)
+    signal (SIGQUIT, handler);
+#endif
+  if (signal (SIGINT, SIG_IGN) != SIG_IGN)
+    signal (SIGINT, handler);
+#ifdef SIGALRM
+  if (signal (SIGALRM, SIG_IGN) != SIG_IGN)
+    signal (SIGALRM, handler);
+#endif
+#ifdef SIGHUP
+  if (signal (SIGHUP, SIG_IGN) != SIG_IGN)
+    signal (SIGHUP, handler);
+#endif
+  if (signal (SIGSEGV, SIG_IGN) != SIG_IGN)
+    signal (SIGSEGV, handler);
+#ifdef SIGBUS
+  if (signal (SIGBUS, SIG_IGN) != SIG_IGN)
+    signal (SIGBUS, handler);
+#endif
+
+  /* Extract COMPILER_PATH and PATH into our prefix list.  */
+  prefix_from_env ("COMPILER_PATH", &cpath);
+  prefix_from_env ("PATH", &path);
+
+  /* Try to discover a valid linker/nm/strip to use.  */
+
+  /* Maybe we know the right file to use (if not cross).  */
+  ld_file_name = 0;
+#ifdef DEFAULT_LINKER
+  if (access (DEFAULT_LINKER, X_OK) == 0)
+    ld_file_name = DEFAULT_LINKER;
+  if (ld_file_name == 0)
+#endif
+#ifdef REAL_LD_FILE_NAME
+  ld_file_name = find_a_file (&path, REAL_LD_FILE_NAME);
+  if (ld_file_name == 0)
+#endif
+  /* Search the (target-specific) compiler dirs for ld'.  */
+  ld_file_name = find_a_file (&cpath, real_ld_suffix);
+  /* Likewise for `collect-ld'.  */
+  if (ld_file_name == 0)
+    ld_file_name = find_a_file (&cpath, collect_ld_suffix);
+  /* Search the compiler directories for `ld'.  We have protection against
+     recursive calls in find_a_file.  */
+  if (ld_file_name == 0)
+    ld_file_name = find_a_file (&cpath, ld_suffix);
+  /* Search the ordinary system bin directories
+     for `ld' (if native linking) or `TARGET-ld' (if cross).  */
+  if (ld_file_name == 0)
+    ld_file_name = find_a_file (&path, full_ld_suffix);
+
+#ifdef REAL_NM_FILE_NAME
+  nm_file_name = find_a_file (&path, REAL_NM_FILE_NAME);
+  if (nm_file_name == 0)
+#endif
+  nm_file_name = find_a_file (&cpath, gnm_suffix);
+  if (nm_file_name == 0)
+    nm_file_name = find_a_file (&path, full_gnm_suffix);
+  if (nm_file_name == 0)
+    nm_file_name = find_a_file (&cpath, nm_suffix);
+  if (nm_file_name == 0)
+    nm_file_name = find_a_file (&path, full_nm_suffix);
+
+#ifdef LDD_SUFFIX
+  ldd_file_name = find_a_file (&cpath, ldd_suffix);
+  if (ldd_file_name == 0)
+    ldd_file_name = find_a_file (&path, full_ldd_suffix);
+#endif
+
+#ifdef REAL_STRIP_FILE_NAME
+  strip_file_name = find_a_file (&path, REAL_STRIP_FILE_NAME);
+  if (strip_file_name == 0)
+#endif
+  strip_file_name = find_a_file (&cpath, gstrip_suffix);
+  if (strip_file_name == 0)
+    strip_file_name = find_a_file (&path, full_gstrip_suffix);
+  if (strip_file_name == 0)
+    strip_file_name = find_a_file (&cpath, strip_suffix);
+  if (strip_file_name == 0)
+    strip_file_name = find_a_file (&path, full_strip_suffix);
+
+  /* Determine the full path name of the C compiler to use.  */
+  c_file_name = getenv ("COLLECT_GCC");
+  if (c_file_name == 0)
+    {
+#ifdef CROSS_COMPILE
+      c_file_name = concat (target_machine, "-gcc", NULL);
+#else
+      c_file_name = "gcc";
+#endif
+    }
+
+  p = find_a_file (&cpath, c_file_name);
+
+  /* Here it should be safe to use the system search path since we should have
+     already qualified the name of the compiler when it is needed.  */
+  if (p == 0)
+    p = find_a_file (&path, c_file_name);
+
+  if (p)
+    c_file_name = p;
+
+  *ld1++ = *ld2++ = ld_file_name;
+
+  /* Make temp file names.  */
+  c_file = make_temp_file (".c");
+  o_file = make_temp_file (".o");
+#ifdef COLLECT_EXPORT_LIST
+  export_file = make_temp_file (".x");
+#endif
+  ldout = make_temp_file (".ld");
+  *c_ptr++ = c_file_name;
+  *c_ptr++ = "-x";
+  *c_ptr++ = "c";
+  *c_ptr++ = "-c";
+  *c_ptr++ = "-o";
+  *c_ptr++ = o_file;
+
+#ifdef COLLECT_EXPORT_LIST
+  /* Generate a list of directories from LIBPATH.  */
+  prefix_from_env ("LIBPATH", &libpath_lib_dirs);
+  /* Add to this list also two standard directories where
+     AIX loader always searches for libraries.  */
+  add_prefix (&libpath_lib_dirs, "/lib");
+  add_prefix (&libpath_lib_dirs, "/usr/lib");
+#endif
+
+  /* Get any options that the upper GCC wants to pass to the sub-GCC.
+
+     AIX support needs to know if -shared has been specified before
+     parsing commandline arguments.  */
+
+  p = getenv ("COLLECT_GCC_OPTIONS");
+  while (p && *p)
+    {
+      const char *q = extract_string (&p);
+      if (*q == '-' && (q[1] == 'm' || q[1] == 'f'))
+	*c_ptr++ = xstrdup (q);
+      if (strcmp (q, "-EL") == 0 || strcmp (q, "-EB") == 0)
+	*c_ptr++ = xstrdup (q);
+      if (strcmp (q, "-shared") == 0)
+	shared_obj = 1;
+      if (*q == '-' && q[1] == 'B')
+	{
+	  *c_ptr++ = xstrdup (q);
+	  if (q[2] == 0)
+	    {
+	      q = extract_string (&p);
+	      *c_ptr++ = xstrdup (q);
+	    }
+	}
+    }
+  obstack_free (&temporary_obstack, temporary_firstobj);
+  *c_ptr++ = "-fno-profile-arcs";
+  *c_ptr++ = "-fno-test-coverage";
+  *c_ptr++ = "-fno-branch-probabilities";
+  *c_ptr++ = "-fno-exceptions";
+  *c_ptr++ = "-w";
+
+  /* !!! When GCC calls collect2,
+     it does not know whether it is calling collect2 or ld.
+     So collect2 cannot meaningfully understand any options
+     except those ld understands.
+     If you propose to make GCC pass some other option,
+     just imagine what will happen if ld is really ld!!!  */
+
+  /* Parse arguments.  Remember output file spec, pass the rest to ld.  */
+  /* After the first file, put in the c++ rt0.  */
+
+  first_file = 1;
+  while ((arg = *++argv) != (char *) 0)
+    {
+      *ld1++ = *ld2++ = arg;
+
+      if (arg[0] == '-')
+	{
+	  switch (arg[1])
+	    {
+#ifdef COLLECT_EXPORT_LIST
+	    /* We want to disable automatic exports on AIX when user
+	       explicitly puts an export list in command line */
+	    case 'b':
+	      if (arg[2] == 'E' || strncmp (&arg[2], "export", 6) == 0)
+                export_flag = 1;
+	      else if (arg[2] == '6' && arg[3] == '4')
+		aix64_flag = 1;
+	      else if (arg[2] == 'r' && arg[3] == 't' && arg[4] == 'l')
+		aixrtl_flag = 1;
+	      break;
+#endif
+
+	    case 'd':
+	      if (!strcmp (arg, "-debug"))
+		{
+		  /* Already parsed.  */
+		  ld1--;
+		  ld2--;
+		}
+	      break;
+
+	    case 'l':
+	      if (first_file)
+		{
+		  /* place o_file BEFORE this argument! */
+		  first_file = 0;
+		  ld2--;
+		  *ld2++ = o_file;
+		  *ld2++ = arg;
+		}
+#ifdef COLLECT_EXPORT_LIST
+	      {
+	        /* Resolving full library name.  */
+		const char *s = resolve_lib_name (arg+2);
+
+		/* Saving a full library name.  */
+		add_to_list (&libs, s);
+	      }
+#endif
+	      break;
+
+#ifdef COLLECT_EXPORT_LIST
+	    /* Saving directories where to search for libraries.  */
+	    case 'L':
+	      add_prefix (&cmdline_lib_dirs, arg+2);
+	      break;
+#else
+#if LINK_ELIMINATE_DUPLICATE_LDIRECTORIES
+	    case 'L':
+	      if (is_in_args (arg, (const char **) ld1_argv, ld1-1))
+		--ld1;
+	      break;
+#endif /* LINK_ELIMINATE_DUPLICATE_LDIRECTORIES */
+#endif
+
+	    case 'o':
+	      if (arg[2] == '\0')
+		output_file = *ld1++ = *ld2++ = *++argv;
+	      else if (1
+#ifdef SWITCHES_NEED_SPACES
+		       && ! strchr (SWITCHES_NEED_SPACES, arg[1])
+#endif
+		       )
+
+		output_file = &arg[2];
+	      break;
+
+	    case 'r':
+	      if (arg[2] == '\0')
+		rflag = 1;
+	      break;
+
+	    case 's':
+	      if (arg[2] == '\0' && do_collecting)
+		{
+		  /* We must strip after the nm run, otherwise C++ linking
+		     will not work.  Thus we strip in the second ld run, or
+		     else with strip if there is no second ld run.  */
+		  strip_flag = 1;
+		  ld1--;
+		}
+	      break;
+
+	    case 'v':
+	      if (arg[2] == '\0')
+		vflag = 1;
+	      break;
+	    }
+	}
+      else if ((p = strrchr (arg, '.')) != (char *) 0
+	       && (strcmp (p, ".o") == 0 || strcmp (p, ".a") == 0
+		   || strcmp (p, ".so") == 0 || strcmp (p, ".lo") == 0
+		   || strcmp (p, ".obj") == 0))
+	{
+	  if (first_file)
+	    {
+	      first_file = 0;
+	      if (p[1] == 'o')
+		*ld2++ = o_file;
+	      else
+		{
+		  /* place o_file BEFORE this argument! */
+		  ld2--;
+		  *ld2++ = o_file;
+		  *ld2++ = arg;
+		}
+	    }
+	  if (p[1] == 'o' || p[1] == 'l')
+	    *object++ = arg;
+#ifdef COLLECT_EXPORT_LIST
+	  /* libraries can be specified directly, i.e. without -l flag.  */
+	  else
+	    {
+	      /* Saving a full library name.  */
+              add_to_list (&libs, arg);
+            }
+#endif
+	}
+    }
+
+#ifdef COLLECT_EXPORT_LIST
+  /* This is added only for debugging purposes.  */
+  if (debug)
+    {
+      fprintf (stderr, "List of libraries:\n");
+      dump_list (stderr, "\t", libs.first);
+    }
+
+  /* The AIX linker will discard static constructors in object files if
+     nothing else in the file is referenced, so look at them first.  */
+  {
+      const char **export_object_lst = (const char **)object_lst;
+
+      while (export_object_lst < object)
+	scan_prog_file (*export_object_lst++, PASS_OBJ);
+  }
+  {
+    struct id *list = libs.first;
+
+    for (; list; list = list->next)
+      scan_prog_file (list->name, PASS_FIRST);
+  }
+
+  if (exports.first)
+    {
+      char *buf = concat ("-bE:", export_file, NULL);
+
+      *ld1++ = buf;
+      *ld2++ = buf;
+
+      exportf = fopen (export_file, "w");
+      if (exportf == (FILE *) 0)
+	fatal_perror ("fopen %s", export_file);
+      write_aix_file (exportf, exports.first);
+      if (fclose (exportf))
+	fatal_perror ("fclose %s", export_file);
+    }
+#endif
+
+  *c_ptr++ = c_file;
+  *c_ptr = *ld1 = *object = (char *) 0;
+
+  if (vflag)
+    {
+      notice ("collect2 version %s", version_string);
+#ifdef TARGET_VERSION
+      TARGET_VERSION;
+#endif
+      fprintf (stderr, "\n");
+    }
+
+  if (debug)
+    {
+      const char *ptr;
+      fprintf (stderr, "ld_file_name        = %s\n",
+	       (ld_file_name ? ld_file_name : "not found"));
+      fprintf (stderr, "c_file_name         = %s\n",
+	       (c_file_name ? c_file_name : "not found"));
+      fprintf (stderr, "nm_file_name        = %s\n",
+	       (nm_file_name ? nm_file_name : "not found"));
+#ifdef LDD_SUFFIX
+      fprintf (stderr, "ldd_file_name       = %s\n",
+	       (ldd_file_name ? ldd_file_name : "not found"));
+#endif
+      fprintf (stderr, "strip_file_name     = %s\n",
+	       (strip_file_name ? strip_file_name : "not found"));
+      fprintf (stderr, "c_file              = %s\n",
+	       (c_file ? c_file : "not found"));
+      fprintf (stderr, "o_file              = %s\n",
+	       (o_file ? o_file : "not found"));
+
+      ptr = getenv ("COLLECT_GCC_OPTIONS");
+      if (ptr)
+	fprintf (stderr, "COLLECT_GCC_OPTIONS = %s\n", ptr);
+
+      ptr = getenv ("COLLECT_GCC");
+      if (ptr)
+	fprintf (stderr, "COLLECT_GCC         = %s\n", ptr);
+
+      ptr = getenv ("COMPILER_PATH");
+      if (ptr)
+	fprintf (stderr, "COMPILER_PATH       = %s\n", ptr);
+
+      ptr = getenv (LIBRARY_PATH_ENV);
+      if (ptr)
+	fprintf (stderr, "%-20s= %s\n", LIBRARY_PATH_ENV, ptr);
+
+      fprintf (stderr, "\n");
+    }
+
+  /* Load the program, searching all libraries and attempting to provide
+     undefined symbols from repository information.  */
+
+  /* On AIX we do this later.  */
+#ifndef COLLECT_EXPORT_LIST
+  do_tlink (ld1_argv, object_lst);
+#endif
+
+  /* If -r or they will be run via some other method, do not build the
+     constructor or destructor list, just return now.  */
+  if (rflag
+#ifndef COLLECT_EXPORT_LIST
+      || ! do_collecting
+#endif
+      )
+    {
+#ifdef COLLECT_EXPORT_LIST
+      /* Do the link we avoided above if we are exiting.  */
+      do_tlink (ld1_argv, object_lst);
+
+      /* But make sure we delete the export file we may have created.  */
+      if (export_file != 0 && export_file[0])
+	maybe_unlink (export_file);
+#endif
+      maybe_unlink (c_file);
+      maybe_unlink (o_file);
+      return 0;
+    }
+
+  /* Examine the namelist with nm and search it for static constructors
+     and destructors to call.
+     Write the constructor and destructor tables to a .s file and reload.  */
+
+  /* On AIX we already scanned for global constructors/destructors.  */
+#ifndef COLLECT_EXPORT_LIST
+  scan_prog_file (output_file, PASS_FIRST);
+#endif
+
+#ifdef SCAN_LIBRARIES
+  scan_libraries (output_file);
+#endif
+
+  if (debug)
+    {
+      notice ("%d constructor(s) found\n", constructors.number);
+      notice ("%d destructor(s)  found\n", destructors.number);
+      notice ("%d frame table(s) found\n", frame_tables.number);
+    }
+
+  if (constructors.number == 0 && destructors.number == 0
+      && frame_tables.number == 0
+#if defined (SCAN_LIBRARIES) || defined (COLLECT_EXPORT_LIST)
+      /* If we will be running these functions ourselves, we want to emit
+	 stubs into the shared library so that we do not have to relink
+	 dependent programs when we add static objects.  */
+      && ! shared_obj
+#endif
+      )
+    {
+#ifdef COLLECT_EXPORT_LIST
+      /* Do tlink without additional code generation.  */
+      do_tlink (ld1_argv, object_lst);
+#endif
+      /* Strip now if it was requested on the command line.  */
+      if (strip_flag)
+	{
+	  char **real_strip_argv = xcalloc (sizeof (char *), 3);
+	  const char ** strip_argv = (const char **) real_strip_argv;
+
+	  strip_argv[0] = strip_file_name;
+	  strip_argv[1] = output_file;
+	  strip_argv[2] = (char *) 0;
+	  fork_execute ("strip", real_strip_argv);
+	}
+
+#ifdef COLLECT_EXPORT_LIST
+      maybe_unlink (export_file);
+#endif
+      maybe_unlink (c_file);
+      maybe_unlink (o_file);
+      return 0;
+    }
+
+  /* Sort ctor and dtor lists by priority.  */
+  sort_ids (&constructors);
+  sort_ids (&destructors);
+
+  maybe_unlink(output_file);
+  outf = fopen (c_file, "w");
+  if (outf == (FILE *) 0)
+    fatal_perror ("fopen %s", c_file);
+
+  write_c_file (outf, c_file);
+
+  if (fclose (outf))
+    fatal_perror ("fclose %s", c_file);
+
+  /* Tell the linker that we have initializer and finalizer functions.  */
+#ifdef LD_INIT_SWITCH
+#ifdef COLLECT_EXPORT_LIST
+  *ld2++ = concat (LD_INIT_SWITCH, ":", initname, ":", fininame, NULL);
+#else
+  *ld2++ = LD_INIT_SWITCH;
+  *ld2++ = initname;
+  *ld2++ = LD_FINI_SWITCH;
+  *ld2++ = fininame;
+#endif
+#endif
+
+#ifdef COLLECT_EXPORT_LIST
+  if (shared_obj)
+    {
+      /* If we did not add export flag to link arguments before, add it to
+	 second link phase now.  No new exports should have been added.  */
+      if (! exports.first)
+	*ld2++ = concat ("-bE:", export_file, NULL);
+
+#ifndef LD_INIT_SWITCH
+      add_to_list (&exports, initname);
+      add_to_list (&exports, fininame);
+      add_to_list (&exports, "_GLOBAL__DI");
+      add_to_list (&exports, "_GLOBAL__DD");
+#endif
+      exportf = fopen (export_file, "w");
+      if (exportf == (FILE *) 0)
+	fatal_perror ("fopen %s", export_file);
+      write_aix_file (exportf, exports.first);
+      if (fclose (exportf))
+	fatal_perror ("fclose %s", export_file);
+    }
+#endif
+
+  /* End of arguments to second link phase.  */
+  *ld2 = (char*) 0;
+
+  if (debug)
+    {
+      fprintf (stderr, "\n========== output_file = %s, c_file = %s\n",
+	       output_file, c_file);
+      write_c_file (stderr, "stderr");
+      fprintf (stderr, "========== end of c_file\n\n");
+#ifdef COLLECT_EXPORT_LIST
+      fprintf (stderr, "\n========== export_file = %s\n", export_file);
+      write_aix_file (stderr, exports.first);
+      fprintf (stderr, "========== end of export_file\n\n");
+#endif
+    }
+
+  /* Assemble the constructor and destructor tables.
+     Link the tables in with the rest of the program.  */
+
+  fork_execute ("gcc",  c_argv);
+#ifdef COLLECT_EXPORT_LIST
+  /* On AIX we must call tlink because of possible templates resolution.  */
+  do_tlink (ld2_argv, object_lst);
+#else
+  /* Otherwise, simply call ld because tlink is already done.  */
+  fork_execute ("ld", ld2_argv);
+
+  /* Let scan_prog_file do any final mods (OSF/rose needs this for
+     constructors/destructors in shared libraries.  */
+  scan_prog_file (output_file, PASS_SECOND);
+#endif
+
+  maybe_unlink (c_file);
+  maybe_unlink (o_file);
+
+#ifdef COLLECT_EXPORT_LIST
+  maybe_unlink (export_file);
+#endif
+
+  return 0;
+}
+
+
+/* Wait for a process to finish, and exit if a nonzero status is found.  */
+
+int
+collect_wait (const char *prog)
+{
+  int status;
+
+  pwait (pid, &status, 0);
+  if (status)
+    {
+      if (WIFSIGNALED (status))
+	{
+	  int sig = WTERMSIG (status);
+	  error ("%s terminated with signal %d [%s]%s",
+		 prog, sig, strsignal(sig),
+		 WCOREDUMP(status) ? ", core dumped" : "");
+	  collect_exit (FATAL_EXIT_CODE);
+	}
+
+      if (WIFEXITED (status))
+	return WEXITSTATUS (status);
+    }
+  return 0;
+}
+
+static void
+do_wait (const char *prog)
+{
+  int ret = collect_wait (prog);
+  if (ret != 0)
+    {
+      error ("%s returned %d exit status", prog, ret);
+      collect_exit (ret);
+    }
+}
+
+
+/* Execute a program, and wait for the reply.  */
+
+void
+collect_execute (const char *prog, char **argv, const char *redir)
+{
+  char *errmsg_fmt;
+  char *errmsg_arg;
+  int redir_handle = -1;
+  int stdout_save = -1;
+  int stderr_save = -1;
+
+  if (vflag || debug)
+    {
+      char **p_argv;
+      const char *str;
+
+      if (argv[0])
+	fprintf (stderr, "%s", argv[0]);
+      else
+	notice ("[cannot find %s]", prog);
+
+      for (p_argv = &argv[1]; (str = *p_argv) != (char *) 0; p_argv++)
+	fprintf (stderr, " %s", str);
+
+      fprintf (stderr, "\n");
+    }
+
+  fflush (stdout);
+  fflush (stderr);
+
+  /* If we cannot find a program we need, complain error.  Do this here
+     since we might not end up needing something that we could not find.  */
+
+  if (argv[0] == 0)
+    fatal ("cannot find `%s'", prog);
+
+  if (redir)
+    {
+      /* Open response file.  */
+      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT);
+
+      /* Duplicate the stdout and stderr file handles
+	 so they can be restored later.  */
+      stdout_save = dup (STDOUT_FILENO);
+      if (stdout_save == -1)
+	fatal_perror ("redirecting stdout: %s", redir);
+      stderr_save = dup (STDERR_FILENO);
+      if (stderr_save == -1)
+	fatal_perror ("redirecting stdout: %s", redir);
+
+      /* Redirect stdout & stderr to our response file.  */
+      dup2 (redir_handle, STDOUT_FILENO);
+      dup2 (redir_handle, STDERR_FILENO);
+    }
+
+  pid = pexecute (argv[0], argv, argv[0], NULL, &errmsg_fmt, &errmsg_arg,
+		  (PEXECUTE_FIRST | PEXECUTE_LAST | PEXECUTE_SEARCH));
+
+  if (redir)
+    {
+      /* Restore stdout and stderr to their previous settings.  */
+      dup2 (stdout_save, STDOUT_FILENO);
+      dup2 (stderr_save, STDERR_FILENO);
+
+      /* Close response file.  */
+      close (redir_handle);
+    }
+
+ if (pid == -1)
+   fatal_perror (errmsg_fmt, errmsg_arg);
+}
+
+static void
+fork_execute (const char *prog, char **argv)
+{
+  collect_execute (prog, argv, NULL);
+  do_wait (prog);
+}
+
+/* Unlink a file unless we are debugging.  */
+
+static void
+maybe_unlink (const char *file)
+{
+  if (!debug)
+    unlink (file);
+  else
+    notice ("[Leaving %s]\n", file);
+}
+
+
+static long sequence_number = 0;
+
+/* Add a name to a linked list.  */
+
+static void
+add_to_list (struct head *head_ptr, const char *name)
+{
+  struct id *newid = xcalloc (sizeof (struct id) + strlen (name), 1);
+  struct id *p;
+  strcpy (newid->name, name);
+
+  if (head_ptr->first)
+    head_ptr->last->next = newid;
+  else
+    head_ptr->first = newid;
+
+  /* Check for duplicate symbols.  */
+  for (p = head_ptr->first;
+       strcmp (name, p->name) != 0;
+       p = p->next)
+    ;
+  if (p != newid)
+    {
+      head_ptr->last->next = 0;
+      free (newid);
+      return;
+    }
+
+  newid->sequence = ++sequence_number;
+  head_ptr->last = newid;
+  head_ptr->number++;
+}
+
+/* Grab the init priority number from an init function name that
+   looks like "_GLOBAL_.I.12345.foo".  */
+
+static int
+extract_init_priority (const char *name)
+{
+  int pos = 0, pri;
+
+  while (name[pos] == '_')
+    ++pos;
+  pos += 10; /* strlen ("GLOBAL__X_") */
+
+  /* Extract init_p number from ctor/dtor name.  */
+  pri = atoi (name + pos);
+  return pri ? pri : DEFAULT_INIT_PRIORITY;
+}
+
+/* Insertion sort the ids from ctor/dtor list HEAD_PTR in descending order.
+   ctors will be run from right to left, dtors from left to right.  */
+
+static void
+sort_ids (struct head *head_ptr)
+{
+  /* id holds the current element to insert.  id_next holds the next
+     element to insert.  id_ptr iterates through the already sorted elements
+     looking for the place to insert id.  */
+  struct id *id, *id_next, **id_ptr;
+
+  id = head_ptr->first;
+
+  /* We don't have any sorted elements yet.  */
+  head_ptr->first = NULL;
+
+  for (; id; id = id_next)
+    {
+      id_next = id->next;
+      id->sequence = extract_init_priority (id->name);
+
+      for (id_ptr = &(head_ptr->first); ; id_ptr = &((*id_ptr)->next))
+	if (*id_ptr == NULL
+	    /* If the sequence numbers are the same, we put the id from the
+	       file later on the command line later in the list.  */
+	    || id->sequence > (*id_ptr)->sequence
+	    /* Hack: do lexical compare, too.
+	    || (id->sequence == (*id_ptr)->sequence
+	        && strcmp (id->name, (*id_ptr)->name) > 0) */
+	    )
+	  {
+	    id->next = *id_ptr;
+	    *id_ptr = id;
+	    break;
+	  }
+    }
+
+  /* Now set the sequence numbers properly so write_c_file works.  */
+  for (id = head_ptr->first; id; id = id->next)
+    id->sequence = ++sequence_number;
+}
+
+/* Write: `prefix', the names on list LIST, `suffix'.  */
+
+static void
+write_list (FILE *stream, const char *prefix, struct id *list)
+{
+  while (list)
+    {
+      fprintf (stream, "%sx%d,\n", prefix, list->sequence);
+      list = list->next;
+    }
+}
+
+#if LINK_ELIMINATE_DUPLICATE_LDIRECTORIES
+/* Given a STRING, return nonzero if it occurs in the list in range
+   [ARGS_BEGIN,ARGS_END).  */
+
+static int
+is_in_args (const char *string, const char **args_begin,
+	    const char **args_end)
+{
+  const char **args_pointer;
+  for (args_pointer = args_begin; args_pointer != args_end; ++args_pointer)
+    if (strcmp (string, *args_pointer) == 0)
+      return 1;
+  return 0;
+}
+#endif /* LINK_ELIMINATE_DUPLICATE_LDIRECTORIES */
+
+#ifdef COLLECT_EXPORT_LIST
+/* This function is really used only on AIX, but may be useful.  */
+#if 0
+static int
+is_in_list (const char *prefix, struct id *list)
+{
+  while (list)
+    {
+      if (!strcmp (prefix, list->name)) return 1;
+      list = list->next;
+    }
+    return 0;
+}
+#endif
+#endif /* COLLECT_EXPORT_LIST */
+
+/* Added for debugging purpose.  */
+#ifdef COLLECT_EXPORT_LIST
+static void
+dump_list (FILE *stream, const char *prefix, struct id *list)
+{
+  while (list)
+    {
+      fprintf (stream, "%s%s,\n", prefix, list->name);
+      list = list->next;
+    }
+}
+#endif
+
+#if 0
+static void
+dump_prefix_list (FILE *stream, const char *prefix, struct prefix_list *list)
+{
+  while (list)
+    {
+      fprintf (stream, "%s%s,\n", prefix, list->prefix);
+      list = list->next;
+    }
+}
+#endif
+
+static void
+write_list_with_asm (FILE *stream, const char *prefix, struct id *list)
+{
+  while (list)
+    {
+      fprintf (stream, "%sx%d __asm__ (\"%s\");\n",
+	       prefix, list->sequence, list->name);
+      list = list->next;
+    }
+}
+
+/* Write out the constructor and destructor tables statically (for a shared
+   object), along with the functions to execute them.  */
+
+static void
+write_c_file_stat (FILE *stream, const char *name ATTRIBUTE_UNUSED)
+{
+  const char *p, *q;
+  char *prefix, *r;
+  int frames = (frame_tables.number > 0);
+
+  /* Figure out name of output_file, stripping off .so version.  */
+  p = strrchr (output_file, '/');
+  if (p == 0)
+    p = output_file;
+  else
+    p++;
+  q = p;
+  while (q)
+    {
+      q = strchr (q,'.');
+      if (q == 0)
+	{
+	  q = p + strlen (p);
+	  break;
+	}
+      else
+	{
+	  if (strncmp (q, ".so", 3) == 0)
+	    {
+	      q += 3;
+	      break;
+	    }
+	  else
+	    q++;
+	}
+    }
+  /* q points to null at end of the string (or . of the .so version) */
+  prefix = xmalloc (q - p + 1);
+  strncpy (prefix, p, q - p);
+  prefix[q - p] = 0;
+  for (r = prefix; *r; r++)
+    if (!ISALNUM ((unsigned char)*r))
+      *r = '_';
+  if (debug)
+    notice ("\nwrite_c_file - output name is %s, prefix is %s\n",
+	    output_file, prefix);
+
+  initname = concat ("_GLOBAL__FI_", prefix, NULL);
+  fininame = concat ("_GLOBAL__FD_", prefix, NULL);
+
+  free (prefix);
+
+  /* Write the tables as C code.  */
+
+  fprintf (stream, "static int count;\n");
+  fprintf (stream, "typedef void entry_pt();\n");
+  write_list_with_asm (stream, "extern entry_pt ", constructors.first);
+
+  if (frames)
+    {
+      write_list_with_asm (stream, "extern void *", frame_tables.first);
+
+      fprintf (stream, "\tstatic void *frame_table[] = {\n");
+      write_list (stream, "\t\t&", frame_tables.first);
+      fprintf (stream, "\t0\n};\n");
+
+      /* This must match what's in frame.h.  */
+      fprintf (stream, "struct object {\n");
+      fprintf (stream, "  void *pc_begin;\n");
+      fprintf (stream, "  void *pc_end;\n");
+      fprintf (stream, "  void *fde_begin;\n");
+      fprintf (stream, "  void *fde_array;\n");
+      fprintf (stream, "  __SIZE_TYPE__ count;\n");
+      fprintf (stream, "  struct object *next;\n");
+      fprintf (stream, "};\n");
+
+      fprintf (stream, "extern void __register_frame_info_table (void *, struct object *);\n");
+      fprintf (stream, "extern void *__deregister_frame_info (void *);\n");
+
+      fprintf (stream, "static void reg_frame () {\n");
+      fprintf (stream, "\tstatic struct object ob;\n");
+      fprintf (stream, "\t__register_frame_info_table (frame_table, &ob);\n");
+      fprintf (stream, "\t}\n");
+
+      fprintf (stream, "static void dereg_frame () {\n");
+      fprintf (stream, "\t__deregister_frame_info (frame_table);\n");
+      fprintf (stream, "\t}\n");
+    }
+
+  fprintf (stream, "void %s() {\n", initname);
+  if (constructors.number > 0 || frames)
+    {
+      fprintf (stream, "\tstatic entry_pt *ctors[] = {\n");
+      write_list (stream, "\t\t", constructors.first);
+      if (frames)
+	fprintf (stream, "\treg_frame,\n");
+      fprintf (stream, "\t};\n");
+      fprintf (stream, "\tentry_pt **p;\n");
+      fprintf (stream, "\tif (count++ != 0) return;\n");
+      fprintf (stream, "\tp = ctors + %d;\n", constructors.number + frames);
+      fprintf (stream, "\twhile (p > ctors) (*--p)();\n");
+    }
+  else
+    fprintf (stream, "\t++count;\n");
+  fprintf (stream, "}\n");
+  write_list_with_asm (stream, "extern entry_pt ", destructors.first);
+  fprintf (stream, "void %s() {\n", fininame);
+  if (destructors.number > 0 || frames)
+    {
+      fprintf (stream, "\tstatic entry_pt *dtors[] = {\n");
+      write_list (stream, "\t\t", destructors.first);
+      if (frames)
+	fprintf (stream, "\tdereg_frame,\n");
+      fprintf (stream, "\t};\n");
+      fprintf (stream, "\tentry_pt **p;\n");
+      fprintf (stream, "\tif (--count != 0) return;\n");
+      fprintf (stream, "\tp = dtors;\n");
+      fprintf (stream, "\twhile (p < dtors + %d) (*p++)();\n",
+	       destructors.number + frames);
+    }
+  fprintf (stream, "}\n");
+
+  if (shared_obj)
+    {
+      COLLECT_SHARED_INIT_FUNC(stream, initname);
+      COLLECT_SHARED_FINI_FUNC(stream, fininame);
+    }
+}
+
+/* Write the constructor/destructor tables.  */
+
+#ifndef LD_INIT_SWITCH
+static void
+write_c_file_glob (FILE *stream, const char *name ATTRIBUTE_UNUSED)
+{
+  /* Write the tables as C code.  */
+
+  int frames = (frame_tables.number > 0);
+
+  fprintf (stream, "typedef void entry_pt();\n\n");
+
+  write_list_with_asm (stream, "extern entry_pt ", constructors.first);
+
+  if (frames)
+    {
+      write_list_with_asm (stream, "extern void *", frame_tables.first);
+
+      fprintf (stream, "\tstatic void *frame_table[] = {\n");
+      write_list (stream, "\t\t&", frame_tables.first);
+      fprintf (stream, "\t0\n};\n");
+
+      /* This must match what's in frame.h.  */
+      fprintf (stream, "struct object {\n");
+      fprintf (stream, "  void *pc_begin;\n");
+      fprintf (stream, "  void *pc_end;\n");
+      fprintf (stream, "  void *fde_begin;\n");
+      fprintf (stream, "  void *fde_array;\n");
+      fprintf (stream, "  __SIZE_TYPE__ count;\n");
+      fprintf (stream, "  struct object *next;\n");
+      fprintf (stream, "};\n");
+
+      fprintf (stream, "extern void __register_frame_info_table (void *, struct object *);\n");
+      fprintf (stream, "extern void *__deregister_frame_info (void *);\n");
+
+      fprintf (stream, "static void reg_frame () {\n");
+      fprintf (stream, "\tstatic struct object ob;\n");
+      fprintf (stream, "\t__register_frame_info_table (frame_table, &ob);\n");
+      fprintf (stream, "\t}\n");
+
+      fprintf (stream, "static void dereg_frame () {\n");
+      fprintf (stream, "\t__deregister_frame_info (frame_table);\n");
+      fprintf (stream, "\t}\n");
+    }
+
+  fprintf (stream, "\nentry_pt * __CTOR_LIST__[] = {\n");
+  fprintf (stream, "\t(entry_pt *) %d,\n", constructors.number + frames);
+  write_list (stream, "\t", constructors.first);
+  if (frames)
+    fprintf (stream, "\treg_frame,\n");
+  fprintf (stream, "\t0\n};\n\n");
+
+  write_list_with_asm (stream, "extern entry_pt ", destructors.first);
+
+  fprintf (stream, "\nentry_pt * __DTOR_LIST__[] = {\n");
+  fprintf (stream, "\t(entry_pt *) %d,\n", destructors.number + frames);
+  write_list (stream, "\t", destructors.first);
+  if (frames)
+    fprintf (stream, "\tdereg_frame,\n");
+  fprintf (stream, "\t0\n};\n\n");
+
+  fprintf (stream, "extern entry_pt %s;\n", NAME__MAIN);
+  fprintf (stream, "entry_pt *__main_reference = %s;\n\n", NAME__MAIN);
+}
+#endif /* ! LD_INIT_SWITCH */
+
+static void
+write_c_file (FILE *stream, const char *name)
+{
+  fprintf (stream, "#ifdef __cplusplus\nextern \"C\" {\n#endif\n");
+#ifndef LD_INIT_SWITCH
+  if (! shared_obj)
+    write_c_file_glob (stream, name);
+  else
+#endif
+    write_c_file_stat (stream, name);
+  fprintf (stream, "#ifdef __cplusplus\n}\n#endif\n");
+}
+
+#ifdef COLLECT_EXPORT_LIST
+static void
+write_aix_file (FILE *stream, struct id *list)
+{
+  for (; list; list = list->next)
+    {
+      fputs (list->name, stream);
+      putc ('\n', stream);
+    }
+}
+#endif
+
+#ifdef OBJECT_FORMAT_NONE
+
+/* Generic version to scan the name list of the loaded program for
+   the symbols g++ uses for static constructors and destructors.
+
+   The constructor table begins at __CTOR_LIST__ and contains a count
+   of the number of pointers (or -1 if the constructors are built in a
+   separate section by the linker), followed by the pointers to the
+   constructor functions, terminated with a null pointer.  The
+   destructor table has the same format, and begins at __DTOR_LIST__.  */
+
+static void
+scan_prog_file (const char *prog_name, enum pass which_pass)
+{
+  void (*int_handler) (int);
+  void (*quit_handler) (int);
+  char *real_nm_argv[4];
+  const char **nm_argv = (const char **) real_nm_argv;
+  int argc = 0;
+  int pipe_fd[2];
+  char *p, buf[1024];
+  FILE *inf;
+
+  if (which_pass == PASS_SECOND)
+    return;
+
+  /* If we do not have an `nm', complain.  */
+  if (nm_file_name == 0)
+    fatal ("cannot find `nm'");
+
+  nm_argv[argc++] = nm_file_name;
+  if (NM_FLAGS[0] != '\0')
+    nm_argv[argc++] = NM_FLAGS;
+
+  nm_argv[argc++] = prog_name;
+  nm_argv[argc++] = (char *) 0;
+
+  if (pipe (pipe_fd) < 0)
+    fatal_perror ("pipe");
+
+  inf = fdopen (pipe_fd[0], "r");
+  if (inf == (FILE *) 0)
+    fatal_perror ("fdopen");
+
+  /* Trace if needed.  */
+  if (vflag)
+    {
+      const char **p_argv;
+      const char *str;
+
+      for (p_argv = &nm_argv[0]; (str = *p_argv) != (char *) 0; p_argv++)
+	fprintf (stderr, " %s", str);
+
+      fprintf (stderr, "\n");
+    }
+
+  fflush (stdout);
+  fflush (stderr);
+
+  /* Spawn child nm on pipe.  */
+  pid = vfork ();
+  if (pid == -1)
+    fatal_perror (VFORK_STRING);
+
+  if (pid == 0)			/* child context */
+    {
+      /* setup stdout */
+      if (dup2 (pipe_fd[1], 1) < 0)
+	fatal_perror ("dup2 %d 1", pipe_fd[1]);
+
+      if (close (pipe_fd[0]) < 0)
+	fatal_perror ("close %d", pipe_fd[0]);
+
+      if (close (pipe_fd[1]) < 0)
+	fatal_perror ("close %d", pipe_fd[1]);
+
+      execv (nm_file_name, real_nm_argv);
+      fatal_perror ("execv %s", nm_file_name);
+    }
+
+  /* Parent context from here on.  */
+  int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);
+#ifdef SIGQUIT
+  quit_handler = (void (*) (int)) signal (SIGQUIT, SIG_IGN);
+#endif
+
+  if (close (pipe_fd[1]) < 0)
+    fatal_perror ("close %d", pipe_fd[1]);
+
+  if (debug)
+    fprintf (stderr, "\nnm output with constructors/destructors.\n");
+
+  /* Read each line of nm output.  */
+  while (fgets (buf, sizeof buf, inf) != (char *) 0)
+    {
+      int ch, ch2;
+      char *name, *end;
+
+      /* If it contains a constructor or destructor name, add the name
+	 to the appropriate list.  */
+
+      for (p = buf; (ch = *p) != '\0' && ch != '\n' && ch != '_'; p++)
+	if (ch == ' ' && p[1] == 'U' && p[2] == ' ')
+	  break;
+
+      if (ch != '_')
+	continue;
+
+      name = p;
+      /* Find the end of the symbol name.
+	 Do not include `|', because Encore nm can tack that on the end.  */
+      for (end = p; (ch2 = *end) != '\0' && !ISSPACE (ch2) && ch2 != '|';
+	   end++)
+	continue;
+
+
+      *end = '\0';
+      switch (is_ctor_dtor (name))
+	{
+	case 1:
+	  if (which_pass != PASS_LIB)
+	    add_to_list (&constructors, name);
+	  break;
+
+	case 2:
+	  if (which_pass != PASS_LIB)
+	    add_to_list (&destructors, name);
+	  break;
+
+	case 3:
+	  if (which_pass != PASS_LIB)
+	    fatal ("init function found in object %s", prog_name);
+#ifndef LD_INIT_SWITCH
+	  add_to_list (&constructors, name);
+#endif
+	  break;
+
+	case 4:
+	  if (which_pass != PASS_LIB)
+	    fatal ("fini function found in object %s", prog_name);
+#ifndef LD_FINI_SWITCH
+	  add_to_list (&destructors, name);
+#endif
+	  break;
+
+	case 5:
+	  if (which_pass != PASS_LIB)
+	    add_to_list (&frame_tables, name);
+	  break;
+
+	default:		/* not a constructor or destructor */
+	  continue;
+	}
+
+      if (debug)
+	fprintf (stderr, "\t%s\n", buf);
+    }
+
+  if (debug)
+    fprintf (stderr, "\n");
+
+  if (fclose (inf) != 0)
+    fatal_perror ("fclose");
+
+  do_wait (nm_file_name);
+
+  signal (SIGINT,  int_handler);
+#ifdef SIGQUIT
+  signal (SIGQUIT, quit_handler);
+#endif
+}
+
+#if SUNOS4_SHARED_LIBRARIES
+
+/* Routines to scan the SunOS 4 _DYNAMIC structure to find shared libraries
+   that the output file depends upon and their initialization/finalization
+   routines, if any.  */
+
+#include <a.out.h>
+#include <fcntl.h>
+#include <link.h>
+#include <sys/mman.h>
+#include <sys/param.h>
+#include <unistd.h>
+#include <sys/dir.h>
+
+/* pointers to the object file */
+unsigned object;	/* address of memory mapped file */
+unsigned objsize;	/* size of memory mapped to file */
+char * code;		/* pointer to code segment */
+char * data;		/* pointer to data segment */
+struct nlist *symtab;	/* pointer to symbol table */
+struct link_dynamic *ld;
+struct link_dynamic_2 *ld_2;
+struct head libraries;
+
+/* Map the file indicated by NAME into memory and store its address.  */
+
+static void
+mapfile (const char *name)
+{
+  int fp;
+  struct stat s;
+  if ((fp = open (name, O_RDONLY)) == -1)
+    fatal ("unable to open file '%s'", name);
+  if (fstat (fp, &s) == -1)
+    fatal ("unable to stat file '%s'", name);
+
+  objsize = s.st_size;
+  object = (unsigned) mmap (0, objsize, PROT_READ|PROT_WRITE, MAP_PRIVATE,
+			    fp, 0);
+  if (object == (unsigned)-1)
+    fatal ("unable to mmap file '%s'", name);
+
+  close (fp);
+}
+
+/* Helpers for locatelib.  */
+
+static const char *libname;
+
+static int
+libselect (struct direct *d)
+{
+  return (strncmp (libname, d->d_name, strlen (libname)) == 0);
+}
+
+/* If one file has an additional numeric extension past LIBNAME, then put
+   that one first in the sort.  If both files have additional numeric
+   extensions, then put the one with the higher number first in the sort.
+
+   We must verify that the extension is numeric, because Sun saves the
+   original versions of patched libraries with a .FCS extension.  Files with
+   invalid extensions must go last in the sort, so that they will not be used.  */
+
+static int
+libcompare (struct direct **d1, struct direct **d2)
+{
+  int i1, i2 = strlen (libname);
+  char *e1 = (*d1)->d_name + i2;
+  char *e2 = (*d2)->d_name + i2;
+
+  while (*e1 && *e2 && *e1 == '.' && *e2 == '.'
+	 && e1[1] && ISDIGIT (e1[1]) && e2[1] && ISDIGIT (e2[1]))
+    {
+      ++e1;
+      ++e2;
+      i1 = strtol (e1, &e1, 10);
+      i2 = strtol (e2, &e2, 10);
+      if (i1 != i2)
+	return i1 - i2;
+    }
+
+  if (*e1)
+    {
+      /* It has a valid numeric extension, prefer this one.  */
+      if (*e1 == '.' && e1[1] && ISDIGIT (e1[1]))
+	return 1;
+      /* It has an invalid numeric extension, must prefer the other one.  */
+      else
+	return -1;
+    }
+  else if (*e2)
+    {
+      /* It has a valid numeric extension, prefer this one.  */
+      if (*e2 == '.' && e2[1] && ISDIGIT (e2[1]))
+	return -1;
+      /* It has an invalid numeric extension, must prefer the other one.  */
+      else
+	return 1;
+    }
+  else
+    return 0;
+}
+
+/* Given the name NAME of a dynamic dependency, find its pathname and add
+   it to the list of libraries.  */
+
+static void
+locatelib (const char *name)
+{
+  static const char **l;
+  static int cnt;
+  char buf[MAXPATHLEN];
+  char *p, *q;
+  const char **pp;
+
+  if (l == 0)
+    {
+      char *ld_rules;
+      char *ldr = 0;
+      /* counting elements in array, need 1 extra for null */
+      cnt = 1;
+      ld_rules = (char *) (ld_2->ld_rules + code);
+      if (ld_rules)
+	{
+	  cnt++;
+	  for (; *ld_rules != 0; ld_rules++)
+	    if (*ld_rules == ':')
+	      cnt++;
+	  ld_rules = (char *) (ld_2->ld_rules + code);
+	  ldr = xstrdup (ld_rules);
+	}
+      p = getenv ("LD_LIBRARY_PATH");
+      q = 0;
+      if (p)
+	{
+	  cnt++;
+	  for (q = p ; *q != 0; q++)
+	    if (*q == ':')
+	      cnt++;
+	  q = xstrdup (p);
+	}
+      l = xmalloc ((cnt + 3) * sizeof (char *));
+      pp = l;
+      if (ldr)
+	{
+	  *pp++ = ldr;
+	  for (; *ldr != 0; ldr++)
+	    if (*ldr == ':')
+	      {
+		*ldr++ = 0;
+		*pp++ = ldr;
+	      }
+	}
+      if (q)
+	{
+	  *pp++ = q;
+	  for (; *q != 0; q++)
+	    if (*q == ':')
+	      {
+		*q++ = 0;
+		*pp++ = q;
+	      }
+	}
+      /* built in directories are /lib, /usr/lib, and /usr/local/lib */
+      *pp++ = "/lib";
+      *pp++ = "/usr/lib";
+      *pp++ = "/usr/local/lib";
+      *pp = 0;
+    }
+  libname = name;
+  for (pp = l; *pp != 0 ; pp++)
+    {
+      struct direct **namelist;
+      int entries;
+      if ((entries = scandir (*pp, &namelist, libselect, libcompare)) > 0)
+	{
+	  sprintf (buf, "%s/%s", *pp, namelist[entries - 1]->d_name);
+	  add_to_list (&libraries, buf);
+	  if (debug)
+	    fprintf (stderr, "%s\n", buf);
+	  break;
+	}
+    }
+  if (*pp == 0)
+    {
+      if (debug)
+	notice ("not found\n");
+      else
+	fatal ("dynamic dependency %s not found", name);
+    }
+}
+
+/* Scan the _DYNAMIC structure of the output file to find shared libraries
+   that it depends upon and any constructors or destructors they contain.  */
+
+static void
+scan_libraries (const char *prog_name)
+{
+  struct exec *header;
+  char *base;
+  struct link_object *lo;
+  char buff[MAXPATHLEN];
+  struct id *list;
+
+  mapfile (prog_name);
+  header = (struct exec *)object;
+  if (N_BADMAG (*header))
+    fatal ("bad magic number in file '%s'", prog_name);
+  if (header->a_dynamic == 0)
+    return;
+
+  code = (char *) (N_TXTOFF (*header) + (long) header);
+  data = (char *) (N_DATOFF (*header) + (long) header);
+  symtab = (struct nlist *) (N_SYMOFF (*header) + (long) header);
+
+  if (header->a_magic == ZMAGIC && header->a_entry == 0x20)
+    {
+      /* shared object */
+      ld = (struct link_dynamic *) (symtab->n_value + code);
+      base = code;
+    }
+  else
+    {
+      /* executable */
+      ld = (struct link_dynamic *) data;
+      base = code-PAGSIZ;
+    }
+
+  if (debug)
+    notice ("dynamic dependencies.\n");
+
+  ld_2 = (struct link_dynamic_2 *) ((long) ld->ld_un.ld_2 + (long)base);
+  for (lo = (struct link_object *) ld_2->ld_need; lo;
+       lo = (struct link_object *) lo->lo_next)
+    {
+      char *name;
+      lo = (struct link_object *) ((long) lo + code);
+      name = (char *) (code + lo->lo_name);
+      if (lo->lo_library)
+	{
+	  if (debug)
+	    fprintf (stderr, "\t-l%s.%d => ", name, lo->lo_major);
+	  sprintf (buff, "lib%s.so.%d.%d", name, lo->lo_major, lo->lo_minor);
+	  locatelib (buff);
+	}
+      else
+	{
+	  if (debug)
+	    fprintf (stderr, "\t%s\n", name);
+	  add_to_list (&libraries, name);
+	}
+    }
+
+  if (debug)
+    fprintf (stderr, "\n");
+
+  /* Now iterate through the library list adding their symbols to
+     the list.  */
+  for (list = libraries.first; list; list = list->next)
+    scan_prog_file (list->name, PASS_LIB);
+}
+
+#else  /* SUNOS4_SHARED_LIBRARIES */
+#ifdef LDD_SUFFIX
+
+/* Use the List Dynamic Dependencies program to find shared libraries that
+   the output file depends upon and their initialization/finalization
+   routines, if any.  */
+
+static void
+scan_libraries (const char *prog_name)
+{
+  static struct head libraries;		/* list of shared libraries found */
+  struct id *list;
+  void (*int_handler) (int);
+  void (*quit_handler) (int);
+  char *real_ldd_argv[4];
+  const char **ldd_argv = (const char **) real_ldd_argv;
+  int argc = 0;
+  int pipe_fd[2];
+  char buf[1024];
+  FILE *inf;
+
+  /* If we do not have an `ldd', complain.  */
+  if (ldd_file_name == 0)
+    {
+      error ("cannot find `ldd'");
+      return;
+    }
+
+  ldd_argv[argc++] = ldd_file_name;
+  ldd_argv[argc++] = prog_name;
+  ldd_argv[argc++] = (char *) 0;
+
+  if (pipe (pipe_fd) < 0)
+    fatal_perror ("pipe");
+
+  inf = fdopen (pipe_fd[0], "r");
+  if (inf == (FILE *) 0)
+    fatal_perror ("fdopen");
+
+  /* Trace if needed.  */
+  if (vflag)
+    {
+      const char **p_argv;
+      const char *str;
+
+      for (p_argv = &ldd_argv[0]; (str = *p_argv) != (char *) 0; p_argv++)
+	fprintf (stderr, " %s", str);
+
+      fprintf (stderr, "\n");
+    }
+
+  fflush (stdout);
+  fflush (stderr);
+
+  /* Spawn child ldd on pipe.  */
+  pid = vfork ();
+  if (pid == -1)
+    fatal_perror (VFORK_STRING);
+
+  if (pid == 0)			/* child context */
+    {
+      /* setup stdout */
+      if (dup2 (pipe_fd[1], 1) < 0)
+	fatal_perror ("dup2 %d 1", pipe_fd[1]);
+
+      if (close (pipe_fd[0]) < 0)
+	fatal_perror ("close %d", pipe_fd[0]);
+
+      if (close (pipe_fd[1]) < 0)
+	fatal_perror ("close %d", pipe_fd[1]);
+
+      execv (ldd_file_name, real_ldd_argv);
+      fatal_perror ("execv %s", ldd_file_name);
+    }
+
+  /* Parent context from here on.  */
+  int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);
+#ifdef SIGQUIT
+  quit_handler = (void (*) (int)) signal (SIGQUIT, SIG_IGN);
+#endif
+
+  if (close (pipe_fd[1]) < 0)
+    fatal_perror ("close %d", pipe_fd[1]);
+
+  if (debug)
+    notice ("\nldd output with constructors/destructors.\n");
+
+  /* Read each line of ldd output.  */
+  while (fgets (buf, sizeof buf, inf) != (char *) 0)
+    {
+      int ch2;
+      char *name, *end, *p = buf;
+
+      /* Extract names of libraries and add to list.  */
+      PARSE_LDD_OUTPUT (p);
+      if (p == 0)
+	continue;
+
+      name = p;
+      if (strncmp (name, "not found", sizeof ("not found") - 1) == 0)
+	fatal ("dynamic dependency %s not found", buf);
+
+      /* Find the end of the symbol name.  */
+      for (end = p;
+	   (ch2 = *end) != '\0' && ch2 != '\n' && !ISSPACE (ch2) && ch2 != '|';
+	   end++)
+	continue;
+      *end = '\0';
+
+      if (access (name, R_OK) == 0)
+        add_to_list (&libraries, name);
+      else
+	fatal ("unable to open dynamic dependency '%s'", buf);
+
+      if (debug)
+	fprintf (stderr, "\t%s\n", buf);
+    }
+  if (debug)
+    fprintf (stderr, "\n");
+
+  if (fclose (inf) != 0)
+    fatal_perror ("fclose");
+
+  do_wait (ldd_file_name);
+
+  signal (SIGINT,  int_handler);
+#ifdef SIGQUIT
+  signal (SIGQUIT, quit_handler);
+#endif
+
+  /* Now iterate through the library list adding their symbols to
+     the list.  */
+  for (list = libraries.first; list; list = list->next)
+    scan_prog_file (list->name, PASS_LIB);
+}
+
+#endif /* LDD_SUFFIX */
+#endif /* SUNOS4_SHARED_LIBRARIES */
+
+#endif /* OBJECT_FORMAT_NONE */
+
+
+/*
+ * COFF specific stuff.
+ */
+
+#ifdef OBJECT_FORMAT_COFF
+
+#if defined (EXTENDED_COFF)
+
+#   define GCC_SYMBOLS(X)	(SYMHEADER(X).isymMax + SYMHEADER(X).iextMax)
+#   define GCC_SYMENT		SYMR
+#   define GCC_OK_SYMBOL(X)	((X).st == stProc || (X).st == stGlobal)
+#   define GCC_SYMINC(X)	(1)
+#   define GCC_SYMZERO(X)	(SYMHEADER(X).isymMax)
+#   define GCC_CHECK_HDR(X)	(PSYMTAB(X) != 0)
+
+#else
+
+#   define GCC_SYMBOLS(X)	(HEADER(ldptr).f_nsyms)
+#   define GCC_SYMENT		SYMENT
+#   if defined (C_WEAKEXT)
+#     define GCC_OK_SYMBOL(X) \
+       (((X).n_sclass == C_EXT || (X).n_sclass == C_WEAKEXT) && \
+        ((X).n_scnum > N_UNDEF) && \
+        (aix64_flag \
+         || (((X).n_type & N_TMASK) == (DT_NON << N_BTSHFT) \
+             || ((X).n_type & N_TMASK) == (DT_FCN << N_BTSHFT))))
+#     define GCC_UNDEF_SYMBOL(X) \
+       (((X).n_sclass == C_EXT || (X).n_sclass == C_WEAKEXT) && \
+        ((X).n_scnum == N_UNDEF))
+#   else
+#     define GCC_OK_SYMBOL(X) \
+       (((X).n_sclass == C_EXT) && \
+        ((X).n_scnum > N_UNDEF) && \
+        (aix64_flag \
+         || (((X).n_type & N_TMASK) == (DT_NON << N_BTSHFT) \
+             || ((X).n_type & N_TMASK) == (DT_FCN << N_BTSHFT))))
+#     define GCC_UNDEF_SYMBOL(X) \
+       (((X).n_sclass == C_EXT) && ((X).n_scnum == N_UNDEF))
+#   endif
+#   define GCC_SYMINC(X)	((X).n_numaux+1)
+#   define GCC_SYMZERO(X)	0
+
+/* 0757 = U803XTOCMAGIC (AIX 4.3) and 0767 = U64_TOCMAGIC (AIX V5) */
+#ifdef _AIX51
+#   define GCC_CHECK_HDR(X) \
+     ((HEADER (X).f_magic == U802TOCMAGIC && ! aix64_flag) \
+      || (HEADER (X).f_magic == 0767 && aix64_flag))
+#else
+#   define GCC_CHECK_HDR(X) \
+     ((HEADER (X).f_magic == U802TOCMAGIC && ! aix64_flag) \
+      || (HEADER (X).f_magic == 0757 && aix64_flag))
+#endif
+
+#endif
+
+#ifdef COLLECT_EXPORT_LIST
+/* Array of standard AIX libraries which should not
+   be scanned for ctors/dtors.  */
+static const char *const aix_std_libs[] = {
+  "/unix",
+  "/lib/libc.a",
+  "/lib/libm.a",
+  "/lib/libc_r.a",
+  "/lib/libm_r.a",
+  "/usr/lib/libc.a",
+  "/usr/lib/libm.a",
+  "/usr/lib/libc_r.a",
+  "/usr/lib/libm_r.a",
+  "/usr/lib/threads/libc.a",
+  "/usr/ccs/lib/libc.a",
+  "/usr/ccs/lib/libm.a",
+  "/usr/ccs/lib/libc_r.a",
+  "/usr/ccs/lib/libm_r.a",
+  NULL
+};
+
+/* This function checks the filename and returns 1
+   if this name matches the location of a standard AIX library.  */
+static int ignore_library (const char *);
+static int
+ignore_library (const char *name)
+{
+  const char *const *p = &aix_std_libs[0];
+  while (*p++ != NULL)
+    if (! strcmp (name, *p)) return 1;
+  return 0;
+}
+#endif /* COLLECT_EXPORT_LIST */
+
+#if defined (HAVE_DECL_LDGETNAME) && !HAVE_DECL_LDGETNAME
+extern char *ldgetname (LDFILE *, GCC_SYMENT *);
+#endif
+
+/* COFF version to scan the name list of the loaded program for
+   the symbols g++ uses for static constructors and destructors.
+
+   The constructor table begins at __CTOR_LIST__ and contains a count
+   of the number of pointers (or -1 if the constructors are built in a
+   separate section by the linker), followed by the pointers to the
+   constructor functions, terminated with a null pointer.  The
+   destructor table has the same format, and begins at __DTOR_LIST__.  */
+
+static void
+scan_prog_file (const char *prog_name, enum pass which_pass)
+{
+  LDFILE *ldptr = NULL;
+  int sym_index, sym_count;
+  int is_shared = 0;
+
+  if (which_pass != PASS_FIRST && which_pass != PASS_OBJ)
+    return;
+
+#ifdef COLLECT_EXPORT_LIST
+  /* We do not need scanning for some standard C libraries.  */
+  if (which_pass == PASS_FIRST && ignore_library (prog_name))
+    return;
+
+  /* On AIX we have a loop, because there is not much difference
+     between an object and an archive. This trick allows us to
+     eliminate scan_libraries() function.  */
+  do
+    {
+#endif
+      /* Some platforms (e.g. OSF4) declare ldopen as taking a
+         non-const char * filename parameter, even though it will not
+         modify that string.  So we must cast away const-ness here,
+         which will cause -Wcast-qual to burp.  */
+      if ((ldptr = ldopen ((char *)prog_name, ldptr)) != NULL)
+	{
+	  if (! MY_ISCOFF (HEADER (ldptr).f_magic))
+	    fatal ("%s: not a COFF file", prog_name);
+
+	  if (GCC_CHECK_HDR (ldptr))
+	    {
+	      sym_count = GCC_SYMBOLS (ldptr);
+	      sym_index = GCC_SYMZERO (ldptr);
+
+#ifdef COLLECT_EXPORT_LIST
+	      /* Is current archive member a shared object?  */
+	      is_shared = HEADER (ldptr).f_flags & F_SHROBJ;
+#endif
+
+	      while (sym_index < sym_count)
+		{
+		  GCC_SYMENT symbol;
+
+		  if (ldtbread (ldptr, sym_index, &symbol) <= 0)
+		    break;
+		  sym_index += GCC_SYMINC (symbol);
+
+		  if (GCC_OK_SYMBOL (symbol))
+		    {
+		      char *name;
+
+		      if ((name = ldgetname (ldptr, &symbol)) == NULL)
+			continue;		/* Should never happen.  */
+
+#ifdef XCOFF_DEBUGGING_INFO
+		      /* All AIX function names have a duplicate entry
+			 beginning with a dot.  */
+		      if (*name == '.')
+			++name;
+#endif
+
+		      switch (is_ctor_dtor (name))
+			{
+			case 1:
+			  if (! is_shared)
+			    add_to_list (&constructors, name);
+#if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
+			  if (which_pass == PASS_OBJ)
+			    add_to_list (&exports, name);
+#endif
+			  break;
+
+			case 2:
+			  if (! is_shared)
+			    add_to_list (&destructors, name);
+#if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
+			  if (which_pass == PASS_OBJ)
+			    add_to_list (&exports, name);
+#endif
+			  break;
+
+#ifdef COLLECT_EXPORT_LIST
+			case 3:
+#ifndef LD_INIT_SWITCH
+			  if (is_shared)
+			    add_to_list (&constructors, name);
+#endif
+			  break;
+
+			case 4:
+#ifndef LD_INIT_SWITCH
+			  if (is_shared)
+			    add_to_list (&destructors, name);
+#endif
+			  break;
+#endif
+
+			case 5:
+			  if (! is_shared)
+			    add_to_list (&frame_tables, name);
+#if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
+			  if (which_pass == PASS_OBJ)
+			    add_to_list (&exports, name);
+#endif
+			  break;
+
+			default:	/* not a constructor or destructor */
+#ifdef COLLECT_EXPORT_LIST
+			  /* Explicitly export all global symbols when
+			     building a shared object on AIX, but do not
+			     re-export symbols from another shared object
+			     and do not export symbols if the user
+			     provides an explicit export list.  */
+			  if (shared_obj && !is_shared
+			      && which_pass == PASS_OBJ && !export_flag)
+			    add_to_list (&exports, name);
+#endif
+			  continue;
+			}
+
+		      if (debug)
+#if !defined(EXTENDED_COFF)
+			fprintf (stderr, "\tsec=%d class=%d type=%s%o %s\n",
+				 symbol.n_scnum, symbol.n_sclass,
+				 (symbol.n_type ? "0" : ""), symbol.n_type,
+				 name);
+#else
+			fprintf (stderr,
+				 "\tiss = %5d, value = %5ld, index = %5d, name = %s\n",
+				 symbol.iss, (long) symbol.value, symbol.index, name);
+#endif
+		    }
+		}
+	    }
+#ifdef COLLECT_EXPORT_LIST
+	  else
+	    {
+	      /* If archive contains both 32-bit and 64-bit objects,
+		 we want to skip objects in other mode so mismatch normal.  */
+	      if (debug)
+		fprintf (stderr, "%s : magic=%o aix64=%d mismatch\n",
+			 prog_name, HEADER (ldptr).f_magic, aix64_flag);
+	    }
+#endif
+	}
+      else
+	{
+	  fatal ("%s: cannot open as COFF file", prog_name);
+	}
+#ifdef COLLECT_EXPORT_LIST
+      /* On AIX loop continues while there are more members in archive.  */
+    }
+  while (ldclose (ldptr) == FAILURE);
+#else
+  /* Otherwise we simply close ldptr.  */
+  (void) ldclose(ldptr);
+#endif
+}
+#endif /* OBJECT_FORMAT_COFF */
+
+#ifdef COLLECT_EXPORT_LIST
+/* Given a library name without "lib" prefix, this function
+   returns a full library name including a path.  */
+static char *
+resolve_lib_name (const char *name)
+{
+  char *lib_buf;
+  int i, j, l = 0;
+  /* Library extensions for AIX dynamic linking.  */
+  const char * const libexts[2] = {"a", "so"};
+
+  for (i = 0; libpaths[i]; i++)
+    if (libpaths[i]->max_len > l)
+      l = libpaths[i]->max_len;
+
+  lib_buf = xmalloc (l + strlen(name) + 10);
+
+  for (i = 0; libpaths[i]; i++)
+    {
+      struct prefix_list *list = libpaths[i]->plist;
+      for (; list; list = list->next)
+	{
+	  /* The following lines are needed because path_prefix list
+	     may contain directories both with trailing '/' and
+	     without it.  */
+	  const char *p = "";
+	  if (list->prefix[strlen(list->prefix)-1] != '/')
+	    p = "/";
+	  for (j = 0; j < 2; j++)
+	    {
+	      sprintf (lib_buf, "%s%slib%s.%s",
+		       list->prefix, p, name,
+		       libexts[(j + aixrtl_flag) % 2]);
+	      if (debug) fprintf (stderr, "searching for: %s\n", lib_buf);
+	      if (file_exists (lib_buf))
+		{
+		  if (debug) fprintf (stderr, "found: %s\n", lib_buf);
+		  return (lib_buf);
+		}
+	    }
+	}
+    }
+  if (debug)
+    fprintf (stderr, "not found\n");
+  else
+    fatal ("library lib%s not found", name);
+  return (NULL);
+}
+#endif /* COLLECT_EXPORT_LIST */
diff -uNr gcc-3.4.6.orig/gcc/Makefile.in gcc-3.4.6/gcc/Makefile.in
--- gcc-3.4.6.orig/gcc/Makefile.in	2005-02-24 10:26:59.000000000 +0100
+++ gcc-3.4.6/gcc/Makefile.in	2007-11-13 08:48:20.000000000 +0100
@@ -2945,9 +2945,9 @@
 install-driver: installdirs xgcc$(exeext)
 	-rm -f $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
 	-$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
-	-rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-$(version)
+	-rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-$(version)$(exeext)
 	-( cd $(DESTDIR)$(bindir) && \
-	   $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-$(version) )
+	   $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-$(version)$(exeext) )
 	-if [ -f gcc-cross$(exeext) ] ; then \
 	  if [ -d $(DESTDIR)$(gcc_tooldir)/bin/. ] ; then \
 	    rm -f $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
diff -uNr gcc-3.4.6.orig/gcc/Makefile.in.orig gcc-3.4.6/gcc/Makefile.in.orig
--- gcc-3.4.6.orig/gcc/Makefile.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/Makefile.in.orig	2005-02-24 10:26:59.000000000 +0100
@@ -0,0 +1,3914 @@
+# Makefile for GNU Compiler Collection
+# Run 'configure' to generate Makefile from Makefile.in
+
+# Copyright (C) 1987, 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
+# 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+
+#This file is part of GCC.
+
+#GCC is free software; you can redistribute it and/or modify
+#it under the terms of the GNU General Public License as published by
+#the Free Software Foundation; either version 2, or (at your option)
+#any later version.
+
+#GCC is distributed in the hope that it will be useful,
+#but WITHOUT ANY WARRANTY; without even the implied warranty of
+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#GNU General Public License for more details.
+
+#You should have received a copy of the GNU General Public License
+#along with GCC; see the file COPYING.  If not, write to
+#the Free Software Foundation, 59 Temple Place - Suite 330,
+#Boston MA 02111-1307, USA.
+
+# The targets for external use include:
+# all, doc, proto, install, install-cross, install-cross-rest,
+# uninstall, TAGS, mostlyclean, clean, distclean, maintainer-clean,
+# stage1, stage2, stage3, stage4.
+
+# This is the default target.
+# Set by autoconf to "all.internal" for a native build, or
+# "all.cross" to build a cross compiler.
+all: @ALL@
+
+# Depend on this to specify a phony target portably.
+force:
+
+# This tells GNU make version 3 not to export the variables
+# defined in this file into the environment (and thus recursive makes).
+.NOEXPORT:
+# And this tells it not to automatically pass command-line variables
+# to recursive makes.
+MAKEOVERRIDES =
+
+# Suppress smart makes who think they know how to automake yacc and flex file
+.y.c:
+.l.c:
+
+# The only suffixes we want for implicit rules are .c and .o, so clear
+# the list and add them.  This speeds up GNU Make, and allows -r to work.
+# For i18n support, we also need .gmo, .po, .pox.
+# This must come before the language makefile fragments to allow them to
+# add suffixes and rules of their own.
+.SUFFIXES:
+.SUFFIXES: .c .o .po .pox .gmo
+
+# -------------------------------
+# Standard autoconf-set variables
+# -------------------------------
+
+build=@build@
+host=@host@
+target=@target@
+target_noncanonical:=@target_noncanonical@
+
+# Sed command to transform gcc to installed name.
+program_transform_name := @program_transform_name@
+
+# -----------------------------
+# Directories used during build
+# -----------------------------
+
+# Directory where sources are, from where we are.
+srcdir = @srcdir@
+docdir = @srcdir@/doc
+
+# Directory where sources are, absolute.
+abs_srcdir = @abs_srcdir@
+abs_docdir = @abs_srcdir@/doc
+
+# Top build directory, relative to here.
+top_builddir = ..
+# objdir is set by configure.
+# It's normally the absolute path to the current directory.
+objdir = @objdir@
+
+# --------
+# Defined vpaths
+# --------
+
+# Directory where sources are, from where we are.
+VPATH = @srcdir@
+
+# We define a vpath for the sources of the .texi files here because they 
+# are split between multiple directories and we would rather use one implicit
+# pattern rule for everything.
+# This vpath could be extended within the Make-lang fragments.
+
+vpath %.texi $(docdir):$(docdir)/include
+
+# ----
+# Default values for variables overridden in Makefile fragments.
+# These need to be quite early in the Makefile so as to avoid
+# trouble induced by changes in fragment ordering.
+# ----
+
+# For ada/Make-lang.in; overridden in, for example, config/pa/x-ada.
+X_ADA_CFLAGS =
+T_ADA_CFLAGS =
+X_ADAFLAGS =
+T_ADAFLAGS =
+
+# --------
+# UNSORTED
+# --------
+
+# Variables that exist for you to override.
+# See below for how to change them for certain systems.
+
+# List of language subdirectories.
+SUBDIRS =@subdirs@
+
+# Selection of languages to be made.
+CONFIG_LANGUAGES = @all_languages@
+LANGUAGES = c gcov$(exeext) gcov-dump$(exeext) $(CONFIG_LANGUAGES)
+
+# Selection of languages to be made during stage1 build.
+BOOT_LANGUAGES = c @all_boot_languages@
+
+# Various ways of specifying flags for compilations:
+# CFLAGS is for the user to override to, e.g., do a cross build with -O2.
+# For recursive  bootstrap builds CFLAGS is used to pass in STAGE1_CFLAGS
+# or BOOT_CFLAGS
+# STAGE1_CFLAGS is set by configure on some targets or passed from toplevel
+# and sets the CFLAGS passed to stage1 of a bootstrap compilation.
+# BOOT_CFLAGS is the value of CFLAGS to pass to the stage2, stage3 and stage4
+# bootstrap compilations.
+# XCFLAGS is used for most compilations but not when using the GCC just built.
+# TCFLAGS is used for compilations with the GCC just built.
+XCFLAGS =
+TCFLAGS =
+CFLAGS = -g
+STAGE1_CFLAGS = -g @stage1_cflags@
+BOOT_CFLAGS = -g -O2
+
+# Flags to determine code coverage. When coverage is disabled, this will
+# contain the optimization flags, as you normally want code coverage
+# without optimization.
+COVERAGE_FLAGS = @coverage_flags@
+coverageexts = .{gcda,gcno}
+
+# The warning flags are separate from BOOT_CFLAGS because people tend to
+# override optimization flags and we'd like them to still have warnings
+# turned on.  These flags are also used to pass other stage dependent
+# flags from configure.  The user is free to explicitly turn these flags
+# off if they wish.
+# LOOSE_WARN are the warning flags to use when compiling something
+# which is only compiled with gcc, such as libgcc and the frontends
+# other than C.
+# STRICT_WARN and STRICT2_WARN are the additional warning flags to
+# apply to the back end and the C front end, which may be compiled
+# with other compilers.  This is partially controlled by configure in
+# stage1, as not all versions of gcc understand -Wno-long-long.
+LOOSE_WARN = -W -Wall -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes
+STRICT_WARN = @strict1_warn@
+STRICT2_WARN = -pedantic -Wno-long-long -Wold-style-definition @WERROR@
+
+# This is set by --enable-checking.  The idea is to catch forgotten
+# "extern" tags in header files.
+NOCOMMON_FLAG = @nocommon_flag@
+
+# This is set by --disable-maintainer-mode (default) to "#"
+MAINT := @MAINT@
+
+# These are set by --enable-checking=valgrind.
+RUN_GEN = @valgrind_command@
+VALGRIND_DRIVER_DEFINES = @valgrind_path_defines@
+
+# This is how we control whether or not the additional warnings are applied.
+.-warn = $(STRICT_WARN)
+GCC_WARN_CFLAGS = $(LOOSE_WARN) $($(@D)-warn) $(NOCOMMON_FLAG) $($@-warn)
+
+# These files are to have -Werror bypassed in stage2:
+# These are very hard to completely clean due to target complexities.
+gcc.o-warn = -Wno-error
+insn-conditions.o-warn = -Wno-error
+# Bison-1.75 output often yields (harmless) -Wtraditional warnings
+gengtype-yacc.o-warn = -Wno-error
+c-parse.o-warn = -Wno-error
+# flex output may yield harmless "no previous prototype" warnings
+gengtype-lex.o-warn = -Wno-error
+# SYSCALLS.c misses prototypes
+SYSCALLS.c.X-warn = -Wno-strict-prototypes -Wno-error
+
+# All warnings have to be shut off in stage1 if the compiler used then
+# isn't gcc; configure determines that.  WARN_CFLAGS will be either
+# $(GCC_WARN_CFLAGS), or nothing.
+WARN_CFLAGS = @warn_cflags@
+
+CPPFLAGS = @CPPFLAGS@
+
+# These exists to be overridden by the x-* and t-* files, respectively.
+X_CFLAGS =
+T_CFLAGS =
+
+X_CPPFLAGS =
+T_CPPFLAGS =
+
+AWK = @AWK@
+CC = @CC@
+BISON = @BISON@
+BISONFLAGS =
+FLEX = @FLEX@
+FLEXFLAGS =
+AR = ar
+AR_FLAGS = rc
+RANLIB = @RANLIB@
+
+# -------------------------------------------
+# Programs which operate on the build machine
+# -------------------------------------------
+
+SHELL = @SHELL@
+# pwd command to use.  Allow user to override default by setting PWDCMD in
+# the environment to account for automounters.  The make variable must not
+# be called PWDCMD, otherwise the value set here is passed to make
+# subprocesses and overrides the setting from the user's environment.
+# Don't use PWD since it is a common shell environment variable and we
+# don't want to corrupt it.
+PWD_COMMAND = $${PWDCMD-pwd}
+# on sysV, define this as cp.
+INSTALL = @INSTALL@
+# Some systems may be missing symbolic links, regular links, or both.
+# Allow configure to check this and use "ln -s", "ln", or "cp" as appropriate.
+LN=@LN@
+LN_S=@LN_S@
+# These permit overriding just for certain files.
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL@
+MAKEINFO = @MAKEINFO@
+MAKEINFOFLAGS = --no-split
+TEXI2DVI = texi2dvi
+TEXI2POD = perl $(srcdir)/../contrib/texi2pod.pl
+POD2MAN = pod2man --center="GNU" --release="gcc-$(version)"
+# Some versions of `touch' (such as the version on Solaris 2.8)
+# do not correctly set the timestamp due to buggy versions of `utime'
+# in the kernel.  So, we use `echo' instead.
+STAMP = echo timestamp >
+
+# Make sure the $(MAKE) variable is defined.
+@SET_MAKE@
+REMAKEFLAGS=LANGUAGES="$(LANGUAGES)" BOOT_CFLAGS="$(BOOT_CFLAGS)"
+
+# --------
+# UNSORTED
+# --------
+
+# Some compilers can't handle cc -c blah.c -o foo/blah.o.
+# In stage2 and beyond, we force this to "-o $@" since we know we're using gcc.
+OUTPUT_OPTION = @OUTPUT_OPTION@
+
+# This is where we get zlib from.  zlibdir is -L../zlib and zlibinc is
+# -I../zlib, unless we were configured with --with-system-zlib, in which
+# case both are empty.
+ZLIB = @zlibdir@ -lz
+ZLIBINC = @zlibinc@
+
+# Substitution type for target's getgroups 2nd arg.
+TARGET_GETGROUPS_T = @TARGET_GETGROUPS_T@
+
+# Target to use when installing include directory.  Either
+# install-headers-tar, install-headers-cpio or install-headers-cp.
+INSTALL_HEADERS_DIR = @build_install_headers_dir@
+
+# Header files that are made available under the same name
+# to programs compiled with GCC.
+USER_H = $(srcdir)/ginclude/float.h \
+	 $(srcdir)/ginclude/iso646.h \
+	 $(srcdir)/ginclude/stdarg.h \
+	 $(srcdir)/ginclude/stdbool.h \
+	 $(srcdir)/ginclude/stddef.h \
+	 $(srcdir)/ginclude/varargs.h \
+	 $(srcdir)/unwind.h \
+	 $(EXTRA_HEADERS)
+
+# The GCC to use for compiling libgcc.a and crt*.o.
+# Usually the one we just built.
+# Don't use this as a dependency--use $(GCC_PASSES) or $(GCC_PARTS).
+GCC_FOR_TARGET = $(STAGE_CC_WRAPPER) ./xgcc -B./ -B$(build_tooldir)/bin/ -isystem $(build_tooldir)/include -isystem $(build_tooldir)/sys-include -L$(objdir)/../ld
+
+# This is used instead of ALL_CFLAGS when compiling with GCC_FOR_TARGET.
+# It omits XCFLAGS, and specifies -B./.
+# It also specifies -isystem ./include to find, e.g., stddef.h.
+GCC_CFLAGS=$(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(LOOSE_WARN) -Wold-style-definition $($@-warn) -isystem ./include $(TCFLAGS)
+
+# ---------------------------------------------------
+# Programs which produce files for the target machine
+# ---------------------------------------------------
+
+AR_FOR_TARGET = ` \
+  if [ -f $(objdir)/../binutils/ar ] ; then \
+    echo $(objdir)/../binutils/ar ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo ar; \
+    else \
+       t='$(program_transform_name)'; echo ar | sed -e $$t ; \
+    fi; \
+  fi`
+AR_FLAGS_FOR_TARGET =
+AR_CREATE_FOR_TARGET = $(AR_FOR_TARGET) $(AR_FLAGS_FOR_TARGET) rc
+AR_EXTRACT_FOR_TARGET = $(AR_FOR_TARGET) $(AR_FLAGS_FOR_TARGET) x
+RANLIB_FOR_TARGET = ` \
+  if [ -f $(objdir)/../binutils/ranlib ] ; then \
+    echo $(objdir)/../binutils/ranlib ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo $(RANLIB); \
+    else \
+       t='$(program_transform_name)'; echo ranlib | sed -e $$t ; \
+    fi; \
+  fi`
+NM_FOR_TARGET = ` \
+  if [ -f ./nm ] ; then \
+    echo ./nm ; \
+  elif [ -f $(objdir)/../binutils/nm-new ] ; then \
+    echo $(objdir)/../binutils/nm-new ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo nm; \
+    else \
+       t='$(program_transform_name)'; echo nm | sed -e $$t ; \
+    fi; \
+  fi`
+
+# --------
+# UNSORTED
+# --------
+
+# Where to find some libiberty headers.
+HASHTAB_H   = $(srcdir)/../include/hashtab.h
+OBSTACK_H   = $(srcdir)/../include/obstack.h
+SPLAY_TREE_H= $(srcdir)/../include/splay-tree.h
+FIBHEAP_H   = $(srcdir)/../include/fibheap.h
+PARTITION_H = $(srcdir)/../include/partition.h
+
+# Default native SYSTEM_HEADER_DIR, to be overridden by targets.
+NATIVE_SYSTEM_HEADER_DIR = /usr/include
+# Default cross SYSTEM_HEADER_DIR, to be overridden by targets.
+CROSS_SYSTEM_HEADER_DIR = @CROSS_SYSTEM_HEADER_DIR@
+
+# autoconf sets SYSTEM_HEADER_DIR to one of the above.
+SYSTEM_HEADER_DIR = @SYSTEM_HEADER_DIR@
+
+# Control whether to run fixproto and fixincludes.
+STMP_FIXPROTO = @STMP_FIXPROTO@
+STMP_FIXINC = @STMP_FIXINC@
+
+# Test to see whether <limits.h> exists in the system header files.
+LIMITS_H_TEST = [ -f $(SYSTEM_HEADER_DIR)/limits.h ]
+
+# Directory for prefix to system directories, for
+# each of $(system_prefix)/usr/include, $(system_prefix)/usr/lib, etc.
+TARGET_SYSTEM_ROOT = @TARGET_SYSTEM_ROOT@
+
+xmake_file=@xmake_file@
+tmake_file=@tmake_file@
+out_file=$(srcdir)/config/@out_file@
+out_object_file=@out_object_file@
+md_file=$(srcdir)/config/@md_file@
+tm_file_list=@tm_file_list@
+tm_include_list=@tm_include_list@
+tm_defines=@tm_defines@
+tm_p_file_list=@tm_p_file_list@
+tm_p_include_list=@tm_p_include_list@
+build_xm_file_list=@build_xm_file_list@
+build_xm_include_list=@build_xm_include_list@
+build_xm_defines=@build_xm_defines@
+host_xm_file_list=@host_xm_file_list@
+host_xm_include_list=@host_xm_include_list@
+host_xm_defines=@host_xm_defines@
+xm_file_list=@xm_file_list@
+xm_include_list=@xm_include_list@
+xm_defines=@xm_defines@
+lang_checks=check-gcc
+lang_opt_files=@lang_opt_files@ $(srcdir)/c.opt $(srcdir)/common.opt
+lang_specs_files=@lang_specs_files@
+lang_tree_files=@lang_tree_files@
+target_cpu_default=@target_cpu_default@
+GCC_THREAD_FILE=@thread_file@
+OBJC_BOEHM_GC=@objc_boehm_gc@
+GTHREAD_FLAGS=@gthread_flags@
+extra_modes_file=@extra_modes_file@
+host_hook_obj=@out_host_hook_obj@
+# Be prepared for gcc2 merges.
+gcc_version=@gcc_version@
+gcc_version_trigger=@gcc_version_trigger@
+version=$(gcc_version)
+mainversion=`grep version_string $(srcdir)/version.c | sed -e 's/.*\"\([0-9]*\.[0-9]*\).*/\1/'`
+
+# ------------------------
+# Installation directories
+# ------------------------
+
+# Common prefix for installation directories.
+# NOTE: This directory must exist when you start installation.
+prefix = @prefix@
+# Directory in which to put localized header files. On the systems with
+# gcc as the native cc, `local_prefix' may not be `prefix' which is
+# `/usr'.
+# NOTE: local_prefix *should not* default from prefix.
+local_prefix = @local_prefix@
+# Directory in which to put host dependent programs and libraries
+exec_prefix = @exec_prefix@
+# Directory in which to put the executable for the command `gcc'
+bindir = @bindir@
+# Directory in which to put the directories used by the compiler.
+libdir = @libdir@
+# Directory in which GCC puts its executables.
+libexecdir = @libexecdir@
+
+# --------
+# UNSORTED
+# --------
+
+# Directory in which the compiler finds libraries etc.
+libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(version)
+# Directory in which the compiler finds executables
+libexecsubdir = $(libexecdir)/gcc/$(target_noncanonical)/$(version)
+# Used to produce a relative $(gcc_tooldir) in gcc.o
+unlibsubdir = ../../..
+# Directory in which to find other cross-compilation tools and headers.
+dollar = @dollar@
+# Used in install-cross.
+gcc_tooldir = @gcc_tooldir@
+# Used to install the shared libgcc.
+slibdir = @slibdir@
+# Since gcc_tooldir does not exist at build-time, use -B$(build_tooldir)/bin/
+build_tooldir = $(exec_prefix)/$(target_noncanonical)
+# Directory in which the compiler finds target-independent g++ includes.
+gcc_gxx_include_dir = @gcc_gxx_include_dir@
+# Directory to search for site-specific includes.
+local_includedir = $(local_prefix)/include
+includedir = $(prefix)/include
+# where the info files go
+infodir = @infodir@
+# Where cpp should go besides $prefix/bin if necessary
+cpp_install_dir = @cpp_install_dir@
+# where the locale files go
+datadir = @datadir@
+localedir = $(datadir)/locale
+# Extension (if any) to put in installed man-page filename.
+man1ext = .1
+man7ext = .7
+objext = .o
+exeext = @host_exeext@
+build_exeext = @build_exeext@
+
+# Directory in which to put man pages.
+mandir = @mandir@
+man1dir = $(mandir)/man1
+man7dir = $(mandir)/man7
+# Dir for temp files.
+tmpdir = /tmp
+
+# Whether we were configured with NLS.
+USE_NLS = @USE_NLS@
+
+# Internationalization library.
+LIBINTL = @LIBINTL@
+LIBINTL_DEP = @LIBINTL_DEP@
+
+# Character encoding conversion library.
+LIBICONV = @LIBICONV@
+LIBICONV_DEP = @LIBICONV_DEP@
+
+# The GC method to be used on this system.
+GGC=@GGC@.o
+
+# If a supplementary library is being used for the GC.
+GGC_LIB=
+
+# libgcc.a may be built directly or via stmp-multilib,
+# and installed likewise.  Overridden by t-fragment.
+LIBGCC = libgcc.a
+INSTALL_LIBGCC = install-libgcc
+
+# Options to use when compiling libgcc2.a.
+#
+LIBGCC2_DEBUG_CFLAGS = -g
+LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED @inhibit_libc@
+
+# Additional options to use when compiling libgcc2.a.
+# Some targets override this to -isystem include
+LIBGCC2_INCLUDES =
+
+# Additional target-dependent options for compiling libgcc2.a.
+TARGET_LIBGCC2_CFLAGS =
+
+# Options to use when compiling crtbegin/end.
+CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \
+  -finhibit-size-directive -fno-inline-functions -fno-exceptions \
+  -fno-zero-initialized-in-bss -fno-unit-at-a-time
+
+# Additional sources to handle exceptions; overridden by targets as needed.
+LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \
+   $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
+LIB2ADDEHSTATIC = $(LIB2ADDEH)
+LIB2ADDEHSHARED = $(LIB2ADDEH)
+LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h
+
+# Don't build libunwind by default.
+LIBUNWIND =
+LIBUNWINDDEP =
+SHLIBUNWIND_LINK =
+SHLIBUNWIND_INSTALL =
+
+# nm flags to list global symbols in libgcc object files.
+SHLIB_NM_FLAGS = -pg
+
+# List of extra executables that should be compiled for this target machine
+# that are used for compiling from source code to object code.
+# The rules for compiling them should be in the t-* file for the machine.
+EXTRA_PASSES =@extra_passes@
+
+# Like EXTRA_PASSES, but these are used when linking.
+EXTRA_PROGRAMS = @extra_programs@
+
+# List of extra object files that should be compiled for this target machine.
+# The rules for compiling them should be in the t-* file for the machine.
+EXTRA_PARTS = @extra_parts@
+
+# List of extra object files that should be compiled and linked with
+# compiler proper (cc1, cc1obj, cc1plus).
+EXTRA_OBJS = @extra_objs@
+
+# List of extra object files that should be compiled and linked with
+# the gcc driver.
+EXTRA_GCC_OBJS =@extra_gcc_objs@
+
+# List of additional header files to install.
+EXTRA_HEADERS =@extra_headers_list@
+
+# It is convenient for configure to add the assignment at the beginning,
+# so don't override it here.
+USE_COLLECT2 = collect2$(exeext)
+
+# List of extra C and assembler files to add to static and shared libgcc2.
+# Assembler files should have names ending in `.asm'.
+LIB2FUNCS_EXTRA =
+
+# List of extra C and assembler files to add to static libgcc2.
+# Assembler files should have names ending in `.asm'.
+LIB2FUNCS_STATIC_EXTRA =
+
+# List of extra C and assembler files to add to shared libgcc2.
+# Assembler files should have names ending in `.asm'.
+LIB2FUNCS_SHARED_EXTRA =
+
+# Program to convert libraries.
+LIBCONVERT =
+
+# Control whether header files are installed.
+INSTALL_HEADERS=install-headers install-mkheaders
+
+# Control whether Info documentation is built and installed.
+BUILD_INFO = @BUILD_INFO@
+
+# Control whether manpages generated by texi2pod.pl can be rebuilt.
+GENERATED_MANPAGES = @GENERATED_MANPAGES@
+
+# Additional directories of header files to run fixincludes on.
+# These should be directories searched automatically by default
+# just as /usr/include is.
+# *Do not* use this for directories that happen to contain
+# header files, but are not searched automatically by default.
+# On most systems, this is empty.
+OTHER_FIXINCLUDES_DIRS=
+
+# A list of all the language-specific executables.
+COMPILERS = cc1$(exeext) @all_compilers@
+
+# List of things which should already be built whenever we try to use xgcc
+# to compile anything (without linking).
+GCC_PASSES=xgcc$(exeext) cc1$(exeext) specs $(EXTRA_PASSES)
+
+# List of things which should already be built whenever we try to use xgcc
+# to link anything.
+GCC_PARTS=$(GCC_PASSES) $(LIBGCC) $(EXTRA_PROGRAMS) $(USE_COLLECT2) $(EXTRA_PARTS)
+
+# Directory to link to, when using the target `maketest'.
+DIR = ../gcc
+
+# Flags to use when cross-building GCC.
+# Prefix to apply to names of object files when using them
+# to run on the machine we are compiling on.
+BUILD_PREFIX = @BUILD_PREFIX@
+# Prefix to apply to names of object files when compiling them
+# to run on the machine we are compiling on.
+# The default for this variable is chosen to keep these rules
+# out of the way of the other rules for compiling the same source files.
+BUILD_PREFIX_1 = @BUILD_PREFIX_1@
+# Native compiler for the build machine and its switches.
+CC_FOR_BUILD = @CC_FOR_BUILD@
+BUILD_CFLAGS= @BUILD_CFLAGS@ -DGENERATOR_FILE
+
+# Native linker and preprocessor flags.  For x-fragment overrides.
+BUILD_LDFLAGS=$(LDFLAGS)
+BUILD_CPPFLAGS=$(ALL_CPPFLAGS)
+
+# Actual name to use when installing a native compiler.
+GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')
+GCC_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gcc|sed '$(program_transform_name)')
+CPP_INSTALL_NAME := $(shell echo cpp|sed '$(program_transform_name)')
+PROTOIZE_INSTALL_NAME := $(shell echo protoize|sed '$(program_transform_name)')
+UNPROTOIZE_INSTALL_NAME := $(shell echo unprotoize|sed '$(program_transform_name)')
+GCOV_INSTALL_NAME := $(shell echo gcov|sed '$(program_transform_name)')
+GCCBUG_INSTALL_NAME := $(shell echo gccbug|sed '$(program_transform_name)')
+
+# Setup the testing framework, if you have one
+EXPECT = `if [ -f $${rootme}/../expect/expect ] ; then \
+            echo $${rootme}/../expect/expect ; \
+          else echo expect ; fi`
+
+RUNTEST = `if [ -f $${srcdir}/../dejagnu/runtest ] ; then \
+	       echo $${srcdir}/../dejagnu/runtest ; \
+	    else echo runtest; fi`
+RUNTESTFLAGS =
+
+# Extra symbols for fixproto to define when parsing headers.
+FIXPROTO_DEFINES =
+
+# Extra flags to use when compiling crt{begin,end}.o.
+CRTSTUFF_T_CFLAGS =
+
+# Extra flags to use when compiling [m]crt0.o.
+CRT0STUFF_T_CFLAGS =
+
+# "t" or nothing, for building multilibbed versions of, say, crtbegin.o.
+T =
+
+# Should T contain a `=', libgcc.mk will make T_TARGET, setting
+# $(T_TARGET) to the name of the actual target filename.
+T_TARGET =
+T_TARGET : $(T_TARGET)
+
+# This should name the specs file that we're going to install.  Target
+# Makefiles may override it and name another file to be generated from
+# the built-in specs and installed as the default spec, as long as
+# they also introduce a rule to generate a file name specs, to be used
+# at build time.
+SPECS = specs
+
+# End of variables for you to override.
+
+# GTM_H lists the config files that the generator files depend on,
+# while TM_H lists the ones ordinary gcc files depend on, which
+# includes several files generated by those generators.
+BCONFIG_H = bconfig.h $(build_xm_file_list)
+CONFIG_H  = config.h  $(host_xm_file_list)
+TCONFIG_H = tconfig.h $(xm_file_list)
+TM_P_H    = tm_p.h    $(tm_p_file_list)
+GTM_H     = tm.h      $(tm_file_list)
+TM_H      = $(GTM_H) insn-constants.h insn-flags.h
+
+TARGET_H = $(TM_H) target.h
+HOOKS_H = hooks.h
+LANGHOOKS_DEF_H = langhooks-def.h $(HOOKS_H)
+TARGET_DEF_H = target-def.h $(HOOKS_H)
+MACHMODE_H = machmode.h mode-classes.def insn-modes.h
+RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H)
+RTL_H = $(RTL_BASE_H) genrtl.h input.h
+PARAMS_H = params.h params.def
+TREE_H = tree.h tree.def $(MACHMODE_H) tree-check.h version.h builtins.def \
+          input.h
+BASIC_BLOCK_H = basic-block.h bitmap.h sbitmap.h varray.h $(PARTITION_H) \
+          hard-reg-set.h cfghooks.h
+COVERAGE_H = coverage.h gcov-io.h gcov-iov.h
+DEMANGLE_H = $(srcdir)/../include/demangle.h
+RECOG_H = recog.h
+EXPR_H = expr.h
+OPTABS_H = optabs.h insn-codes.h
+REGS_H = regs.h varray.h $(MACHMODE_H)
+INTEGRATE_H = integrate.h varray.h
+LOOP_H = loop.h varray.h bitmap.h
+GCC_H = gcc.h version.h
+GGC_H = ggc.h gtype-desc.h
+TIMEVAR_H = timevar.h timevar.def
+INSN_ATTR_H = insn-attr.h $(srcdir)/insn-addr.h $(srcdir)/varray.h
+C_COMMON_H = c-common.h $(SPLAY_TREE_H) $(CPPLIB_H)
+C_TREE_H = c-tree.h $(C_COMMON_H)
+SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h
+PREDICT_H = predict.h predict.def
+CPPLIB_H = cpplib.h line-map.h
+PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)
+DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H)
+C_PRETTY_PRINT_H = $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)
+
+#
+# Now figure out from those variables how to compile and link.
+
+# IN_GCC distinguishes between code compiled into GCC itself and other
+# programs built during a bootstrap.
+# autoconf inserts -DCROSS_COMPILE if we are building a cross compiler.
+INTERNAL_CFLAGS = -DIN_GCC @CROSS@
+
+# This is the variable actually used when we compile. If you change this,
+# you probably want to update BUILD_CFLAGS in configure.ac
+ALL_CFLAGS = $(X_CFLAGS) $(T_CFLAGS) \
+  $(CFLAGS) $(INTERNAL_CFLAGS) $(COVERAGE_FLAGS) $(WARN_CFLAGS) $(XCFLAGS) @DEFS@
+
+# Likewise.
+ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)
+
+# Build and host support libraries.  FORBUILD is either
+# .. or ../$(build_alias) depending on whether host != build.
+LIBIBERTY = ../libiberty/libiberty.a
+BUILD_LIBIBERTY = @FORBUILD@/libiberty/libiberty.a
+
+# Dependencies on the intl and portability libraries.
+LIBDEPS= $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP)
+
+# Likewise, for use in the tools that must run on this machine
+# even if we are cross-building GCC.
+BUILD_LIBDEPS= $(BUILD_LIBIBERTY)
+
+# How to link with both our special library facilities
+# and the system's installed libraries.
+LIBS = @LIBS@ $(LIBIBERTY) $(LIBINTL) $(LIBICONV)
+
+# Any system libraries needed just for GNAT.
+SYSLIBS = @GNAT_LIBEXC@
+
+# Libs needed (at present) just for jcf-dump.
+LDEXP_LIB = @LDEXP_LIB@
+
+# Likewise, for use in the tools that must run on this machine
+# even if we are cross-building GCC.
+BUILD_LIBS = $(BUILD_LIBIBERTY)
+
+BUILD_RTL = $(BUILD_PREFIX)rtl.o read-rtl.o $(BUILD_PREFIX)bitmap.o \
+		$(BUILD_PREFIX)ggc-none.o min-insn-modes.o
+BUILD_SUPPORT = gensupport.o insn-conditions.o
+BUILD_EARLY_SUPPORT = gensupport.o dummy-conditions.o
+
+BUILD_PRINT = print-rtl1.o
+BUILD_ERRORS = $(BUILD_PREFIX)errors.o
+BUILD_VARRAY = $(BUILD_PREFIX)varray.o
+
+# Specify the directories to be searched for header files.
+# Both . and srcdir are used, in that order,
+# so that *config.h will be found in the compilation
+# subdirectory rather than in the source directory.
+# -I$(@D) and -I$(srcdir)/$(@D) cause the subdirectory of the file
+# currently being compiled, in both source trees, to be examined as well.
+# libintl.h will be found in ../intl if we are using the included libintl.
+INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \
+	   -I$(srcdir)/../include @INCINTL@
+
+.c.o:
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+#
+# Support for additional languages (other than C).
+# C can be supported this way too (leave for later).
+
+LANG_MAKEFRAGS = @all_lang_makefrags@
+LANG_MAKEFILES = @all_lang_makefiles@
+LANG_STAGESTUFF = @all_stagestuff@
+
+# Flags to pass to recursive makes.
+# CC is set by configure.  Hosts without symlinks need special handling
+# because we need CC="stage1/xgcc -Bstage1/" to work in the language
+# subdirectories.
+# ??? The choices here will need some experimenting with.
+
+export AR_FOR_TARGET
+export AR_CREATE_FOR_TARGET
+export AR_FLAGS_FOR_TARGET
+export AR_EXTRACT_FOR_TARGET
+export AWK
+export BUILD_PREFIX
+export BUILD_PREFIX_1
+export DESTDIR
+export GCC_FOR_TARGET
+export INCLUDES
+export INSTALL_DATA
+export LIB1ASMSRC
+export LIBGCC2_CFLAGS
+export MACHMODE_H
+export NM_FOR_TARGET
+export RANLIB_FOR_TARGET
+export libsubdir
+export slibdir
+
+ORDINARY_FLAGS_TO_PASS = \
+	"BISON=$(BISON)" \
+	"BISONFLAGS=$(BISONFLAGS)" \
+	"CFLAGS=$(CFLAGS) $(WARN_CFLAGS)" \
+	"LDFLAGS=$(LDFLAGS)" \
+	"FLEX=$(FLEX)" \
+	"FLEXFLAGS=$(FLEXFLAGS)" \
+	"LN=$(LN)" \
+	"LN_S=$(LN_S)" \
+	"MAKEINFO=$(MAKEINFO)" \
+	"MAKEINFOFLAGS=$(MAKEINFOFLAGS)" \
+	"MAKEOVERRIDES=" \
+	"SHELL=$(SHELL)" \
+	"exeext=$(exeext)" \
+	"build_exeext=$(build_exeext)" \
+	"objext=$(objext)" \
+	"exec_prefix=$(exec_prefix)" \
+	"prefix=$(prefix)" \
+	"local_prefix=$(local_prefix)" \
+	"gxx_include_dir=$(gcc_gxx_include_dir)" \
+	"build_tooldir=$(build_tooldir)" \
+	"gcc_tooldir=$(gcc_tooldir)" \
+	"bindir=$(bindir)" \
+	"libexecsubdir=$(libsubdir)" \
+	"datadir=$(datadir)" \
+	"localedir=$(localedir)"
+FLAGS_TO_PASS = $(ORDINARY_FLAGS_TO_PASS) "CC=@cc_set_by_configure@" \
+	"STAGE_PREFIX=@stage_prefix_set_by_configure@"
+PREPEND_DOTDOT_TO_RELATIVE_PATHS = sed \
+	-e 's|^ *[^ /][^ /]*/|%&|' \
+	-e 's| -B| -B%|g' \
+	-e 's|% *[^- /]|%&|g' \
+	-e 's|%% *|../|g' \
+	-e 's|%||g'
+SUBDIR_FLAGS_TO_PASS = $(ORDINARY_FLAGS_TO_PASS) \
+	"CC=`echo @quoted_cc_set_by_configure@ | $(PREPEND_DOTDOT_TO_RELATIVE_PATHS)`" \
+	"STAGE_PREFIX=`echo @quoted_stage_prefix_set_by_configure@ | $(PREPEND_DOTDOT_TO_RELATIVE_PATHS)`"
+#
+# Lists of files for various purposes.
+
+# Target specific, C specific object file
+C_TARGET_OBJS=@c_target_objs@
+
+# Target specific, C++ specific object file
+CXX_TARGET_OBJS=@cxx_target_objs@
+
+# Language-specific object files for C and Objective C.
+C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \
+  c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \
+  c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \
+  c-objc-common.o c-dump.o c-pch.o libcpp.a $(C_TARGET_OBJS)
+
+# Language-specific object files for C.
+C_OBJS = c-parse.o c-lang.o c-pretty-print.o stub-objc.o $(C_AND_OBJC_OBJS)
+
+# Language-independent object files.
+
+OBJS-common = \
+ alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o	  	   \
+ cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o		   \
+ cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o	   \
+ cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o 	   \
+ dbxout.o debug.o df.o diagnostic.o dojump.o doloop.o dominance.o	   \
+ dwarf2asm.o dwarf2out.o emit-rtl.o except.o explow.o	                   \
+ expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o		   \
+ genrtl.o ggc-common.o global.o graph.o gtype-desc.o			   \
+ haifa-sched.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o insn-modes.o	   \
+ insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o	   \
+ integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  	   \
+ loop.o optabs.o options.o opts.o params.o postreload.o predict.o	   \
+ print-rtl.o print-tree.o value-prof.o					   \
+ profile.o ra.o ra-build.o ra-colorize.o ra-debug.o ra-rewrite.o	   \
+ real.o recog.o reg-stack.o regclass.o regmove.o regrename.o		   \
+ reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o	   \
+ sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o	   \
+ sibcall.o simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o 	   \
+ targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o unroll.o	   \
+ varasm.o varray.o version.o vmsdbgout.o xcoffout.o alloc-pool.o	   \
+ et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o
+
+OBJS-md = $(out_object_file)
+OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) hashtable.o tree-inline.o	   \
+  tree-optimize.o cgraph.o cgraphunit.o
+
+OBJS = $(OBJS-common) $(out_object_file) $(OBJS-archive)
+
+OBJS-onestep = libbackend.o $(OBJS-archive)
+
+BACKEND = main.o libbackend.a
+
+# Files to be copied away after each stage in building.
+STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \
+ insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \
+ insn-attr.h insn-attrtab.c insn-opinit.c insn-constants.h tm-preds.h \
+ tree-check.h insn-conditions.c min-insn-modes.c insn-modes.c insn-modes.h \
+ s-flags s-config s-codes s-mlib s-genrtl s-modes s-gtype gtyp-gen.h \
+ s-output s-recog s-emit s-extract s-peep s-check s-conditions \
+ s-attr s-attrtab s-opinit s-preds s-constants s-crt0 \
+ genemit$(build_exeext) genoutput$(build_exeext) genrecog$(build_exeext) \
+ genextract$(build_exeext) genflags$(build_exeext) gencodes$(build_exeext) \
+ genconfig$(build_exeext) genpeep$(build_exeext) genattrtab$(build_exeext) \
+ genattr$(build_exeext) genopinit$(build_exeext) gengenrtl$(build_exeext) \
+ gencheck$(build_exeext) genpreds$(build_exeext) genconstants$(build_exeext) \
+ gengtype$(build_exeext) genconditions$(build_exeext) genmodes$(build_exeext) \
+ genrtl.c genrtl.h gt-*.h gtype-*.h gtype-desc.c \
+ xgcc$(exeext) cpp$(exeext) cc1$(exeext) $(EXTRA_PASSES) \
+ $(EXTRA_PARTS) $(EXTRA_PROGRAMS) gcc-cross$(exeext) \
+ protoize$(exeext) unprotoize$(exeext) \
+ $(SPECS) collect2$(exeext) $(USE_COLLECT2) \
+ gcov-iov$(build_exeext) gcov$(exeext) gcov-dump$(exeext) \
+ *.[0-9][0-9].* *.[si] libcpp.a libbackend.a libgcc.mk \
+ $(LANG_STAGESTUFF)
+
+# Defined in libgcc2.c, included only in the static library.
+LIB2FUNCS_ST = _eprintf __gcc_bcmp
+
+# Defined in libgcov.c, included only in gcov library
+LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta
+
+FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \
+    _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \
+    _lt_sf _le_sf _unord_sf _si_to_sf _sf_to_si _negate_sf _make_sf \
+    _sf_to_df _sf_to_tf _thenan_sf _sf_to_usi _usi_to_sf
+
+DPBIT_FUNCS = _pack_df _unpack_df _addsub_df _mul_df _div_df \
+    _fpcmp_parts_df _compare_df _eq_df _ne_df _gt_df _ge_df \
+    _lt_df _le_df _unord_df _si_to_df _df_to_si _negate_df _make_df \
+    _df_to_sf _df_to_tf _thenan_df _df_to_usi _usi_to_df
+
+TPBIT_FUNCS = _pack_tf _unpack_tf _addsub_tf _mul_tf _div_tf \
+    _fpcmp_parts_tf _compare_tf _eq_tf _ne_tf _gt_tf _ge_tf \
+    _lt_tf _le_tf _unord_tf _si_to_tf _tf_to_si _negate_tf _make_tf \
+    _tf_to_df _tf_to_sf _thenan_tf _tf_to_usi _usi_to_tf
+
+# These might cause a divide overflow trap and so are compiled with
+# unwinder info.
+LIB2_DIVMOD_FUNCS = _divdi3 _moddi3 _udivdi3 _umoddi3 _udiv_w_sdiv _udivmoddi4
+
+#
+# Language makefile fragments.
+
+# The following targets define the interface between us and the languages.
+#
+# all.cross, start.encap, rest.encap,
+# install-normal, install-common, install-info, install-man,
+# uninstall,
+# mostlyclean, clean, distclean, maintainer-clean,
+# stage1, stage2, stage3, stage4
+#
+# Each language is linked in with a series of hooks.  The name of each
+# hooked is "lang.${target_name}" (eg: lang.info).  Configure computes
+# and adds these here.  We use double-colon rules for some of the hooks;
+# double-colon rules should be preferred for any new hooks.
+
+# language hooks, generated by configure
+@language_hooks@
+
+# Set up library path if needed.
+@set_gcc_lib_path@
+
+# per-language makefile fragments
+ifneq ($(LANG_MAKEFRAGS),)
+include $(LANG_MAKEFRAGS)
+endif
+
+# target and host overrides must follow the per-language makefile fragments
+# so they can override or augment language-specific variables
+
+# target overrides
+ifneq ($(tmake_file),)
+include $(tmake_file)
+endif
+
+# host overrides
+ifneq ($(xmake_file),)
+include $(xmake_file)
+endif
+
+#
+
+# -----------------------------
+# Rebuilding this configuration
+# -----------------------------
+
+Makefile: config.status $(srcdir)/Makefile.in $(srcdir)/version.c $(LANG_MAKEFRAGS)
+	LANGUAGES="$(CONFIG_LANGUAGES)" \
+	CONFIG_HEADERS= \
+	CONFIG_SHELL="$(SHELL)" \
+	CONFIG_FILES=$@ $(SHELL) config.status
+
+config.h: cs-config.h ; @true
+bconfig.h: cs-bconfig.h ; @true
+tconfig.h: cs-tconfig.h ; @true
+tm.h: cs-tm.h ; @true
+tm_p.h: cs-tm_p.h ; @true
+
+cs-config.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(host_xm_include_list)" DEFINES="$(host_xm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh config.h
+
+cs-bconfig.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(build_xm_include_list)" DEFINES="$(build_xm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh bconfig.h
+
+cs-tconfig.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(xm_include_list)" DEFINES="$(xm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh tconfig.h
+
+cs-tm.h: Makefile
+	TARGET_CPU_DEFAULT="$(target_cpu_default)" \
+	HEADERS="$(tm_include_list)" DEFINES="$(tm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh tm.h
+
+cs-tm_p.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(tm_p_include_list)" DEFINES="" \
+	$(SHELL) $(srcdir)/mkconfig.sh tm_p.h
+
+# Don't automatically run autoconf, since configure.ac might be accidentally
+# newer than configure.  Also, this writes into the source directory which
+# might be on a read-only file system.  If configured for maintainer mode
+# then do allow autoconf to be run.
+
+$(srcdir)/configure: @MAINT@ $(srcdir)/configure.ac
+	(cd $(srcdir) && autoconf)
+
+gccbug:	$(srcdir)/gccbug.in
+	CONFIG_FILES=gccbug CONFIG_HEADERS= ./config.status
+
+mklibgcc: $(srcdir)/mklibgcc.in
+	CONFIG_FILES=mklibgcc CONFIG_HEADERS= ./config.status
+
+mkheaders: $(srcdir)/mkheaders.in
+	CONFIG_FILES=mkheaders CONFIG_HEADERS= ./config.status
+
+# cstamp-h.in controls rebuilding of config.in.
+# It is named cstamp-h.in and not stamp-h.in so the mostlyclean rule doesn't
+# delete it.  A stamp file is needed as autoheader won't update the file if
+# nothing has changed.
+# It remains in the source directory and is part of the distribution.
+# This follows what is done in shellutils, fileutils, etc.
+# "echo timestamp" is used instead of touch to be consistent with other
+# packages that use autoconf (??? perhaps also to avoid problems with patch?).
+# ??? Newer versions have a maintainer mode that may be useful here.
+
+# Don't run autoheader automatically either.
+# Only run it if maintainer mode is enabled.
+@MAINT@ $(srcdir)/config.in: $(srcdir)/cstamp-h.in
+@MAINT@ $(srcdir)/cstamp-h.in: $(srcdir)/configure.ac
+@MAINT@	(cd $(srcdir) && autoheader)
+@MAINT@	@rm -f $(srcdir)/cstamp-h.in
+@MAINT@	echo timestamp > $(srcdir)/cstamp-h.in
+auto-host.h: cstamp-h ; @true
+cstamp-h: config.in config.status
+	CONFIG_HEADERS=auto-host.h:config.in \
+	CONFIG_FILES= \
+	LANGUAGES="$(CONFIG_LANGUAGES)" $(SHELL) config.status
+
+# Really, really stupid make features, such as SUN's KEEP_STATE, may force
+# a target to build even if it is up-to-date.  So we must verify that
+# config.status does not exist before failing.
+config.status: $(srcdir)/configure $(srcdir)/config.gcc version.c
+	@if [ ! -f config.status ] ; then \
+	  echo You must configure gcc.  Look at http://gcc.gnu.org/install/ for details.; \
+	  false; \
+	else \
+	  LANGUAGES="$(CONFIG_LANGUAGES)" $(SHELL) config.status --recheck; \
+	fi
+
+# --------
+# UNSORTED
+# --------
+
+all.internal: start.encap rest.encap doc
+# This is what to compile if making a cross-compiler.
+all.cross: native gcc-cross cpp$(exeext) specs \
+	$(LIBGCC) $(EXTRA_PARTS) lang.all.cross doc
+# This is what must be made before installing GCC and converting libraries.
+start.encap: native xgcc$(exeext) cpp$(exeext) specs \
+	xlimits.h lang.start.encap @GENINSRC@ srcextra
+# These can't be made until after GCC can run.
+rest.encap: $(STMP_FIXPROTO) $(LIBGCC) $(EXTRA_PARTS) lang.rest.encap
+# This is what is made with the host's compiler
+# whether making a cross compiler or not.
+native: config.status auto-host.h build-@POSUB@ $(LANGUAGES) \
+	$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2)
+
+# Define the names for selecting languages in LANGUAGES.
+C c: cc1$(exeext)
+PROTO: proto
+
+# Tell GNU make these are phony targets.
+.PHONY: C c PROTO proto
+
+# On the target machine, finish building a cross compiler.
+# This does the things that can't be done on the host machine.
+rest.cross: $(LIBGCC) specs
+
+# Recompile all the language-independent object files.
+# This is used only if the user explicitly asks for it.
+compilations: $(BACKEND)
+
+# Like libcpp.a, this archive is strictly for the host.
+libbackend.a: $(OBJS@onestep@)
+	-rm -rf libbackend.a
+	$(AR) $(AR_FLAGS) libbackend.a $(OBJS@onestep@)
+	-$(RANLIB) libbackend.a
+
+# We call this executable `xgcc' rather than `gcc'
+# to avoid confusion if the current directory is in the path
+# and CC is `gcc'.  It is renamed to `gcc' when it is installed.
+xgcc$(exeext): gcc.o gccspec.o version.o intl.o prefix.o \
+   version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o gccspec.o intl.o \
+	  prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
+
+# cpp is to cpp0 as gcc is to cc1.
+# The only difference from xgcc is that it's linked with cppspec.o
+# instead of gccspec.o.
+cpp$(exeext): gcc.o cppspec.o version.o intl.o prefix.o \
+   version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o cppspec.o intl.o \
+	  prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
+
+# Dump a specs file to make -B./ read these specs over installed ones.
+$(SPECS): xgcc$(exeext)
+	$(GCC_FOR_TARGET) -dumpspecs > tmp-specs
+	mv tmp-specs $(SPECS)
+
+# We do want to create an executable named `xgcc', so we can use it to
+# compile libgcc2.a.
+# Also create gcc-cross, so that install-common will install properly.
+gcc-cross: xgcc$(exeext)
+	cp xgcc$(exeext) gcc-cross$(exeext)
+
+cc1$(exeext): $(C_OBJS) $(BACKEND) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cc1$(exeext) \
+		$(C_OBJS) $(BACKEND) $(LIBS)
+
+# Build the version of limits.h that we will install.
+xlimits.h: glimits.h limitx.h limity.h
+	if $(LIMITS_H_TEST) ; then \
+	  cat $(srcdir)/limitx.h $(srcdir)/glimits.h $(srcdir)/limity.h > tmp-xlimits.h; \
+	else \
+	  cat $(srcdir)/glimits.h > tmp-xlimits.h; \
+	fi
+	mv tmp-xlimits.h xlimits.h
+#
+# Build libgcc.a.
+
+LIB2ADD = $(LIB2FUNCS_EXTRA)
+LIB2ADD_ST = $(LIB2FUNCS_STATIC_EXTRA)
+LIB2ADD_SH = $(LIB2FUNCS_SHARED_EXTRA)
+
+libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) $(LIB2ADD_ST) $(LIB2ADD_SH) \
+  xgcc$(exeext) specs
+	objext='$(objext)' \
+	LIB1ASMFUNCS='$(LIB1ASMFUNCS)' \
+	LIB2FUNCS_ST='$(LIB2FUNCS_ST)' \
+	LIBGCOV='$(LIBGCOV)' \
+	LIB2ADD='$(LIB2ADD)' \
+	LIB2ADD_ST='$(LIB2ADD_ST)' \
+	LIB2ADD_SH='$(LIB2ADD_SH)' \
+	LIB2ADDEH='$(LIB2ADDEH)' \
+	LIB2ADDEHSTATIC='$(LIB2ADDEHSTATIC)' \
+	LIB2ADDEHSHARED='$(LIB2ADDEHSHARED)' \
+	LIB2ADDEHDEP='$(LIB2ADDEHDEP)' \
+	LIBUNWIND='$(LIBUNWIND)' \
+	LIBUNWINDDEP='$(LIBUNWINDDEP)' \
+	SHLIBUNWIND_LINK='$(SHLIBUNWIND_LINK)' \
+	SHLIBUNWIND_INSTALL='$(SHLIBUNWIND_INSTALL)' \
+	FPBIT='$(FPBIT)' \
+	FPBIT_FUNCS='$(FPBIT_FUNCS)' \
+	LIB2_DIVMOD_FUNCS='$(LIB2_DIVMOD_FUNCS)' \
+	DPBIT='$(DPBIT)' \
+	DPBIT_FUNCS='$(DPBIT_FUNCS)' \
+	TPBIT='$(TPBIT)' \
+	TPBIT_FUNCS='$(TPBIT_FUNCS)' \
+	MULTILIBS=`$(GCC_FOR_TARGET) --print-multi-lib` \
+	EXTRA_MULTILIB_PARTS='$(EXTRA_MULTILIB_PARTS)' \
+	SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_INSTALL='$(SHLIB_INSTALL)' \
+	SHLIB_EXT='$(SHLIB_EXT)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)' \
+	SHLIB_MKMAP='$(SHLIB_MKMAP)' \
+	SHLIB_MKMAP_OPTS='$(SHLIB_MKMAP_OPTS)' \
+	SHLIB_MAPFILES='$(SHLIB_MAPFILES)' \
+	SHLIB_NM_FLAGS='$(SHLIB_NM_FLAGS)' \
+	MULTILIB_OSDIRNAMES='$(MULTILIB_OSDIRNAMES)' \
+	mkinstalldirs='$(SHELL) $(srcdir)/mkinstalldirs' \
+	  $(SHELL) mklibgcc > tmp-libgcc.mk
+	mv tmp-libgcc.mk libgcc.mk
+
+# All the things that might cause us to want to recompile bits of libgcc.
+LIBGCC_DEPS = $(GCC_PASSES) $(LANGUAGES) stmp-int-hdrs $(STMP_FIXPROTO) \
+	libgcc.mk $(srcdir)/libgcc2.c $(srcdir)/libgcov.c $(TCONFIG_H) \
+	$(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs \
+	tsystem.h $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \
+	$(LIB2ADD_ST) $(LIB2ADD_SH) $(LIB2ADDEH) $(LIB2ADDEHDEP) \
+	$(EXTRA_PARTS) $(srcdir)/config/$(LIB1ASMSRC) \
+	$(srcdir)/gcov-io.h $(srcdir)/gcov-io.c gcov-iov.h
+
+libgcov.a: libgcc.a; @true
+
+libgcc.a: $(LIBGCC_DEPS)
+	$(MAKE) \
+	  CFLAGS="$(CFLAGS) $(WARN_CFLAGS)" \
+	  CONFIG_H="$(TCONFIG_H)" TM_H="$(TM_H)" \
+	  INCLUDES="$(INCLUDES)" \
+	  MAKEOVERRIDES= \
+	  -f libgcc.mk all
+
+# Use the genmultilib shell script to generate the information the gcc
+# driver program needs to select the library directory based on the
+# switches.
+multilib.h: s-mlib; @true
+s-mlib: $(srcdir)/genmultilib Makefile
+	if test @enable_multilib@ = yes \
+	   || test -n "$(MULTILIB_OSDIRNAMES)"; then \
+	  $(SHELL) $(srcdir)/genmultilib \
+	    "$(MULTILIB_OPTIONS)" \
+	    "$(MULTILIB_DIRNAMES)" \
+	    "$(MULTILIB_MATCHES)" \
+	    "$(MULTILIB_EXCEPTIONS)" \
+	    "$(MULTILIB_EXTRA_OPTS)" \
+	    "$(MULTILIB_EXCLUSIONS)" \
+	    "$(MULTILIB_OSDIRNAMES)" \
+	    "@enable_multilib@" \
+	    > tmp-mlib.h; \
+	else \
+	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' no \
+	    > tmp-mlib.h; \
+	fi
+	$(SHELL) $(srcdir)/move-if-change tmp-mlib.h multilib.h
+	$(STAMP) s-mlib
+
+# Build multiple copies of libgcc.a, one for each target switch.
+stmp-multilib: $(LIBGCC_DEPS)
+	$(MAKE) \
+	  CFLAGS="$(CFLAGS) $(WARN_CFLAGS)" \
+	  CONFIG_H="$(CONFIG_H)" \
+	  MAKEOVERRIDES= \
+	  -f libgcc.mk all
+	$(STAMP) stmp-multilib
+
+# Compile two additional files that are linked with every program
+# linked using GCC on systems using COFF or ELF, for the sake of C++
+# constructors.
+$(T)crtbegin.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) \
+	  @inhibit_libc@ -c $(srcdir)/crtstuff.c -DCRT_BEGIN \
+	  -o $(T)crtbegin$(objext)
+
+$(T)crtend.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) \
+	  @inhibit_libc@ -c $(srcdir)/crtstuff.c -DCRT_END \
+	  -o $(T)crtend$(objext)
+
+# These are versions of crtbegin and crtend for shared libraries.
+$(T)crtbeginS.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS_S) \
+	  @inhibit_libc@ -c $(srcdir)/crtstuff.c -DCRT_BEGIN -DCRTSTUFFS_O \
+	  -o $(T)crtbeginS$(objext)
+
+$(T)crtendS.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS_S) \
+	  @inhibit_libc@ -c $(srcdir)/crtstuff.c -DCRT_END -DCRTSTUFFS_O \
+	  -o $(T)crtendS$(objext)
+
+# This is a version of crtbegin for -static links.
+$(T)crtbeginT.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) \
+	  @inhibit_libc@ -c $(srcdir)/crtstuff.c -DCRT_BEGIN -DCRTSTUFFT_O \
+	  -o $(T)crtbeginT$(objext)
+
+# Compile the start modules crt0.o and mcrt0.o that are linked with
+# every program
+crt0.o: s-crt0 ; @true
+mcrt0.o: s-crt0; @true
+
+s-crt0:	$(CRT0_S) $(MCRT0_S) $(GCC_PASSES) $(CONFIG_H)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(CRT0STUFF_T_CFLAGS) \
+	  -o crt0.o -c $(CRT0_S)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(CRT0STUFF_T_CFLAGS) \
+	  -o mcrt0.o -c $(MCRT0_S)
+	$(STAMP) s-crt0
+#
+# Compiling object files from source files.
+
+# Note that dependencies on obstack.h are not written
+# because that file is not part of GCC.
+
+# C language specific files.
+
+c-errors.o: c-errors.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) flags.h $(DIAGNOSTIC_H) $(TM_P_H)
+c-parse.o : c-parse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(GGC_H) intl.h $(C_TREE_H) input.h flags.h toplev.h output.h $(CPPLIB_H) \
+    varray.h gt-c-parse.h
+
+srcextra: gcc.srcextra lang.srcextra
+
+gcc.srcextra: c-parse.y c-parse.c gengtype-lex.c gengtype-yacc.c gengtype-yacc.h
+	-cp -p $^ $(srcdir)
+
+c-parse.c: c-parse.y
+	-$(BISON) $(BISONFLAGS) -o $@ $< 
+
+c-parse.y: c-parse.in
+	echo '/*WARNING: This file is automatically generated!*/' >tmp-c-parse.y
+	sed -e "/^@@ifobjc.*/,/^@@end_ifobjc.*/d" \
+	    -e "/^@@ifc.*/d" -e "/^@@end_ifc.*/d" $< >>tmp-c-parse.y
+	$(SHELL) $(srcdir)/move-if-change tmp-c-parse.y $@
+
+c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \
+		intl.h prefix.h coretypes.h $(TM_H) cppdefault.h
+
+c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) flags.h function.h output.h \
+    $(EXPR_H) debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) \
+    opts.h c-pragma.h gt-c-decl.h cgraph.h $(HASHTAB_H) libfuncs.h except.h \
+    $(LANGHOOKS_DEF_H)
+c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \
+    $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)
+c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) $(C_PRETTY_PRINT_H) $(DIAGNOSTIC_H) \
+    $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-c.h
+stub-objc.o : stub-objc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+    $(GGC_H) $(C_COMMON_H)
+c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(RTL_H) debug.h $(C_TREE_H) $(C_COMMON_H) real.h c-incpath.h cppdefault.h \
+    c-pragma.h input.h intl.h flags.h toplev.h output.h \
+    $(CPPLIB_H) $(EXPR_H) $(TM_P_H)
+c-ppoutput.o : c-ppoutput.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(C_COMMON_H) $(TREE_H) $(CPPLIB_H) cpphash.h $(TM_P_H) c-pragma.h
+c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) $(EXPR_H) $(C_TREE_H) \
+    flags.h toplev.h tree-inline.h $(DIAGNOSTIC_H) $(VARRAY_H) \
+    langhooks.h $(GGC_H) $(TARGET_H) cgraph.h
+c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) flags.h toplev.h
+c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    flags.h toplev.h $(C_COMMON_H) real.h
+c-pragma.o: c-pragma.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+    function.h c-pragma.h toplev.h output.h $(GGC_H) $(TM_P_H) $(C_COMMON_H) gt-c-pragma.h
+graph.o: graph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h flags.h output.h \
+    $(RTL_H) function.h hard-reg-set.h $(BASIC_BLOCK_H) graph.h
+sbitmap.o: sbitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \
+    hard-reg-set.h $(BASIC_BLOCK_H)
+
+COLLECT2_OBJS = collect2.o tlink.o intl.o version.o
+COLLECT2_LIBS = @COLLECT2_LIBS@
+collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)
+# Don't try modifying collect2 (aka ld) in place--it might be linking this.
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o T$@ \
+		$(COLLECT2_OBJS) $(LIBS) $(COLLECT2_LIBS)
+	mv -f T$@ $@
+
+collect2.o : collect2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) gstab.h intl.h \
+	$(OBSTACK_H) $(DEMANGLE_H) collect2.h version.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES)  \
+	-DTARGET_MACHINE=\"$(target_noncanonical)\" \
+	-c $(srcdir)/collect2.c $(OUTPUT_OPTION)
+
+tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(OBSTACK_H) collect2.h intl.h
+
+# A file used by all variants of C.
+
+c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(OBSTACK_H) $(C_COMMON_H) flags.h toplev.h output.h c-pragma.h intl.h \
+	$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def \
+	$(DIAGNOSTIC_H) gt-c-common.h langhooks.h varray.h $(RTL_H) \
+	$(TARGET_H) $(C_TREE_H)
+c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \
+	$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) real.h
+
+c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+        c-pragma.h flags.h toplev.h langhooks.h tree-inline.h $(DIAGNOSTIC_H) \
+	intl.h debug.h $(C_COMMON_H) opts.h options.h $(PARAMS_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+		$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@
+
+c-cppbuiltin.o : c-cppbuiltin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(TREE_H) $(C_COMMON_H) c-pragma.h flags.h toplev.h langhooks.h \
+	output.h except.h real.h $(TM_P_H)
+
+# A file used by all variants of C and some other languages.
+
+attribs.o : attribs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) flags.h \
+	toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) $(EXPR_H) $(TM_P_H) \
+	builtin-types.def $(TARGET_H) langhooks.h
+
+c-format.o : c-format.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) langhooks.h \
+	$(C_COMMON_H) flags.h toplev.h intl.h $(DIAGNOSTIC_H)
+
+c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(C_TREE_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \
+	$(EXPR_H) $(PREDICT_H) tree-inline.h
+
+c-dump.o : c-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(C_TREE_H) tree-dump.h
+
+c-pch.o : c-pch.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(CPPLIB_H) $(TREE_H) \
+	$(C_COMMON_H) output.h toplev.h c-pragma.h $(GGC_H) debug.h \
+	langhooks.h flags.h hosthooks.h version.h $(TARGET_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	  -DHOST_MACHINE=\"$(host)\" -DTARGET_MACHINE=\"$(target)\" \
+	  $< $(OUTPUT_OPTION)
+
+# Language-independent files.
+
+DRIVER_DEFINES = \
+  -DSTANDARD_STARTFILE_PREFIX=\"$(unlibsubdir)/\" \
+  -DSTANDARD_EXEC_PREFIX=\"$(libdir)/gcc/\" \
+  -DSTANDARD_LIBEXEC_PREFIX=\"$(libexecdir)/gcc/\" \
+  -DDEFAULT_TARGET_VERSION=\"$(version)\" \
+  -DDEFAULT_TARGET_MACHINE=\"$(target_noncanonical)\" \
+  -DSTANDARD_BINDIR_PREFIX=\"$(bindir)/\" \
+  -DTOOLDIR_BASE_PREFIX=\"$(unlibsubdir)/../\" \
+  @TARGET_SYSTEM_ROOT_DEFINE@ \
+  $(VALGRIND_DRIVER_DEFINES) \
+  `test "X$${SHLIB_LINK}" = "X" || test "@enable_shared@" != "yes" || echo "-DENABLE_SHARED_LIBGCC"` \
+  `test "X$${SHLIB_MULTILIB}" = "X" || echo "-DNO_SHARED_LIBGCC_MULTILIB"`
+
+gcc.o: gcc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h multilib.h \
+    Makefile $(lang_specs_files) specs.h prefix.h $(GCC_H)
+	(SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+  $(DRIVER_DEFINES) \
+  -c $(srcdir)/gcc.c $(OUTPUT_OPTION))
+
+gccspec.o: gccspec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H)
+	(SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+  $(DRIVER_DEFINES) \
+  -c $(srcdir)/gccspec.c $(OUTPUT_OPTION))
+
+cppspec.o: cppspec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H)
+
+tree-check.h: s-check ; @true
+s-check : gencheck$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./gencheck$(build_exeext) > tmp-check.h
+	$(SHELL) $(srcdir)/move-if-change tmp-check.h tree-check.h
+	$(STAMP) s-check
+
+gencheck$(build_exeext) : gencheck.o $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 gencheck.o $(BUILD_LIBS)
+
+gencheck.o : gencheck.c gencheck.h tree.def $(BCONFIG_H) $(SYSTEM_H) \
+	coretypes.h $(GTM_H) $(lang_tree_files)
+
+gencheck.h : s-gencheck ; @true
+s-gencheck : Makefile
+	ltf="$(lang_tree_files)"; for f in $$ltf; do \
+	    echo "#include \"$$f\""; \
+	done | sed 's|$(srcdir)/||' > tmp-gencheck.h
+	$(SHELL) $(srcdir)/move-if-change tmp-gencheck.h gencheck.h
+	$(STAMP) s-gencheck
+
+specs.h : s-specs ; @true
+s-specs : Makefile
+	lsf="$(lang_specs_files)"; for f in $$lsf; do \
+	    echo "#include \"$$f\""; \
+	done | sed 's|$(srcdir)/||' > tmp-specs.h
+	$(SHELL) $(srcdir)/move-if-change tmp-specs.h specs.h
+	$(STAMP) s-specs
+
+options.c: $(lang_opt_files) $(srcdir)/opts.sh options.h intl.h
+
+options.h: $(lang_opt_files) $(srcdir)/opts.sh Makefile
+	AWK=$(AWK) $(SHELL) $(srcdir)/opts.sh \
+               '$(SHELL) $(srcdir)/move-if-change' \
+               options.c options.h $(lang_opt_files)
+
+dumpvers: dumpvers.c
+
+version.o: version.c version.h
+
+gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h \
+	$(HASHTAB_H) $(TREE_H) $(RTL_H) function.h insn-config.h $(EXPR_H) $(OPTABS_H) \
+	libfuncs.h debug.h $(GGC_H) bitmap.h $(BASIC_BLOCK_H) hard-reg-set.h \
+	cselib.h insn-addr.h
+
+ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \
+	$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h
+
+ggc-simple.o: ggc-simple.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+	flags.h $(GGC_H) varray.h $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)
+
+ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+	flags.h toplev.h $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)
+
+ggc-zone.o: ggc-zone.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+	flags.h toplev.h $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)
+
+stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(TREE_H) $(GGC_H) gt-stringpool.h
+
+ggc-none.o: ggc-none.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(GGC_H)
+	$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) Makefile prefix.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	-DPREFIX=\"$(prefix)\" \
+	  -c $(srcdir)/prefix.c $(OUTPUT_OPTION)
+
+convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) flags.h \
+   convert.h toplev.h langhooks.h
+
+langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) toplev.h \
+   tree-inline.h $(RTL_H) insn-config.h $(INTEGRATE_H) langhooks.h \
+   $(LANGHOOKS_DEF_H) flags.h $(GGC_H) gt-langhooks.h diagnostic.h
+tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) flags.h function.h \
+   toplev.h $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \
+   real.h gt-tree.h
+tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(C_TREE_H) flags.h langhooks.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \
+   $(EXPR_H) $(SPLAY_TREE_H) tree-dump.h
+tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(RTL_H) $(EXPR_H) flags.h $(PARAMS_H) input.h insn-config.h \
+   $(INTEGRATE_H) $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \
+   langhooks.h $(C_COMMON_H) tree-inline.h cgraph.h intl.h
+tree-optimize.o : tree-optimize.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) toplev.h langhooks.h cgraph.h $(TIMEVAR_H) function.h $(GGC_H)
+
+print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(GGC_H) langhooks.h real.h
+stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   flags.h function.h $(EXPR_H) $(RTL_H) toplev.h $(GGC_H) $(TM_P_H) $(TARGET_H) \
+   langhooks.h
+fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   flags.h real.h toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) $(GGC_H) $(TM_P_H) langhooks.h
+diagnostic.o : diagnostic.c $(DIAGNOSTIC_H) real.h \
+   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(TM_P_H) flags.h $(GGC_H) \
+   input.h toplev.h intl.h langhooks.h $(LANGHOOKS_DEF_H)
+opts.o : opts.c opts.h options.h toplev.h $(CONFIG_H) $(SYSTEM_H) \
+	coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(RTL_H) \
+	output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h
+targhooks.o : targhooks.c targhooks.h $(CONFIG_H) $(SYSTEM_H) \
+	coretypes.h $(TREE_H) $(TM_H) $(RTL_H) $(TM_P_H) function.h \
+	output.h toplev.h
+
+toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \
+   function.h flags.h xcoffout.h input.h $(INSN_ATTR_H) output.h $(DIAGNOSTIC_H) \
+   debug.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h \
+   dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \
+   graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \
+   $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \
+   langhooks.h insn-flags.h cfglayout.h real.h cfgloop.h \
+   hosthooks.h $(LANGHOOKS_DEF_H) cgraph.h $(COVERAGE_H) alloc-pool.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	  -DTARGET_NAME=\"$(target_noncanonical)\" \
+	  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)
+main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h
+
+host-default.o : host-default.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+	hosthooks.h hosthooks-def.h
+
+rtl-error.o: rtl-error.c $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(INSN_ATTR_H) \
+   insn-config.h input.h toplev.h intl.h $(DIAGNOSTIC_H) $(CONFIG_H)
+
+rtl.o : rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(RTL_H) real.h \
+  $(GGC_H) errors.h
+	$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) real.h $(TM_P_H)
+rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \
+   $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) real.h flags.h \
+   $(BASIC_BLOCK_H)
+
+errors.o : errors.c $(CONFIG_H) $(SYSTEM_H) errors.h
+	$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \
+   flags.h function.h $(EXPR_H) hard-reg-set.h $(REGS_H) \
+   output.h c-pragma.h toplev.h xcoffout.h debug.h $(GGC_H) $(TM_P_H) \
+   $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h real.h
+function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h function.h $(EXPR_H) $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h \
+   insn-config.h $(RECOG_H) output.h toplev.h except.h $(HASHTAB_H) $(GGC_H) \
+   $(TM_P_H) langhooks.h gt-function.h $(TARGET_H)
+stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \
+   function.h insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \
+   $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H) \
+   langhooks.h $(PREDICT_H) gt-stmt.h $(OPTABS_H) $(TARGET_H)
+except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) flags.h except.h function.h $(EXPR_H) libfuncs.h $(INTEGRATE_H) \
+   langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \
+   dwarf2asm.h dwarf2out.h toplev.h $(HASHTAB_H) intl.h $(GGC_H) \
+   gt-except.h cgraph.h
+expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \
+   function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) libfuncs.h $(INSN_ATTR_H) insn-config.h \
+   $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \
+   except.h reload.h $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h $(TARGET_H)
+dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h function.h $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \
+   langhooks.h $(GGC_H) gt-dojump.h
+builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H)\
+   flags.h $(TARGET_H) function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) insn-config.h \
+   $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \
+   except.h $(TM_P_H) $(PREDICT_H) libfuncs.h real.h langhooks.h
+calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \
+   $(EXPR_H) $(OPTABS_H) langhooks.h $(TARGET_H) \
+   libfuncs.h $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H) cgraph.h except.h
+expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) real.h \
+   toplev.h $(TM_P_H) langhooks.h
+explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \
+   toplev.h function.h $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h
+optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h $(RECOG_H) reload.h \
+   toplev.h $(GGC_H) real.h $(TM_P_H) except.h gt-optabs.h $(BASIC_BLOCK_H) \
+   $(TARGET_H)
+dbxout.o : dbxout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \
+   flags.h $(REGS_H) debug.h $(TM_P_H) $(TARGET_H) function.h langhooks.h \
+   insn-config.h reload.h gstab.h xcoffout.h output.h dbxout.h toplev.h \
+   $(GGC_H) gt-dbxout.h
+debug.o : debug.c debug.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)
+sdbout.o : sdbout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \
+   flags.h function.h $(EXPR_H) output.h hard-reg-set.h $(REGS_H) real.h \
+   insn-config.h xcoffout.h c-pragma.h $(GGC_H) $(TARGET_H) \
+   sdbout.h toplev.h $(TM_P_H) except.h debug.h langhooks.h gt-sdbout.h
+dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) dwarf2.h debug.h flags.h insn-config.h reload.h output.h $(DIAGNOSTIC_H) real.h \
+   hard-reg-set.h $(REGS_H) $(EXPR_H) libfuncs.h toplev.h dwarf2out.h varray.h \
+   $(GGC_H) except.h dwarf2asm.h $(TM_P_H) langhooks.h $(HASHTAB_H) \
+   gt-dwarf2out.h $(TARGET_H) cgraph.h
+dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) flags.h $(RTL_H) \
+   $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) gt-dwarf2asm.h
+vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) flags.h output.h vmsdbg.h debug.h langhooks.h function.h $(TARGET_H)
+xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \
+   xcoffout.h flags.h toplev.h output.h dbxout.h $(GGC_H) $(TARGET_H)
+emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h function.h $(REGS_H) insn-config.h $(RECOG_H) real.h $(GGC_H) \
+   $(EXPR_H) $(OBSTACK_H) hard-reg-set.h bitmap.h toplev.h \
+   $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h gt-emit-rtl.h
+real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) toplev.h $(TM_P_H)
+integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h debug.h $(INTEGRATE_H) insn-config.h $(EXPR_H) real.h $(REGS_H) \
+   intl.h function.h output.h $(RECOG_H) except.h toplev.h $(LOOP_H) \
+   $(PARAMS_H) $(TM_P_H) $(TARGET_H) langhooks.h gt-integrate.h
+jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \
+   hard-reg-set.h $(REGS_H) insn-config.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \
+   toplev.h $(INSN_ATTR_H) $(TM_P_H) reload.h $(PREDICT_H) $(TIMEVAR_H) \
+   $(DIAGNOSTIC_H)
+
+simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(REGS_H) hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \
+   output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H) $(TREE_H) $(TARGET_H)
+cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   langhooks.h toplev.h flags.h $(GGC_H)  $(TARGET_H) cgraph.h gt-cgraph.h \
+   output.h intl.h
+cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   langhooks.h tree-inline.h toplev.h flags.h $(GGC_H)  $(TARGET_H) cgraph.h intl.h \
+   function.h
+coverage.o : coverage.c gcov-io.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) $(TREE_H) flags.h output.h $(REGS_H) $(EXPR_H) function.h \
+   toplev.h $(GGC_H) $(TARGET_H) langhooks.h $(COVERAGE_H) libfuncs.h \
+   gt-coverage.h $(HASHTAB_H)
+cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \
+   output.h function.h cselib.h $(GGC_H) $(TM_P_H) gt-cselib.h $(PARAMS_H)
+cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \
+   output.h function.h $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \
+   except.h $(TARGET_H) $(PARAMS_H)
+web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   hard-reg-set.h flags.h $(BASIC_BLOCK_H) function.h output.h toplev.h df.h
+gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   hard-reg-set.h flags.h real.h insn-config.h $(GGC_H) $(RECOG_H) $(EXPR_H) \
+   $(BASIC_BLOCK_H) function.h output.h toplev.h $(TM_P_H) $(PARAMS_H) \
+   except.h gt-gcse.h $(TREE_H) cselib.h
+sibcall.o : sibcall.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   function.h hard-reg-set.h flags.h insn-config.h $(RECOG_H) $(BASIC_BLOCK_H)
+resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(BASIC_BLOCK_H) $(REGS_H) flags.h output.h resource.h function.h toplev.h \
+   $(INSN_ATTR_H) except.h $(PARAMS_H) $(TM_P_H)
+lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   hard-reg-set.h flags.h real.h insn-config.h $(INSN_ATTR_H) $(RECOG_H) $(EXPR_H) \
+   $(BASIC_BLOCK_H) $(TM_P_H) df.h function.h
+df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \
+   $(BASIC_BLOCK_H) df.h $(FIBHEAP_H)
+conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H) \
+   $(HASHTAB_H) $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)
+profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) flags.h output.h $(REGS_H) $(EXPR_H) function.h \
+   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_H) value-prof.h
+value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h flags.h \
+   $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H)
+loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h $(LOOP_H) \
+   insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \
+   real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h cfgloop.h \
+   toplev.h varray.h except.h cselib.h $(OPTABS_H) $(TM_P_H) $(GGC_H)
+doloop.o : doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \
+   $(LOOP_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) toplev.h \
+   cfgloop.h
+unroll.o : unroll.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) insn-config.h \
+   function.h $(INTEGRATE_H) $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) $(LOOP_H) toplev.h \
+   hard-reg-set.h varray.h $(BASIC_BLOCK_H) $(TM_P_H) $(PREDICT_H) $(PARAMS_H) \
+   cfgloop.h
+alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h $(HASHTAB_H)
+flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \
+   $(RECOG_H) function.h except.h $(EXPR_H) $(GGC_H) $(TM_P_H)
+cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h insn-config.h \
+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \
+   function.h except.h $(GGC_H) $(TM_P_H) alloc-pool.h
+cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   $(BASIC_BLOCK_H) cfglayout.h
+cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \
+   insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \
+   function.h except.h $(GGC_H) $(TM_P_H) insn-config.h $(EXPR_H)
+cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h insn-config.h $(RECOG_H) $(GGC_H) $(TM_P_H)
+cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \
+   insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \
+   function.h except.h $(GGC_H)
+cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TIMEVAR_H) $(BASIC_BLOCK_H) hard-reg-set.h output.h flags.h \
+   $(RECOG_H) toplev.h $(GGC_H) insn-config.h cselib.h $(TARGET_H) $(TM_P_H) \
+   $(PARAMS_H)
+cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h flags.h
+cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h $(EXPR_H) coretypes.h $(TM_H)
+cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h output.h coretypes.h $(TM_H)
+loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h \
+   coretypes.h $(TM_H)
+loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h $(PARAMS_H) \
+   output.h $(EXPR_H) coretypes.h $(TM_H)
+loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h $(PARAMS_H) \
+   output.h $(EXPR_H) coretypes.h $(TM_H)
+dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h
+et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) et-forest.h alloc-pool.h
+combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \
+   function.h insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \
+   $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h $(TM_P_H) \
+   $(TREE_H) $(TARGET_H) $(PARAMS_H)
+regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   hard-reg-set.h flags.h $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(RECOG_H) reload.h \
+   real.h toplev.h function.h output.h $(GGC_H) $(TM_P_H) $(EXPR_H) $(TIMEVAR_H)
+local-alloc.o : local-alloc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   flags.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \
+   output.h function.h $(INSN_ATTR_H) toplev.h  except.h $(TM_P_H)
+bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(GTM_H) $(RTL_H) flags.h \
+   $(BASIC_BLOCK_H) $(REGS_H) $(GGC_H)
+	$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \
+   reload.h function.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h output.h \
+   toplev.h $(TM_P_H)
+varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h $(GGC_H) errors.h
+ra.o : ra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TM_P_H) insn-config.h \
+   $(RECOG_H) $(INTEGRATE_H) function.h $(REGS_H) $(OBSTACK_H) hard-reg-set.h \
+   $(BASIC_BLOCK_H) df.h $(EXPR_H) output.h toplev.h flags.h reload.h ra.h
+ra-build.o : ra-build.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TM_P_H) \
+   insn-config.h $(RECOG_H) function.h $(REGS_H) hard-reg-set.h \
+   $(BASIC_BLOCK_H) df.h output.h $(GGC_H) ra.h gt-ra-build.h reload.h
+ra-colorize.o : ra-colorize.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+    $(TM_P_H) function.h $(REGS_H) hard-reg-set.h $(BASIC_BLOCK_H) df.h output.h ra.h
+ra-debug.o : ra-debug.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   insn-config.h $(RECOG_H) function.h hard-reg-set.h $(BASIC_BLOCK_H) df.h output.h \
+   ra.h $(TM_P_H)
+ra-rewrite.o : ra-rewrite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TM_P_H) function.h $(REGS_H) hard-reg-set.h $(BASIC_BLOCK_H) df.h $(EXPR_H) \
+   output.h except.h ra.h reload.h insn-config.h
+reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h output.h \
+   $(EXPR_H) $(OPTABS_H) reload.h $(RECOG_H) hard-reg-set.h insn-config.h \
+   $(REGS_H) function.h real.h toplev.h $(TM_P_H) $(PARAMS_H)
+reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) real.h flags.h \
+   $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) hard-reg-set.h insn-config.h \
+   $(BASIC_BLOCK_H) $(RECOG_H) output.h function.h toplev.h $(TM_P_H) \
+   except.h $(TREE_H)
+postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) real.h flags.h \
+   $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) hard-reg-set.h insn-config.h \
+   $(BASIC_BLOCK_H) $(RECOG_H) output.h function.h toplev.h cselib.h $(TM_P_H) \
+   except.h $(TREE_H)
+caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   flags.h $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) function.h \
+   $(RECOG_H) reload.h $(EXPR_H) toplev.h $(TM_P_H)
+bt-load.o : bt-load.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(BASIC_BLOCK_H) $(RTL_H) hard-reg-set.h $(REGS_H) $(OBSTACK_H) $(TM_P_H) \
+   $(FIBHEAP_H) output.h $(TARGET_H) $(EXPR_H) flags.h $(INSN_ATTR_H)
+reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) conditions.h \
+   hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(INSN_ATTR_H) except.h \
+   $(RECOG_H) function.h flags.h output.h $(EXPR_H) toplev.h $(PARAMS_H) $(TM_P_H)
+alias.o : alias.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \
+   hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) toplev.h output.h $(EXPR_H) \
+   $(GGC_H) function.h cselib.h $(TREE_H) $(TM_P_H) langhooks.h $(TARGET_H) \
+   gt-alias.h $(TIMEVAR_H) cgraph.h
+regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) insn-config.h \
+   $(RECOG_H) output.h $(REGS_H) hard-reg-set.h flags.h function.h \
+   $(EXPR_H) $(BASIC_BLOCK_H) toplev.h $(TM_P_H) except.h reload.h
+haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   sched-int.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \
+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)
+sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   sched-int.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \
+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h cselib.h $(PARAMS_H) $(TM_P_H)
+sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   sched-int.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \
+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)
+sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   sched-int.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \
+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(PARAMS_H)
+sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   sched-int.h hard-reg-set.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(REGS_H) $(TM_P_H) \
+   $(TARGET_H) real.h
+final.o : final.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h intl.h $(REGS_H) $(RECOG_H) conditions.h insn-config.h $(INSN_ATTR_H) \
+   function.h real.h output.h hard-reg-set.h except.h debug.h xcoffout.h \
+   toplev.h reload.h dwarf2out.h $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) \
+   $(EXPR_H)
+recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) function.h \
+   $(BASIC_BLOCK_H) $(REGS_H) $(RECOG_H) $(EXPR_H) hard-reg-set.h flags.h insn-config.h \
+   $(INSN_ATTR_H) real.h toplev.h output.h reload.h $(TM_P_H)
+reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   $(RECOG_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h toplev.h reload.h \
+   varray.h function.h $(TM_P_H) $(GGC_H) gt-reg-stack.h
+sreal.o: sreal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) sreal.h
+predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   flags.h insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \
+   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) sreal.h \
+   $(PARAMS_H) $(TARGET_H) cfgloop.h $(COVERAGE_H)
+lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(RTL_H) $(GGC_H)
+bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(BASIC_BLOCK_H) flags.h timevar.h output.h cfglayout.h $(FIBHEAP_H) \
+   $(TARGET_H)
+tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h flags.h timevar.h \
+   $(PARAMS_H) $(COVERAGE_H)
+cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TREE_H) insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h \
+   function.h cfglayout.h cfgloop.h $(TARGET_H) gt-cfglayout.h $(GGC_H)
+timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TIMEVAR_H) flags.h \
+   intl.h toplev.h
+regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h $(RECOG_H) function.h \
+   resource.h $(OBSTACK_H) flags.h $(TM_P_H)
+ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(REGS_H) toplev.h flags.h insn-config.h function.h $(RECOG_H) $(TARGET_H) \
+   $(BASIC_BLOCK_H) $(EXPR_H) output.h except.h $(TM_P_H) real.h $(OPTABS_H) \
+   cfgloop.h
+params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(PARAMS_H) toplev.h
+hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)
+pretty-print.o: $(CONFIG_H) $(SYSTEM_H) pretty-print.c $(PRETTY_PRINT_H)
+
+$(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) $(GGC_H) \
+   $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \
+   output.h $(INSN_ATTR_H) $(SYSTEM_H) toplev.h $(TARGET_H) libfuncs.h \
+   $(TARGET_DEF_H) function.h sched-int.h $(TM_P_H) $(EXPR_H) $(OPTABS_H) \
+   langhooks.h
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+		$(out_file) $(OUTPUT_OPTION)
+
+# Build auxiliary files that support ecoff format.
+mips-tfile: mips-tfile.o version.o $(LIBDEPS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ mips-tfile.o version.o $(LIBS)
+
+mips-tfile.o : mips-tfile.c $(CONFIG_H) $(RTL_H) $(SYSTEM_H) coretypes.h $(TM_H) version.h
+
+mips-tdump: mips-tdump.o version.o $(LIBDEPS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ mips-tdump.o version.o $(LIBS)
+
+mips-tdump.o : mips-tdump.c $(CONFIG_H) $(RTL_H) $(SYSTEM_H) coretypes.h $(TM_H) version.h
+
+# FIXME: writing proper dependencies for this is a *LOT* of work.
+libbackend.o : $(OBJS-common:.o=.c) $(out_file) \
+  insn-config.h insn-flags.h insn-codes.h insn-constants.h \
+  insn-attr.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	  -DTARGET_NAME=\"$(target_noncanonical)\" \
+	  -DLOCALEDIR=\"$(localedir)\" \
+	  -c $(filter %.c,$^) -o $@
+
+#
+# Generate header and source files from the machine description,
+# and compile them.
+
+.PRECIOUS: insn-config.h insn-flags.h insn-codes.h insn-constants.h \
+  insn-emit.c insn-recog.c insn-extract.c insn-output.c insn-peep.c \
+  insn-attr.h insn-attrtab.c
+
+# The following pair of rules has this effect:
+# genconfig is run only if the md has changed since genconfig was last run;
+# but the file insn-config.h is touched only when its contents actually change.
+
+# Each of the other insn-* files is handled by a similar pair of rules.
+
+# This causes an anomaly in the results of make -n
+# because insn-* is older than s-*
+# and thus make -n thinks that insn-* will be updated
+# and force recompilation of things that depend on it.
+# We use move-if-change precisely to avoid such recompilation.
+# But there is no way to teach make -n that it will be avoided.
+
+# Each of the insn-*.[ch] rules has a semicolon at the end,
+# for otherwise the system Make on SunOS 4.1 never tries
+# to recompile insn-*.o.  To avoid problems and extra noise from
+# versions of make which don't like empty commands (nothing after the
+# trailing `;'), we call true for each.
+
+insn-config.h: s-config ; @true
+s-config : $(md_file) genconfig$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genconfig$(build_exeext) $(md_file) > tmp-config.h
+	$(SHELL) $(srcdir)/move-if-change tmp-config.h insn-config.h
+	$(STAMP) s-config
+
+insn-conditions.c: s-conditions ; @true
+s-conditions : $(md_file) genconditions$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genconditions$(build_exeext) $(md_file) > tmp-conditions.c
+	$(SHELL) $(srcdir)/move-if-change tmp-conditions.c insn-conditions.c
+	$(STAMP) s-conditions
+
+insn-conditions.o : insn-conditions.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(GTM_H) $(RTL_H) $(TM_P_H) $(REGS_H) function.h $(RECOG_H) real.h output.h \
+  flags.h hard-reg-set.h resource.h toplev.h reload.h gensupport.h \
+  insn-constants.h
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) insn-conditions.c
+
+dummy-conditions.o : dummy-conditions.c $(BCONFIG_H) $(SYSTEM_H) \
+  coretypes.h $(GTM_H) gensupport.h
+
+insn-flags.h: s-flags ; @true
+s-flags : $(md_file) genflags$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genflags$(build_exeext) $(md_file) > tmp-flags.h
+	$(SHELL) $(srcdir)/move-if-change tmp-flags.h insn-flags.h
+	$(STAMP) s-flags
+
+insn-codes.h: s-codes ; @true
+s-codes : $(md_file) gencodes$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./gencodes$(build_exeext) $(md_file) > tmp-codes.h
+	$(SHELL) $(srcdir)/move-if-change tmp-codes.h insn-codes.h
+	$(STAMP) s-codes
+
+insn-constants.h: s-constants ; @true
+s-constants : $(md_file) genconstants$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genconstants$(build_exeext) $(md_file) > tmp-constants.h
+	$(SHELL) $(srcdir)/move-if-change tmp-constants.h insn-constants.h
+	$(STAMP) s-constants
+
+insn-emit.o : insn-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) $(EXPR_H) real.h output.h insn-config.h $(OPTABS_H) reload.h \
+  $(RECOG_H) toplev.h function.h flags.h hard-reg-set.h resource.h $(TM_P_H)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-emit.c \
+	  $(OUTPUT_OPTION)
+
+insn-emit.c: s-emit ; @true
+s-emit : $(md_file) genemit$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genemit$(build_exeext) $(md_file) > tmp-emit.c
+	$(SHELL) $(srcdir)/move-if-change tmp-emit.c insn-emit.c
+	$(STAMP) s-emit
+
+insn-recog.o : insn-recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) insn-config.h $(RECOG_H) real.h output.h flags.h  function.h \
+  hard-reg-set.h resource.h $(TM_P_H) toplev.h reload.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-recog.c \
+	  $(OUTPUT_OPTION)
+
+insn-recog.c: s-recog ; @true
+s-recog : $(md_file) genrecog$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genrecog$(build_exeext) $(md_file) > tmp-recog.c
+	$(SHELL) $(srcdir)/move-if-change tmp-recog.c insn-recog.c
+	$(STAMP) s-recog
+
+insn-opinit.o : insn-opinit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) insn-config.h flags.h $(RECOG_H) $(EXPR_H) $(OPTABS_H) reload.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-opinit.c \
+	  $(OUTPUT_OPTION)
+
+insn-opinit.c: s-opinit ; @true
+s-opinit : $(md_file) genopinit$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genopinit$(build_exeext) $(md_file) > tmp-opinit.c
+	$(SHELL) $(srcdir)/move-if-change tmp-opinit.c insn-opinit.c
+	$(STAMP) s-opinit
+
+insn-extract.o : insn-extract.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) toplev.h insn-config.h $(RECOG_H)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-extract.c \
+	  $(OUTPUT_OPTION)
+
+insn-extract.c: s-extract ; @true
+s-extract : $(md_file) genextract$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genextract$(build_exeext) $(md_file) > tmp-extract.c
+	$(SHELL) $(srcdir)/move-if-change tmp-extract.c insn-extract.c
+	$(STAMP) s-extract
+
+insn-peep.o : insn-peep.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) $(REGS_H) output.h real.h insn-config.h $(RECOG_H) except.h \
+  function.h $(TM_P_H)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-peep.c \
+	  $(OUTPUT_OPTION)
+
+insn-peep.c: s-peep ; @true
+s-peep : $(md_file) genpeep$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genpeep$(build_exeext) $(md_file) > tmp-peep.c
+	$(SHELL) $(srcdir)/move-if-change tmp-peep.c insn-peep.c
+	$(STAMP) s-peep
+
+insn-attrtab.o : insn-attrtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) $(REGS_H) real.h output.h $(INSN_ATTR_H) insn-config.h toplev.h \
+  $(RECOG_H) $(TM_P_H) flags.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-attrtab.c \
+	  $(OUTPUT_OPTION)
+
+insn-attr.h: s-attr ; @true
+s-attr : $(md_file) genattr$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genattr$(build_exeext) $(md_file) > tmp-attr.h
+	$(SHELL) $(srcdir)/move-if-change tmp-attr.h insn-attr.h
+	$(STAMP) s-attr
+
+insn-attrtab.c: s-attrtab ; @true
+s-attrtab : $(md_file) genattrtab$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genattrtab$(build_exeext) $(md_file) > tmp-attrtab.c
+	$(SHELL) $(srcdir)/move-if-change tmp-attrtab.c insn-attrtab.c
+	$(STAMP) s-attrtab
+
+insn-output.o : insn-output.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(RTL_H) $(GGC_H) $(REGS_H) real.h conditions.h hard-reg-set.h \
+  insn-config.h $(INSN_ATTR_H) $(EXPR_H) output.h $(RECOG_H) function.h \
+  toplev.h flags.h insn-codes.h $(TM_P_H) $(TARGET_H)
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-output.c \
+	  $(OUTPUT_OPTION)
+
+insn-output.c: s-output ; @true
+s-output : $(md_file) genoutput$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genoutput$(build_exeext) $(md_file) > tmp-output.c
+	$(SHELL) $(srcdir)/move-if-change tmp-output.c insn-output.c
+	$(STAMP) s-output
+
+genrtl.o : genrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+  $(GGC_H)
+genrtl.c genrtl.h : s-genrtl
+	@true	# force gnu make to recheck modification times.
+
+s-genrtl: gengenrtl$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./gengenrtl$(build_exeext) -h > tmp-genrtl.h
+	$(SHELL) $(srcdir)/move-if-change tmp-genrtl.h genrtl.h
+	$(RUN_GEN) ./gengenrtl$(build_exeext) > tmp-genrtl.c
+	$(SHELL) $(srcdir)/move-if-change tmp-genrtl.c genrtl.c
+	$(STAMP) s-genrtl
+
+insn-modes.o : insn-modes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	       $(MACHMODE_H) real.h
+min-insn-modes.c insn-modes.c insn-modes.h : s-modes ; @true
+
+s-modes: genmodes$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genmodes$(build_exeext) -h > tmp-modes.h
+	$(SHELL) $(srcdir)/move-if-change tmp-modes.h insn-modes.h
+	$(RUN_GEN) ./genmodes$(build_exeext) -m > tmp-min-modes.c
+	$(SHELL) $(srcdir)/move-if-change tmp-min-modes.c min-insn-modes.c
+	$(RUN_GEN) ./genmodes$(build_exeext) > tmp-modes.c
+	$(SHELL) $(srcdir)/move-if-change tmp-modes.c insn-modes.c
+	$(STAMP) s-modes
+
+tm-preds.h: s-preds; @true
+
+s-preds: genpreds$(build_exeext) $(srcdir)/move-if-change
+	$(RUN_GEN) ./genpreds$(build_exeext) > tmp-preds.h
+	$(SHELL) $(srcdir)/move-if-change tmp-preds.h tm-preds.h
+	$(STAMP) s-preds
+
+GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h $(srcdir)/cpplib.h \
+  $(host_xm_file_list) $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) \
+  $(srcdir)/bitmap.h $(srcdir)/coverage.c $(srcdir)/function.h  $(srcdir)/rtl.h \
+  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/libfuncs.h $(srcdir)/hashtable.h \
+  $(srcdir)/real.h $(srcdir)/varray.h $(srcdir)/insn-addr.h \
+  $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \
+  $(srcdir)/c-common.h $(srcdir)/c-tree.h \
+  $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \
+  $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \
+  $(srcdir)/dojump.c \
+  $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \
+  $(srcdir)/fold-const.c $(srcdir)/function.c \
+  $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \
+  $(srcdir)/profile.c $(srcdir)/ra-build.c $(srcdir)/regclass.c \
+  $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/langhooks.c \
+  $(srcdir)/sdbout.c $(srcdir)/stmt.c $(srcdir)/stor-layout.c \
+  $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \
+  $(out_file) \
+  @all_gtfiles@
+
+GTFILES_FILES_LANGS = @all_gtfiles_files_langs@
+GTFILES_FILES_FILES = @all_gtfiles_files_files@
+GTFILES_LANG_DIR_NAMES = @subdirs@
+GTFILES_SRCDIR = @srcdir@
+
+gt-cgraph.h gt-coverage.h gtype-desc.h gtype-desc.c gt-except.h \
+gt-function.h gt-integrate.h gt-stmt.h gt-tree.h gt-varasm.h \
+gt-emit-rtl.h gt-explow.h gt-stor-layout.h gt-regclass.h \
+gt-lists.h gt-alias.h gt-cselib.h gt-fold-const.h gt-gcse.h \
+gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \
+gt-dwarf2out.h gt-ra-build.h gt-reg-stack.h gt-dwarf2asm.h \
+gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parse.h \
+gt-c-pragma.h gtype-c.h gt-input.h gt-cfglayout.h \
+gt-stringpool.h gt-langhooks.h : s-gtype ; @true
+
+gtyp-gen.h: Makefile
+	echo "/* This file is machine generated.  Do not edit.  */" > tmp-gtyp.h
+	echo "static const char *const srcdir = "  >> tmp-gtyp.h
+	echo "\"$(GTFILES_SRCDIR)\"" >> tmp-gtyp.h
+	echo ";" >> tmp-gtyp.h
+	echo "static const char *const lang_files[] = {" >> tmp-gtyp.h
+	ll="$(GTFILES_FILES_FILES)"; \
+	for f in $$ll; do \
+	echo "\"$$f\", "; done >> tmp-gtyp.h
+	echo "NULL};" >> tmp-gtyp.h
+	echo "static const char *const langs_for_lang_files[] = {" >> tmp-gtyp.h
+	ff="$(GTFILES_FILES_LANGS)"; \
+	for f in $$ff; do \
+	echo "\"$$f\", " ; done  >> tmp-gtyp.h
+	echo "NULL};" >> tmp-gtyp.h
+	echo "static const char *const all_files[] = {" >> tmp-gtyp.h
+	gf="$(GTFILES)"; \
+	for f in $$gf; do \
+	echo "\"$$f\", "; done >> tmp-gtyp.h
+	echo " NULL};" >> tmp-gtyp.h
+	echo "static const char *const lang_dir_names[] = { \"c\", " >> tmp-gtyp.h
+	gf="$(GTFILES_LANG_DIR_NAMES)"; \
+	for l in $$gf; do \
+	echo "\"$$l\", "; done >> tmp-gtyp.h
+	echo "NULL};" >> tmp-gtyp.h
+	$(SHELL) $(srcdir)/move-if-change tmp-gtyp.h gtyp-gen.h 
+
+s-gtype: gengtype$(build_exeext) $(GTFILES)
+	$(RUN_GEN) ./gengtype
+	$(STAMP) s-gtype
+
+#
+# Compile the programs that generate insn-* from the machine description.
+# They are compiled with $(CC_FOR_BUILD), and associated libraries,
+# since they need to run on this machine
+# even if GCC is being compiled to run on some other machine.
+
+# $(CONFIG_H) is omitted from the deps of the gen*.o
+# because these programs don't really depend on anything
+# about the target machine.  They do depend on config.h itself,
+# since that describes the host machine.
+
+# The names of programs that run on the "build" machine.
+genprognames=genconfig genflags gencodes genemit genopinit genrecog \
+	     genextract genpeep genattr genoutput
+
+# The names of the executable files for those programs.
+genprogs=$(genprognames:%=%$(build_exeext))
+
+# Object files used in those programs.
+genobjs=$(genprognames:%=%.o) read-rtl.o gensupport.o genattrtab.o \
+        genautomata.o gengenrtl.o genmodes.o genpreds.o gengtype.o \
+	genconstants.o gen-protos.o scan.o fix-header.o scan-decls.o \
+	gencheck.o dummy-conditions.o genconditions.o
+
+$(genprogs): %$(build_exeext): %.o  $(BUILD_RTL) $(BUILD_SUPPORT) \
+			       $(BUILD_PRINT) $(BUILD_ERRORS) \
+	                       $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+		$< $(BUILD_RTL) $(BUILD_SUPPORT) $(BUILD_PRINT) \
+		$(BUILD_ERRORS) $(BUILD_LIBS)
+
+$(genobjs): %.o : %.c
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+read-rtl.o: read-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(RTL_H) \
+  $(OBSTACK_H) $(HASHTAB_H)
+
+gensupport.o: gensupport.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(RTL_H) \
+  $(OBSTACK_H) errors.h $(HASHTAB_H) gensupport.h
+
+genconfig.o : genconfig.c $(RTL_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+genflags.o : genflags.c $(RTL_H) $(OBSTACK_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+gencodes.o : gencodes.c $(RTL_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+genconstants$(build_exeext) : genconstants.o $(BUILD_RTL) $(BUILD_EARLY_SUPPORT) \
+  $(BUILD_ERRORS) $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 genconstants.o $(BUILD_EARLY_SUPPORT) $(BUILD_RTL) \
+	    $(BUILD_ERRORS) $(BUILD_LIBS)
+
+genconstants.o : genconstants.c $(RTL_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \
+  errors.h
+
+genemit.o : genemit.c $(RTL_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \
+  errors.h gensupport.h
+
+genopinit.o : genopinit.c $(RTL_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+genrecog.o : genrecog.c $(RTL_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+genextract.o : genextract.c $(RTL_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) insn-config.h errors.h gensupport.h
+
+genpeep.o : genpeep.c $(RTL_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \
+  errors.h gensupport.h
+
+genattr.o : genattr.c $(RTL_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h \
+  gensupport.h
+
+genattrtab$(build_exeext) : genattrtab.o genautomata.o \
+  $(BUILD_RTL) $(BUILD_SUPPORT) $(BUILD_PRINT) $(BUILD_ERRORS) $(BUILD_VARRAY) \
+  $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 genattrtab.o genautomata.o \
+	 $(BUILD_RTL) $(BUILD_SUPPORT) $(BUILD_PRINT) $(BUILD_ERRORS) \
+	 $(BUILD_VARRAY) $(BUILD_LIBS) -lm
+
+genattrtab.o : genattrtab.c $(RTL_H) $(OBSTACK_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H) gensupport.h genattrtab.h
+
+genautomata.o : genautomata.c $(RTL_H) $(OBSTACK_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h varray.h genattrtab.h $(HASHTAB_H)
+
+genoutput.o : genoutput.c $(RTL_H) $(BCONFIG_H) \
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+
+gengenrtl$(build_exeext) : gengenrtl.o $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 gengenrtl.o $(BUILD_LIBS)
+
+gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def
+
+genmodes$(build_exeext) : genmodes.o $(BUILD_ERRORS) $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 genmodes.o $(BUILD_ERRORS) $(BUILD_LIBS)
+
+genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h $(HASHTAB_H) \
+	     machmode.def $(extra_modes_file)
+
+genpreds$(build_exeext) : genpreds.o $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 genpreds.o $(BUILD_LIBS)
+
+genpreds.o : genpreds.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H)
+
+gengtype$(build_exeext) : gengtype.o gengtype-lex.o gengtype-yacc.o \
+  $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 gengtype.o gengtype-lex.o gengtype-yacc.o $(BUILD_LIBS)
+
+gengtype.o : gengtype.c gengtype.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \
+  real.h $(RTL_BASE_H) gtyp-gen.h
+
+gengtype-lex.o : gengtype-lex.c gengtype.h gengtype-yacc.h \
+  $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) \
+	 $< $(OUTPUT_OPTION)
+
+gengtype-yacc.o : gengtype-yacc.c gengtype.h $(BCONFIG_H) $(SYSTEM_H) \
+  coretypes.h $(GTM_H)
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) \
+	 $< $(OUTPUT_OPTION)
+
+gengtype-lex.c : gengtype-lex.l
+	-$(FLEX) $(FLEXFLAGS) -o$@ $<
+
+gengtype-yacc.c gengtype-yacc.h: gengtype-yacc.y
+	-$(BISON) $(BISONFLAGS) -d -o gengtype-yacc.c $<
+
+genconditions$(build_exeext) : genconditions.o $(BUILD_EARLY_SUPPORT) \
+  $(BUILD_RTL) $(BUILD_ERRORS) $(BUILD_LIBDEPS)
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	 genconditions.o $(BUILD_EARLY_SUPPORT) $(BUILD_RTL) \
+	    $(BUILD_ERRORS) $(BUILD_LIBS)
+
+genconditions.o : genconditions.c $(RTL_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(GTM_H) errors.h
+
+#
+# Compile the libraries to be used by gen*.
+# If we are not cross-building, gen* use the same .o's that cc1 will use,
+# and BUILD_PREFIX_1 is `loser-', just to ensure these rules don't conflict
+# with the rules for rtl.o, etc.
+$(BUILD_PREFIX_1)rtl.o: $(srcdir)/rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) $(RTL_H) \
+  real.h $(GGC_H) errors.h
+	rm -f $(BUILD_PREFIX)rtl.c
+	sed -e 's/config[.]h/bconfig.h/' $(srcdir)/rtl.c > $(BUILD_PREFIX)rtl.c
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)rtl.c $(OUTPUT_OPTION)
+
+print-rtl1.o: $(srcdir)/print-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(GTM_H) $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H)
+	rm -f print-rtl1.c
+	sed -e 's/config[.]h/bconfig.h/' $(srcdir)/print-rtl.c > print-rtl1.c
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) print-rtl1.c $(OUTPUT_OPTION)
+
+$(BUILD_PREFIX_1)bitmap.o: $(srcdir)/bitmap.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) \
+  $(RTL_H) flags.h $(BASIC_BLOCK_H) $(REGS_H) $(GGC_H)
+	rm -f $(BUILD_PREFIX)bitmap.c
+	sed -e 's/config[.]h/bconfig.h/' $(srcdir)/bitmap.c > $(BUILD_PREFIX)bitmap.c
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)bitmap.c $(OUTPUT_OPTION)
+
+$(BUILD_PREFIX_1)errors.o: errors.c $(BCONFIG_H) $(SYSTEM_H) errors.h
+	rm -f $(BUILD_PREFIX)errors.c
+	sed -e 's/config[.]h/bconfig.h/' $(srcdir)/errors.c > $(BUILD_PREFIX)errors.c
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)errors.c $(OUTPUT_OPTION)
+
+$(BUILD_PREFIX_1)varray.o: varray.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) varray.h \
+  $(RTL_H) $(GGC_H) $(TREE_H) bitmap.h errors.h
+	rm -f $(BUILD_PREFIX)varray.c
+	sed -e 's/config[.]h/bconfig.h/' $(srcdir)/varray.c > \
+		$(BUILD_PREFIX)varray.c
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) \
+		$(BUILD_PREFIX)varray.c $(OUTPUT_OPTION)
+
+$(BUILD_PREFIX_1)ggc-none.o: ggc-none.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) $(GGC_H)
+	rm -f $(BUILD_PREFIX)ggc-none.c
+	sed -e 's/config[.]h/bconfig.h/' $(srcdir)/ggc-none.c > $(BUILD_PREFIX)ggc-none.c
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)ggc-none.c $(OUTPUT_OPTION)
+
+min-insn-modes.o: min-insn-modes.c $(BCONFIG_H) $(SYSTEM_H) $(MACHMODE_H)
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) \
+	    min-insn-modes.c $(OUTPUT_OPTION)
+
+#
+# Remake internationalization support.
+intl.o: intl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h Makefile
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	  -DLOCALEDIR=\"$(localedir)\" \
+	  -c $(srcdir)/intl.c $(OUTPUT_OPTION)
+
+#
+# Remake cpp and protoize.
+
+PREPROCESSOR_DEFINES = \
+  -DGCC_INCLUDE_DIR=\"$(libsubdir)/include\" \
+  -DGPLUSPLUS_INCLUDE_DIR=\"$(gcc_gxx_include_dir)\" \
+  -DGPLUSPLUS_TOOL_INCLUDE_DIR=\"$(gcc_gxx_include_dir)/$(target_noncanonical)\" \
+  -DGPLUSPLUS_BACKWARD_INCLUDE_DIR=\"$(gcc_gxx_include_dir)/backward\" \
+  -DLOCAL_INCLUDE_DIR=\"$(local_includedir)\" \
+  -DCROSS_INCLUDE_DIR=\"$(CROSS_SYSTEM_HEADER_DIR)\" \
+  -DTOOL_INCLUDE_DIR=\"$(gcc_tooldir)/include\" \
+  @TARGET_SYSTEM_ROOT_DEFINE@
+
+LIBCPP_OBJS =	cpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpptrad.o \
+		cpphash.o cpperror.o cppinit.o cppcharset.o \
+		hashtable.o line-map.o mkdeps.o cpppch.o
+
+LIBCPP_DEPS =	$(CPPLIB_H) cpphash.h line-map.h hashtable.h intl.h \
+		$(OBSTACK_H) $(CONFIG_H) $(SYSTEM_H)
+
+# Most of the other archives built/used by this makefile are for
+# targets.  This one is strictly for the host.
+libcpp.a: $(LIBCPP_OBJS)
+	-rm -rf libcpp.a
+	$(AR) $(AR_FLAGS) libcpp.a $(LIBCPP_OBJS)
+	-$(RANLIB) libcpp.a
+
+cppcharset.o: cppcharset.c $(LIBCPP_DEPS) cppucnid.h
+cpperror.o: cpperror.c $(LIBCPP_DEPS)
+cppexp.o:   cppexp.c   $(LIBCPP_DEPS)
+cpplex.o:   cpplex.c   $(LIBCPP_DEPS)
+cppmacro.o: cppmacro.c $(LIBCPP_DEPS)
+cpplib.o:   cpplib.c   $(LIBCPP_DEPS)
+cpphash.o:  cpphash.c  $(LIBCPP_DEPS)
+cpptrad.o:  cpptrad.c  $(LIBCPP_DEPS)
+cppfiles.o: cppfiles.c $(LIBCPP_DEPS) $(HASHTAB_H) mkdeps.h
+cppinit.o:  cppinit.c  $(LIBCPP_DEPS) mkdeps.h
+cpppch.o:   cpppch.c   $(LIBCPP_DEPS) mkdeps.h
+
+cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	cppdefault.h Makefile
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	  $(PREPROCESSOR_DEFINES) \
+	  -c $(srcdir)/cppdefault.c $(OUTPUT_OPTION)
+
+mkdeps.o: mkdeps.c $(CONFIG_H) $(SYSTEM_H) mkdeps.h
+hashtable.o: hashtable.c hashtable.h $(CONFIG_H) $(SYSTEM_H) $(OBSTACK_H)
+line-map.o: line-map.c line-map.h intl.h $(CONFIG_H) $(SYSTEM_H)
+
+# Note for the stamp targets, we run the program `true' instead of
+# having an empty command (nothing following the semicolon).
+
+proto: config.status protoize$(exeext) unprotoize$(exeext) SYSCALLS.c.X
+
+PROTO_OBJS = intl.o version.o cppdefault.o
+
+protoize$(exeext): protoize.o $(PROTO_OBJS) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ protoize.o $(PROTO_OBJS) $(LIBS)
+
+unprotoize$(exeext): unprotoize.o $(PROTO_OBJS) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ unprotoize.o $(PROTO_OBJS) $(LIBS)
+
+protoize.o: protoize.c $(srcdir)/../include/getopt.h $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) Makefile version.h
+	(SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	  $(DRIVER_DEFINES) \
+	  $(srcdir)/protoize.c $(OUTPUT_OPTION))
+
+unprotoize.o: protoize.c $(srcdir)/../include/getopt.h \
+   $(CONFIG_H) $(SYSTEM_H) Makefile version.h
+	(SHLIB_LINK='$(SHLIB_LINK)' \
+	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
+	$(CC) -c -DUNPROTOIZE $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	  $(DRIVER_DEFINES) \
+	  $(srcdir)/protoize.c $(OUTPUT_OPTION))
+
+# This info describes the target machine, so compile with GCC just built.
+SYSCALLS.c.X: $(srcdir)/sys-types.h $(srcdir)/sys-protos.h $(GCC_PASSES) \
+   stmp-int-hdrs
+	-rm -f SYSCALLS.c tmp-SYSCALLS.s
+	sed -e s/TARGET_GETGROUPS_T/$(TARGET_GETGROUPS_T)/ \
+	  $(srcdir)/sys-types.h $(srcdir)/sys-protos.h > SYSCALLS.c
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	  -aux-info $@ -S -o tmp-SYSCALLS.s SYSCALLS.c
+	-rm -f SYSCALLS.c tmp-SYSCALLS.s
+
+
+test-protoize-simple: ./protoize ./unprotoize $(GCC_PASSES)
+	-rm -f tmp-proto.[cso]
+	cp $(srcdir)/protoize.c tmp-proto.c
+	chmod u+w tmp-proto.c
+	./protoize -N -B ./ -x getopt.h -c "-B./ -Wall -Wwrite-strings \
+	  $(GCC_CFLAGS) $(INCLUDES) \
+	  -DGCC_INCLUDE_DIR=0 \
+	  -DGPLUSPLUS_INCLUDE_DIR=0 \
+	  -DCROSS_INCLUDE_DIR=0 \
+	  -DTOOL_INCLUDE_DIR=0 \
+	  -DSTANDARD_EXEC_PREFIX=0 \
+	  -DDEFAULT_TARGET_MACHINE=0 \
+	  -DDEFAULT_TARGET_VERSION=0" tmp-proto.c
+	@echo '**********' Expect 400 lines of differences.
+	-diff $(srcdir)/protoize.c tmp-proto.c > tmp-proto.diff
+	-wc -l tmp-proto.diff
+	./unprotoize -N -x getopt.h -c "-B./ -Wall -Wwrite-strings \
+	  $(GCC_CFLAGS) $(INCLUDES) \
+	  -DGCC_INCLUDE_DIR=0 \
+	  -DGPLUSPLUS_INCLUDE_DIR=0 \
+	  -DCROSS_INCLUDE_DIR=0 \
+	  -DTOOL_INCLUDE_DIR=0 \
+	  -DSTANDARD_EXEC_PREFIX=0 \
+	  -DDEFAULT_TARGET_MACHINE=0 \
+	  -DDEFAULT_TARGET_VERSION=0" tmp-proto.c
+	@echo Expect zero differences.
+	diff $(srcdir)/protoize.c tmp-proto.c | cat
+	-rm -f tmp-proto.[cs] tmp-proto$(objext)
+
+# gcov-iov.c is run on the build machine to generate gcov-iov.h from version.c
+gcov-iov.o: gcov-iov.c version.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) coretypes.h $(TM_H)
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(srcdir)/gcov-iov.c $(OUTPUT_OPTION)
+gcov-iov$(build_exeext): gcov-iov.o
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) gcov-iov.o -o $@
+gcov-iov.h: s-iov
+s-iov: gcov-iov$(build_exeext) $(srcdir)/move-if-change
+	./gcov-iov$(build_exeext) > tmp-gcov-iov.h
+	$(SHELL) $(srcdir)/move-if-change tmp-gcov-iov.h gcov-iov.h
+	$(STAMP) s-iov
+
+gcov.o: gcov.c gcov-io.h gcov-io.c gcov-iov.h intl.h $(SYSTEM_H) coretypes.h $(TM_H) $(CONFIG_H)
+gcov-dump.o: gcov-dump.c gcov-io.h gcov-io.c gcov-iov.h $(SYSTEM_H) coretypes.h $(TM_H) $(CONFIG_H)
+
+# Only one of 'gcov' or 'gcov.exe' is actually built, depending
+# upon whether $(exeext) is empty or not.
+GCOV_OBJS = gcov.o intl.o version.o
+gcov$(exeext): $(GCOV_OBJS) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) $(GCOV_OBJS) $(LIBS) -o $@
+GCOV_DUMP_OBJS = gcov-dump.o version.o
+gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) $(GCOV_DUMP_OBJS) $(LIBS) -o $@
+#
+# Build the include directory.  The stamp files are stmp-* rather than
+# s-* so that mostlyclean does not force the include directory to
+# be rebuilt.
+
+# Build the include directory
+stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) xlimits.h
+# Copy in the headers provided with gcc.
+# The sed command gets just the last file name component;
+# this is necessary because VPATH could add a dirname.
+# Using basename would be simpler, but some systems don't have it.
+# The touch command is here to workaround an AIX/Linux NFS bug.
+	-if [ -d include ] ; then true; else mkdir include; chmod a+rx include; fi
+	for file in .. $(USER_H); do \
+	  if [ X$$file != X.. ]; then \
+	    realfile=`echo $$file | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
+	    $(STAMP) include/$$realfile; \
+	    rm -f include/$$realfile; \
+	    cp $$file include; \
+	    chmod a+r include/$$realfile; \
+	  fi; \
+	done
+	rm -f include/limits.h
+	cp xlimits.h include/limits.h
+	chmod a+r include/limits.h
+# Install the README
+	rm -f include/README
+	cp $(srcdir)/README-fixinc include/README
+	chmod a+r include/README
+	$(STAMP) $@
+
+# fixinc.sh depends on this, not on specs directly.
+# The idea is to make sure specs gets built, but not rerun fixinc.sh
+# after each stage just because specs' mtime has changed.
+specs.ready: specs
+	-if [ -f specs.ready ] ; then \
+		true; \
+	else \
+		$(STAMP) specs.ready; \
+	fi
+
+# Until someone fixes this recursive make nightmare (please note where
+# BUILD_CFLAGS and WARN_CFLAGS are first expanded below versus which
+# later make invocation has the fine-grain -warn markings for fixinc):
+fixinc.sh-warn = -Wno-error
+
+FIXINCSRCDIR=$(srcdir)/fixinc
+fixinc.sh: $(FIXINCSRCDIR)/mkfixinc.sh $(FIXINCSRCDIR)/fixincl.c \
+	$(FIXINCSRCDIR)/procopen.c $(FIXINCSRCDIR)/server.c \
+	$(FIXINCSRCDIR)/server.h $(FIXINCSRCDIR)/inclhack.def specs.ready
+	(MAKE="$(MAKE)"; srcdir=`cd $(srcdir)/fixinc && ${PWD_COMMAND}` ; \
+	CC="$(CC_FOR_BUILD)"; CFLAGS="$(BUILD_CFLAGS)"; LDFLAGS="$(BUILD_LDFLAGS)"; \
+	WARN_CFLAGS="$(WARN_CFLAGS)"; LIBERTY=`${PWD_COMMAND}`/"$(BUILD_LIBIBERTY)"; \
+	export MAKE srcdir CC CFLAGS LDFLAGS WARN_CFLAGS LIBERTY; \
+	cd ./fixinc && \
+	$(SHELL) $${srcdir}/mkfixinc.sh $(build) $(target))
+
+.PHONY: install-gcc-tooldir
+install-gcc-tooldir:
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(gcc_tooldir)
+
+# Build fixed copies of system files.
+stmp-fixinc: fixinc.sh gsyslimits.h
+	@if test ! -d ${SYSTEM_HEADER_DIR}; then \
+	  echo The directory that should contain system headers does not exist: >&2 ; \
+	  echo "  ${SYSTEM_HEADER_DIR}" >&2 ; \
+	  if test "x${SYSTEM_HEADER_DIR}" = "x${gcc_tooldir}/sys-include"; \
+	  then sleep 1; else exit 1; fi; \
+	fi
+	rm -rf include; mkdir include
+	-chmod a+rx include
+	(TARGET_MACHINE='$(target)'; srcdir=`cd $(srcdir); ${PWD_COMMAND}`; \
+	SHELL='$(SHELL)' ;\
+	export TARGET_MACHINE srcdir SHELL ; \
+	$(SHELL) ./fixinc.sh `${PWD_COMMAND}`/include $(SYSTEM_HEADER_DIR) $(OTHER_FIXINCLUDES_DIRS); \
+	rm -f include/syslimits.h; \
+	if [ -f include/limits.h ]; then \
+	  mv include/limits.h include/syslimits.h; \
+	else \
+	  cp $(srcdir)/gsyslimits.h include/syslimits.h; \
+	fi; \
+	chmod a+r include/syslimits.h)
+	$(STAMP) stmp-fixinc
+
+# Files related to the fixproto script.
+# gen-protos and fix-header are compiled with CC_FOR_BUILD, but they are only
+# used in native and host-x-target builds, so it's safe to link them with
+# libiberty.a.
+
+deduced.h: $(GCC_PASSES) $(srcdir)/scan-types.sh stmp-int-hdrs
+	if [ -d "$(SYSTEM_HEADER_DIR)" ]; \
+	then \
+	  CC="$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) -I. -I$(srcdir) -isystem include -isystem ${SYSTEM_HEADER_DIR}"; \
+	  export CC; \
+	  $(SHELL) $(srcdir)/scan-types.sh "$(srcdir)" >tmp-deduced.h; \
+	  mv tmp-deduced.h deduced.h; \
+	else \
+	  $(STAMP) deduced.h; \
+	fi
+
+GEN_PROTOS_OBJS = gen-protos.o scan.o
+gen-protos$(build_exeext): $(GEN_PROTOS_OBJS)
+	${CC_FOR_BUILD} $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	  $(GEN_PROTOS_OBJS) $(BUILD_LIBS)
+
+gen-protos.o: gen-protos.c scan.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H)
+
+scan.o: scan.c scan.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H)
+
+xsys-protos.h: $(GCC_PASSES) $(srcdir)/sys-protos.h deduced.h gen-protos$(build_exeext) Makefile
+	sed -e s/TARGET_GETGROUPS_T/$(TARGET_GETGROUPS_T)/ \
+	  deduced.h $(srcdir)/sys-protos.h > tmp-fixtmp.c
+	mv tmp-fixtmp.c fixtmp.c
+	$(GCC_FOR_TARGET) fixtmp.c -w -U__SIZE_TYPE__ -U__PTRDIFF_TYPE__ -U__WCHAR_TYPE__ -E \
+	  | sed -e 's/	/ /g' -e 's/ *(/ (/g' -e 's/ [ ]*/ /g' -e 's/( )/()/' \
+	  | $(RUN_GEN) ./gen-protos >xsys-protos.hT
+	mv xsys-protos.hT xsys-protos.h
+	rm -rf fixtmp.c
+
+# This is nominally a 'build' program, but it's run only when host==build,
+# so we can (indeed, must) use $(LIBDEPS) and $(LIBS).
+fix-header$(build_exeext): fix-header.o scan-decls.o scan.o xsys-protos.h \
+           c-incpath.o cppdefault.o prefix.o $(LIBDEPS) libcpp.a
+	$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ fix-header.o \
+	c-incpath.o cppdefault.o scan-decls.o prefix.o scan.o libcpp.a $(LIBS)
+
+fix-header.o: fix-header.c $(OBSTACK_H) scan.h \
+	xsys-protos.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(CPPLIB_H)
+
+scan-decls.o: scan-decls.c scan.h $(CPPLIB_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H)
+
+# stmp-fixproto depends on this, not on fix-header directly.
+# The idea is to make sure fix-header gets built,
+# but not rerun fixproto after each stage
+# just because fix-header's mtime has changed.
+fixhdr.ready: fix-header$(build_exeext)
+	-if [ -f fixhdr.ready ] ; then \
+		true; \
+	else \
+		$(STAMP) fixhdr.ready; \
+	fi
+
+# stmp-int-headers is to make sure fixincludes has already finished.
+# The if statement is so that we don't run fixproto a second time
+# if it has already been run on the files in `include'.
+stmp-fixproto: fixhdr.ready fixproto stmp-int-hdrs
+	if [ -f include/fixed ] ; then true; \
+	else \
+	  : This line works around a 'make' bug in BSDI 1.1.; \
+	  FIXPROTO_DEFINES="$(FIXPROTO_DEFINES)"; export FIXPROTO_DEFINES; \
+	  mkinstalldirs="$(SHELL) $(srcdir)/mkinstalldirs"; \
+	    export mkinstalldirs; \
+	  if [ -d "$(SYSTEM_HEADER_DIR)" ]; then \
+	    $(SHELL) ${srcdir}/fixproto include include $(SYSTEM_HEADER_DIR); \
+	    if [ $$? -eq 0 ] ; then true ; else exit 1 ; fi ; \
+	  else true; fi; \
+	  $(STAMP) include/fixed; \
+	fi
+	$(STAMP) stmp-fixproto
+#
+# Remake the info files.
+
+doc: $(BUILD_INFO) $(GENERATED_MANPAGES) gccbug
+
+INFOFILES = doc/cpp.info doc/gcc.info doc/gccint.info \
+            doc/gccinstall.info doc/cppinternals.info
+
+info: $(INFOFILES) lang.info @GENINSRC@ srcinfo lang.srcinfo
+
+srcinfo: $(INFOFILES)
+	-cp -p $^ $(srcdir)/doc
+
+TEXI_CPP_FILES = cpp.texi fdl.texi cppenv.texi cppopts.texi
+
+TEXI_GCC_FILES = gcc.texi gcc-common.texi frontends.texi standards.texi \
+	 invoke.texi extend.texi md.texi objc.texi gcov.texi trouble.texi \
+	 bugreport.texi service.texi contribute.texi compat.texi funding.texi \
+	 gnu.texi gpl.texi fdl.texi contrib.texi cppenv.texi cppopts.texi
+
+TEXI_GCCINT_FILES = gccint.texi gcc-common.texi contribute.texi makefile.texi \
+	 configterms.texi portability.texi interface.texi passes.texi \
+	 c-tree.texi rtl.texi md.texi tm.texi hostconfig.texi fragments.texi \
+	 configfiles.texi collect2.texi headerdirs.texi funding.texi gnu.texi \
+	 gpl.texi fdl.texi contrib.texi languages.texi sourcebuild.texi \
+	 gty.texi libgcc.texi
+
+TEXI_GCCINSTALL_FILES = install.texi install-old.texi fdl.texi
+
+TEXI_CPPINT_FILES = cppinternals.texi
+
+# The *.1, *.7, *.info, and *.dvi files are being generated from implicit 
+# patterns.   To use them, put each of the specific target with with their 
+# specific dependencies but no build commands.
+
+doc/cpp.info: $(TEXI_CPP_FILES)
+doc/gcc.info: $(TEXI_GCC_FILES)
+doc/gccint.info: $(TEXI_GCCINT_FILES)
+doc/cppinternals.info: $(TEXI_CPPINT_FILES)
+
+doc/%.info: %.texi
+	if [ x$(BUILD_INFO) = xinfo ]; then \
+		$(MAKEINFO) $(MAKEINFOFLAGS) -I $(docdir) \
+			-I $(docdir)/include -o $@ $<; \
+	fi
+
+# Duplicate entry to handle renaming of gccinstall.info
+doc/gccinstall.info: $(TEXI_GCCINSTALL_FILES)
+	if [ x$(BUILD_INFO) = xinfo ]; then \
+		$(MAKEINFO) $(MAKEINFOFLAGS) -I $(docdir) \
+			-I $(docdir)/include -o $@ $<; \
+	fi
+
+doc/cpp.dvi: $(TEXI_CPP_FILES)
+doc/gcc.dvi: $(TEXI_GCC_FILES)
+doc/gccint.dvi: $(TEXI_GCCINT_FILES)
+doc/cppinternals.dvi: $(TEXI_CPPINT_FILES)
+
+dvi:: doc/gcc.dvi doc/gccint.dvi doc/gccinstall.dvi doc/cpp.dvi \
+      doc/cppinternals.dvi
+
+doc/%.dvi: %.texi
+	$(TEXI2DVI) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<
+
+# Duplicate entry to handle renaming of gccinstall.dvi
+doc/gccinstall.dvi: $(TEXI_GCCINSTALL_FILES)
+	$(TEXI2DVI) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<
+
+MANFILES = doc/gcov.1 doc/cpp.1 doc/gcc.1 doc/gfdl.7 doc/gpl.7 doc/fsf-funding.7
+
+generated-manpages: man 
+
+man: $(MANFILES) lang.man @GENINSRC@ srcman lang.srcman
+
+srcman: $(MANFILES)
+	-cp -p $^ $(srcdir)/doc
+
+doc/%.1: %.pod
+	$(STAMP) $@
+	-($(POD2MAN) --section=1 $< > $(@).T$$$$ && \
+		mv -f $(@).T$$$$ $@) || \
+		(rm -f $(@).T$$$$ && exit 1)
+
+doc/%.7: %.pod
+	$(STAMP) $@
+	-($(POD2MAN) --section=7 $< > $(@).T$$$$ && \
+		mv -f $(@).T$$$$ $@) || \
+		(rm -f $(@).T$$$$ && exit 1)
+
+%.pod: %.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+
+.INTERMEDIATE: cpp.pod gcc.pod gfdl.pod fsf-funding.pod
+cpp.pod: cpp.texi cppenv.texi cppopts.texi
+
+# These next rules exist because the output name is not the same as
+# the input name, so our implict %.pod rule will not work.
+
+gcc.pod: invoke.texi cppenv.texi cppopts.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+gfdl.pod: fdl.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+fsf-funding.pod: funding.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+
+#
+# Deletion of files made during compilation.
+# There are four levels of this:
+#   `mostlyclean', `clean', `distclean' and `maintainer-clean'.
+# `mostlyclean' is useful while working on a particular type of machine.
+# It deletes most, but not all, of the files made by compilation.
+# It does not delete libgcc.a or its parts, so it won't have to be recompiled.
+# `clean' deletes everything made by running `make all'.
+# `distclean' also deletes the files made by config.
+# `maintainer-clean' also deletes everything that could be regenerated
+# automatically, except for `configure'.
+# We remove as much from the language subdirectories as we can
+# (less duplicated code).
+
+mostlyclean: lang.mostlyclean
+	-rm -f $(STAGESTUFF)
+	-rm -f *$(coverageexts)
+	-rm -rf libgcc
+# Delete the temporary source copies for cross compilation.
+	-rm -f $(BUILD_PREFIX_1)rtl.c $(BUILD_PREFIX_1)print-rtl.c
+	-rm -f $(BUILD_PREFIX_1)bitmap.c $(BUILD_PREFIX_1)errors.c
+	-rm -f $(BUILD_PREFIX_1)ggc-none.c print-rtl1.c
+# Delete the temp files made in the course of building libgcc.a.
+	-rm -f xlimits.h
+# Delete other built files.
+	-rm -f xsys-protos.hT
+	-rm -f specs.h gencheck.h options.c options.h
+# Delete the stamp and temporary files.
+	-rm -f s-* tmp-* stamp-* stmp-*
+	-rm -f */stamp-* */tmp-*
+# Delete debugging dump files.
+	-rm -f *.[0-9][0-9].* */*.[0-9][0-9].*
+# Delete some files made during installation.
+	-rm -f specs $(SPECS) SYSCALLS.c.X SYSCALLS.c
+	-rm -f collect collect2 mips-tfile mips-tdump
+# Delete files generated for fixproto
+	-rm -rf fix-header$(build_exeext) xsys-protos.h deduced.h tmp-deduced.h \
+	  gen-protos$(build_exeext) fixproto.list fixtmp.* fixhdr.ready
+# Delete files generated for fixincl
+	-rm -rf fixincl fixinc.sh specs.ready
+	(cd fixinc && $(MAKE) clean)
+# Delete unwanted output files from TeX.
+	-rm -f *.toc *.log *.vr *.fn *.cp *.tp *.ky *.pg
+	-rm -f */*.toc */*.log */*.vr */*.fn */*.cp */*.tp */*.ky */*.pg
+# Delete sorted indices we don't actually use.
+	-rm -f gcc.vrs gcc.kys gcc.tps gcc.pgs gcc.fns
+# Delete core dumps.
+	-rm -f core */core
+# Delete file generated for gengtype.c
+	-rm -f gtyp-gen.h
+# Delete files generated by gengtype.c
+	-rm -f gtype-*
+	-rm -f gt-*
+
+# Delete all files made by compilation
+# that don't exist in the distribution.
+clean: mostlyclean lang.clean
+	-rm -f libgcc.a libgcc_eh.a libgcov.a
+	-rm -f libgcc_s*
+	-rm -f libunwind*
+	-rm -f config.h tconfig.h bconfig.h tm_p.h tm.h
+	-rm -f cs-*
+	-rm -rf libgcc
+	-rm -f doc/*.dvi
+# Delete the include directory.
+	-rm -rf include
+# Delete files used by the "multilib" facility (including libgcc subdirs).
+	-rm -f multilib.h tmpmultilib*
+	-if [ "x$(MULTILIB_DIRNAMES)" != x ] ; then \
+	  rm -rf $(MULTILIB_DIRNAMES); \
+	else if [ "x$(MULTILIB_OPTIONS)" != x ] ; then \
+	  rm -rf `echo $(MULTILIB_OPTIONS) | sed -e 's/\// /g'`; \
+	fi ; fi
+	-rm -fr stage1 stage2 stage3 stage4 stageprofile stagefeedback
+# Delete stamps of bootstrap stages
+	-rm -f stage?_*
+	-rm -f clean?_*
+	-rm -f stage_last
+
+# Delete all files that users would normally create
+# while building and installing GCC.
+distclean: clean lang.distclean
+	-rm -f auto-host.h auto-build.h
+	-rm -f cstamp-h
+	-rm -f config.status config.run config.cache config.bak
+	-rm -f Make-lang Make-hooks Make-host Make-target
+	-rm -f Makefile *.oaux
+	-rm -f gthr-default.h
+	-rm -f */stage1 */stage2 */stage3 */stage4 */include */stageprofile */stagefeedback
+	-rm -f c-parse.y c-parse.c c-parse.output TAGS */TAGS
+	-rm -f *.asm
+	-rm -f site.exp site.bak testsuite/site.exp testsuite/site.bak
+	-rm -f testsuite/*.log testsuite/*.sum
+	-cd testsuite && rm -f x *.x *.x? *.exe *.rpo *.o *.s *.S *.c
+	-cd testsuite && rm -f *.out *.gcov *$(coverageexts)
+	-rm -rf ${QMTEST_DIR} stamp-qmtest
+	-rm -f cxxmain.c
+	-rm -f mklibgcc mkheaders gccbug .gdbinit configargs.h
+	-rm -f gcov.pod
+	-rm -f fixinc/Makefile
+# Delete po/*.gmo only if we are not building in the source directory.
+	-if [ ! -f po/exgettext ]; then rm -f po/*.gmo; fi
+	-rmdir ada cp f java objc fixinc intl po testsuite 2>/dev/null
+
+# Get rid of every file that's generated from some other file, except for `configure'.
+# Most of these files ARE PRESENT in the GCC distribution.
+maintainer-clean:
+	@echo 'This command is intended for maintainers to use; it'
+	@echo 'deletes files that may need special tools to rebuild.'
+	$(MAKE) lang.maintainer-clean distclean
+	-rm -f $(srcdir)/c-parse.y $(srcdir)/c-parse.c
+	-rm -f cpp.??s cpp.*aux
+	-rm -f gcc.??s gcc.*aux
+	-rm -f $(docdir)/*.info $(docdir)/*.1 $(docdir)/*.7 $(docdir)/*.dvi
+#
+# Entry points `install' and `uninstall'.
+# Also use `install-collect2' to install collect2 when the config files don't.
+
+# Copy the compiler files into directories where they will be run.
+# Install the driver last so that the window when things are
+# broken is small.
+install: install-common $(INSTALL_HEADERS) $(INSTALL_LIBGCC) \
+    install-cpp install-man install-info install-@POSUB@ \
+    lang.install-normal install-driver
+
+# Handle cpp installation.
+install-cpp: cpp$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-$(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-if [ x$(cpp_install_dir) != x ]; then \
+	  rm -f $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	else true; fi
+
+# Create the installation directories.
+# $(libdir)/gcc/include isn't currently searched by cpp.
+installdirs:
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(libsubdir)
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(libexecsubdir)
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(bindir)
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(includedir)
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(infodir)
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(slibdir)
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(man1dir)
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(man7dir)
+
+# Install the compiler executables built during cross compilation.
+install-common: native $(EXTRA_PARTS) lang.install-common installdirs
+	for file in $(COMPILERS); do \
+	  if [ -f $$file ] ; then \
+	    rm -f $(DESTDIR)$(libexecsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libexecsubdir)/$$file; \
+	  else true; \
+	  fi; \
+	done
+	for file in $(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2) ..; do \
+	  if [ x"$$file" != x.. ]; then \
+	    rm -f $(DESTDIR)$(libexecsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libexecsubdir)/$$file; \
+	  else true; fi; \
+	done
+	for file in $(EXTRA_PARTS) ..; do \
+	  if [ x"$$file" != x.. ]; then \
+	    rm -f $(DESTDIR)$(libsubdir)/$$file; \
+	    $(INSTALL_DATA) $$file $(DESTDIR)$(libsubdir)/$$file; \
+	    chmod a-x $(DESTDIR)$(libsubdir)/$$file; \
+	  else true; fi; \
+	done
+# Don't mess with specs if it doesn't exist yet.
+	-if [ -f specs ] ; then \
+	  rm -f $(DESTDIR)$(libsubdir)/specs; \
+	  $(INSTALL_DATA) $(SPECS) $(DESTDIR)$(libsubdir)/specs; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/specs; \
+	fi
+# Install protoize if it was compiled.
+	-if [ -f protoize$(exeext) ]; then \
+	  rm -f $(DESTDIR)$(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) protoize$(exeext) $(DESTDIR)$(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext); \
+	  rm -f $(DESTDIR)$(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) unprotoize$(exeext) $(DESTDIR)$(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext); \
+	  rm -f $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	  $(INSTALL_DATA) SYSCALLS.c.X $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	fi
+# Install gcov if it was compiled.
+	-if [ -f gcov$(exeext) ]; \
+	then \
+	    rm -f $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \
+	    $(INSTALL_PROGRAM) gcov$(exeext) $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \
+	fi
+	$(INSTALL_SCRIPT) gccbug $(DESTDIR)$(bindir)/$(GCCBUG_INSTALL_NAME)
+
+# Install the driver program as $(target_noncanonical)-gcc, 
+# $(target_noncanonical)-gcc-$(version)
+# and also as either gcc (if native) or $(gcc_tooldir)/bin/gcc.
+install-driver: installdirs xgcc$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-$(version)
+	-( cd $(DESTDIR)$(bindir) && \
+	   $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-$(version) )
+	-if [ -f gcc-cross$(exeext) ] ; then \
+	  if [ -d $(DESTDIR)$(gcc_tooldir)/bin/. ] ; then \
+	    rm -f $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
+	    $(INSTALL_PROGRAM) gcc-cross$(exeext) $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
+	  else true; fi; \
+	else \
+	  rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-tmp$(exeext); \
+	  ( cd $(DESTDIR)$(bindir) && \
+	    $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-tmp$(exeext) && \
+	    mv -f $(target_noncanonical)-gcc-tmp$(exeext) $(GCC_TARGET_INSTALL_NAME)$(exeext) ); \
+	fi
+
+# Install the info files.
+# $(INSTALL_DATA) might be a relative pathname, so we can't cd into srcdir
+# to do the install.
+install-info:: doc installdirs \
+	$(DESTDIR)$(infodir)/cpp.info \
+	$(DESTDIR)$(infodir)/gcc.info \
+	$(DESTDIR)$(infodir)/cppinternals.info \
+	$(DESTDIR)$(infodir)/gccinstall.info \
+	$(DESTDIR)$(infodir)/gccint.info
+
+$(DESTDIR)$(infodir)/%.info: doc/%.info installdirs
+	rm -f $@
+	if [ -f $< ]; then \
+	  for f in $(<)*; do \
+	    realfile=`echo $$f | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
+	    $(INSTALL_DATA) $$f $(DESTDIR)$(infodir)/$$realfile; \
+	    chmod a-x $(DESTDIR)$(infodir)/$$realfile; \
+	  done; \
+	else true; fi
+	-if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
+	  if [ -f $@ ]; then \
+	    install-info --dir-file=$(DESTDIR)$(infodir)/dir $@; \
+	  else true; fi; \
+	else true; fi;
+
+# Install the man pages.
+install-man: installdirs lang.install-man \
+	$(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext) \
+	$(DESTDIR)$(man1dir)/$(CPP_INSTALL_NAME)$(man1ext) \
+	$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext) \
+	$(DESTDIR)$(man7dir)/fsf-funding$(man7ext) \
+	$(DESTDIR)$(man7dir)/gfdl$(man7ext) \
+	$(DESTDIR)$(man7dir)/gpl$(man7ext)
+
+$(DESTDIR)$(man7dir)/%$(man7ext): doc/%.7
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@
+	-chmod a-x $@
+
+$(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext): doc/gcc.1
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@ 
+	-chmod a-x $@
+
+$(DESTDIR)$(man1dir)/$(CPP_INSTALL_NAME)$(man1ext): doc/cpp.1
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@ 
+	-chmod a-x $@
+
+$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext): doc/gcov.1
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@ 
+	-chmod a-x $@
+
+# Install the library.
+install-libgcc: libgcc.mk libgcc.a libgcov.a installdirs
+	$(MAKE) \
+	  CFLAGS="$(CFLAGS) $(WARN_CFLAGS)" \
+	  CONFIG_H="$(TCONFIG_H)" \
+	  MAKEOVERRIDES= \
+	  -f libgcc.mk install
+
+# Install multiple versions of libgcc.a, libgcov.a.
+install-multilib: stmp-multilib installdirs
+	$(MAKE) \
+	  CFLAGS="$(CFLAGS) $(WARN_CFLAGS)" \
+	  CONFIG_H="$(CONFIG_H)" \
+	  MAKEOVERRIDES= \
+	  -f libgcc.mk install
+
+# Install all the header files built in the include subdirectory.
+install-headers: $(INSTALL_HEADERS_DIR)
+# Fix symlinks to absolute paths in the installed include directory to
+# point to the installed directory, not the build directory.
+# Don't need to use LN_S here since we really do need ln -s and no substitutes.
+	-files=`cd $(DESTDIR)$(libsubdir)/include; find . -type l -print 2>/dev/null`; \
+	if [ $$? -eq 0 ]; then \
+	  dir=`cd include; ${PWD_COMMAND}`; \
+	  for i in $$files; do \
+	    dest=`ls -ld $(DESTDIR)$(libsubdir)/include/$$i | sed -n 's/.*-> //p'`; \
+	    if expr "$$dest" : "$$dir.*" > /dev/null; then \
+	      rm -f $(DESTDIR)$(libsubdir)/include/$$i; \
+	      ln -s `echo $$i | sed "s|/[^/]*|/..|g" | sed 's|/..$$||'``echo "$$dest" | sed "s|$$dir||"` $(DESTDIR)$(libsubdir)/include/$$i; \
+	    fi; \
+	  done; \
+	fi
+
+# Create or recreate the gcc private include file directory.
+install-include-dir: installdirs
+	-rm -rf $(DESTDIR)$(libsubdir)/include
+	mkdir $(DESTDIR)$(libsubdir)/include
+	-chmod a+rx $(DESTDIR)$(libsubdir)/include
+
+# Install the include directory using tar.
+install-headers-tar: stmp-int-hdrs $(STMP_FIXPROTO) install-include-dir
+# We use `pwd`/include instead of just include to problems with CDPATH
+# Unless a full pathname is provided, some shells would print the new CWD,
+# found in CDPATH, corrupting the output.  We could just redirect the
+# output of `cd', but some shells lose on redirection within `()'s
+	(cd `${PWD_COMMAND}`/include ; \
+	 tar -cf - .; exit 0) | (cd $(DESTDIR)$(libsubdir)/include; tar xpf - )
+# /bin/sh on some systems returns the status of the first tar,
+# and that can lose with GNU tar which always writes a full block.
+# So use `exit 0' to ignore its exit status.
+
+# Install the include directory using cpio.
+install-headers-cpio: stmp-int-hdrs $(STMP_FIXPROTO) install-include-dir
+# See discussion about the use of `pwd` above
+	cd `${PWD_COMMAND}`/include ; \
+	find . -print | cpio -pdum $(DESTDIR)$(libsubdir)/include
+
+# Install the include directory using cp.
+install-headers-cp: stmp-int-hdrs $(STMP_FIXPROTO) install-include-dir
+	cp -p -r include $(DESTDIR)$(libsubdir)
+
+itoolsdir = $(libexecsubdir)/install-tools
+itoolsdatadir = $(libsubdir)/install-tools
+# Don't install the headers.  Instead, install appropriate scripts
+# and supporting files for fixincludes to be run later.
+install-mkheaders: stmp-int-hdrs $(STMP_FIXPROTO) install-include-dir \
+    mkheaders xlimits.h
+	-rm -rf $(DESTDIR)$(itoolsdir) $(DESTDIR)$(itoolsdatadir)
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(itoolsdatadir)/include
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(itoolsdir)
+	for file in $(USER_H); do \
+	  realfile=`echo $$file | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
+	  $(INSTALL_DATA) $$file \
+	    $(DESTDIR)$(itoolsdatadir)/include/$$realfile ; \
+	done
+	$(INSTALL_DATA) xlimits.h $(DESTDIR)$(itoolsdatadir)/include/limits.h
+	if [ x$(STMP_FIXINC) != x ] ; then \
+	  $(INSTALL_DATA) $(srcdir)/README-fixinc \
+	    $(DESTDIR)$(itoolsdatadir)/include/README ; \
+	  $(INSTALL_SCRIPT) fixinc.sh $(DESTDIR)$(itoolsdir)/fixinc.sh ; \
+	  $(INSTALL_PROGRAM) fixinc/fixincl $(DESTDIR)$(itoolsdir)/fixincl ; \
+	  $(INSTALL_DATA) $(srcdir)/gsyslimits.h \
+	    $(DESTDIR)$(itoolsdatadir)/gsyslimits.h ; \
+	else :; fi
+	if [ x$(STMP_FIXPROTO) != x ] ; then \
+	  $(INSTALL_SCRIPT) $(srcdir)/mkinstalldirs \
+		$(DESTDIR)$(itoolsdir)/mkinstalldirs ; \
+	  $(INSTALL_SCRIPT) $(srcdir)/fixproto $(DESTDIR)$(itoolsdir)/fixproto ; \
+	  $(INSTALL_PROGRAM) fix-header$(build_exeext) \
+		$(DESTDIR)$(itoolsdir)/fix-header$(build_exeext) ; \
+	else :; fi
+	$(INSTALL_SCRIPT) mkheaders $(DESTDIR)$(itoolsdir)/mkheaders
+	echo 'SYSTEM_HEADER_DIR="'"$(SYSTEM_HEADER_DIR)"'"' \
+		> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'OTHER_FIXINCLUDES_DIRS="$(OTHER_FIXINCLUDES_DIRS)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'FIXPROTO_DEFINES="$(FIXPROTO_DEFINES)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'STMP_FIXPROTO="$(STMP_FIXPROTO)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'STMP_FIXINC="$(STMP_FIXINC)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+
+# Use this target to install the program `collect2' under the name `collect2'.
+install-collect2: collect2 installdirs
+	$(INSTALL_PROGRAM) collect2$(exeext) $(DESTDIR)$(libexecsubdir)/collect2$(exeext)
+# Install the driver program as $(libsubdir)/gcc for collect2.
+	$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(libexecsubdir)/gcc$(exeext)
+
+# Cancel installation by deleting the installed files.
+uninstall: lang.uninstall
+	-rm -rf $(DESTDIR)$(libsubdir)
+	-rm -rf $(DESTDIR)$(libexecsubdir)
+	-rm -rf $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-if [ x$(cpp_install_dir) != x ]; then \
+	  rm -f $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	else true; fi
+	-rm -rf $(DESTDIR)$(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext)
+	-rm -rf $(DESTDIR)$(man1dir)/cpp$(man1ext)
+	-rm -rf $(DESTDIR)$(man1dir)/protoize$(man1ext)
+	-rm -rf $(DESTDIR)$(man1dir)/unprotoize$(man1ext)
+	-rm -f $(DESTDIR)$(infodir)/cpp.info* $(DESTDIR)$(infodir)/gcc.info*
+	-rm -f $(DESTDIR)$(infodir)/cppinternals.info* $(DESTDIR)$(infodir)/gccint.info*
+#
+# These targets are for the dejagnu testsuites. The file site.exp
+# contains global variables that all the testsuites will use.
+
+target_subdir = @target_subdir@
+
+site.exp: ./config.status Makefile
+	@echo "Making a new config file..."
+	-@rm -f ./tmp?
+	@$(STAMP) site.exp
+	-@mv site.exp site.bak
+	@echo "## these variables are automatically generated by make ##" > ./tmp0
+	@echo "# Do not edit here. If you wish to override these values" >> ./tmp0
+	@echo "# add them to the last section" >> ./tmp0
+	@echo "set rootme \"`${PWD_COMMAND}`\"" >> ./tmp0
+	@echo "set srcdir \"`cd ${srcdir}; ${PWD_COMMAND}`\"" >> ./tmp0
+	@echo "set host_triplet $(host)" >> ./tmp0
+	@echo "set build_triplet $(build)" >> ./tmp0
+	@echo "set target_triplet $(target)" >> ./tmp0
+	@echo "set target_alias $(target_noncanonical)" >> ./tmp0
+# CFLAGS is set even though it's empty to show we reserve the right to set it.
+	@echo "set CFLAGS \"\"" >> ./tmp0
+	@echo "set CXXFLAGS \"\"" >> ./tmp0
+	@echo "set TESTING_IN_BUILD_TREE 1" >> ./tmp0
+	@echo "set HAVE_LIBSTDCXX_V3 1" >> ./tmp0
+# If newlib has been configured, we need to pass -B to gcc so it can find
+# newlib's crt0.o if it exists.  This will cause a "path prefix not used"
+# message if it doesn't, but the testsuite is supposed to ignore the message -
+# it's too difficult to tell when to and when not to pass -B (not all targets
+# have crt0's).  We could only add the -B if ../newlib/crt0.o exists, but that
+# seems like too selective a test.
+# ??? Another way to solve this might be to rely on linker scripts.  Then
+# theoretically the -B won't be needed.
+# We also need to pass -L ../ld so that the linker can find ldscripts.
+	@if [ -d $(objdir)/../$(target_subdir)/newlib ] \
+	    && [ "${host}" != "${target}" ]; then \
+	  echo "set newlib_cflags \"-I$(objdir)/../$(target_subdir)/newlib/targ-include -I\$$srcdir/../newlib/libc/include\"" >> ./tmp0; \
+	  echo "set newlib_ldflags \"-B$(objdir)/../$(target_subdir)/newlib/\"" >> ./tmp0; \
+	  echo "append CFLAGS \" \$$newlib_cflags\"" >> ./tmp0; \
+	  echo "append CXXFLAGS \" \$$newlib_cflags\"" >> ./tmp0; \
+	  echo "append LDFLAGS \" \$$newlib_ldflags\"" >> ./tmp0; \
+	else true; \
+	fi
+	@if [ -d $(objdir)/../ld ] ; then \
+	  echo "append LDFLAGS \" -L$(objdir)/../ld\"" >> ./tmp0; \
+	else true; \
+	fi
+	echo "set tmpdir $(objdir)/testsuite" >> ./tmp0
+	@echo "set srcdir \"\$${srcdir}/testsuite\"" >> ./tmp0
+	@if [ "X$(ALT_CC_UNDER_TEST)" != "X" ] ; then \
+	  echo "set ALT_CC_UNDER_TEST \"$(ALT_CC_UNDER_TEST)\"" >> ./tmp0; \
+	else true; \
+	fi
+	@if [ "X$(ALT_CXX_UNDER_TEST)" != "X" ] ; then \
+	  echo "set ALT_CXX_UNDER_TEST \"$(ALT_CXX_UNDER_TEST)\"" >> ./tmp0; \
+	else true; \
+	fi
+	@if [ "X$(COMPAT_OPTIONS)" != "X" ] ; then \
+	  echo "set COMPAT_OPTIONS \"$(COMPAT_OPTIONS)\"" >> ./tmp0; \
+	else true; \
+	fi
+	@echo "## All variables above are generated by configure. Do Not Edit ##" >> ./tmp0
+	@cat ./tmp0 > site.exp
+	@cat site.bak | sed \
+		-e '1,/^## All variables above are.*##/ d' >> site.exp
+	-@rm -f ./tmp?
+
+CHECK_TARGETS = check-gcc @check_languages@
+
+check: $(CHECK_TARGETS)
+
+# The idea is to parallelize testing of multilibs, for example:
+#   make -j3 check-gcc//sh-hms-sim/{-m1,-m2,-m3,-m3e,-m4}/{,-nofpu}
+# will run 3 concurrent sessions of check-gcc, eventually testing
+# all 10 combinations.  GNU make is required, as is a shell that expands
+# alternations within braces.
+lang_checks_parallel = $(lang_checks:=//%)
+$(lang_checks_parallel): site.exp
+	target=`echo "$@" | sed 's,//.*,,'`; \
+	variant=`echo "$@" | sed 's,^[^/]*//,,'`; \
+	vardots=`echo "$$variant" | sed 's,/,.,g'`; \
+	$(MAKE) TESTSUITEDIR="testsuite.$$vardots" \
+	  RUNTESTFLAGS="--target_board=$$variant $(RUNTESTFLAGS)" \
+	  "$$target"
+
+TESTSUITEDIR = testsuite
+
+$(TESTSUITEDIR)/site.exp: site.exp
+	test -d $(TESTSUITEDIR) || mkdir $(TESTSUITEDIR)
+	-rm -f $@
+	sed '/set tmpdir/ s|testsuite|$(TESTSUITEDIR)|' < site.exp > $@
+
+$(lang_checks): check-% : $(TESTSUITEDIR)/site.exp
+	-(rootme=`${PWD_COMMAND}`; export rootme; \
+	srcdir=`cd ${srcdir}; ${PWD_COMMAND}` ; export srcdir ; \
+	cd $(TESTSUITEDIR); \
+	EXPECT=${EXPECT} ; export EXPECT ; \
+	if [ -f $${rootme}/../expect/expect ] ; then  \
+	   TCL_LIBRARY=`cd .. ; cd ${srcdir}/../tcl/library ; ${PWD_COMMAND}` ; \
+	    export TCL_LIBRARY ; fi ; \
+	$(RUNTEST) --tool $* $(RUNTESTFLAGS))
+
+check-consistency: testsuite/site.exp
+	-rootme=`${PWD_COMMAND}`; export rootme; \
+	srcdir=`cd ${srcdir}; ${PWD_COMMAND}` ; export srcdir ; \
+	cd testsuite; \
+	EXPECT=${EXPECT} ; export EXPECT ; \
+	if [ -f $${rootme}/../expect/expect ] ; then  \
+	   TCL_LIBRARY=`cd .. ; cd ${srcdir}/../tcl/library ; ${PWD_COMMAND}` ; \
+	   export TCL_LIBRARY ; fi ; \
+	$(RUNTEST) --tool consistency $(RUNTESTFLAGS)
+
+# QMTest targets
+
+# The path to qmtest.
+QMTEST_PATH=qmtest
+
+# The flags to pass to qmtest.
+QMTESTFLAGS=
+
+# The flags to pass to "qmtest run".
+QMTESTRUNFLAGS=-f none --result-stream dejagnu_stream.DejaGNUStream
+
+# The command to use to invoke qmtest.
+QMTEST=${QMTEST_PATH} ${QMTESTFLAGS}
+
+# The tests (or suites) to run.
+QMTEST_GPP_TESTS=g++
+
+# The subdirectory of the OBJDIR that will be used to store the QMTest
+# test database configuration and that will be used for temporary
+# scratch space during QMTest's execution.
+QMTEST_DIR=qmtestsuite
+
+# Create the QMTest database configuration.
+${QMTEST_DIR} stamp-qmtest:
+	${QMTEST} -D ${QMTEST_DIR} create-tdb \
+	    -c gcc_database.GCCDatabase \
+            -a srcdir=`cd ${srcdir}/testsuite && ${PWD_COMMAND}` && \
+	    $(STAMP) stamp-qmtest
+
+# Create the QMTest context file.
+${QMTEST_DIR}/context: stamp-qmtest
+	rm -f $@
+	echo "CompilerTable.languages=c cplusplus" >> $@
+	echo "CompilerTable.c_kind=GCC" >> $@
+	echo "CompilerTable.c_path=${objdir}/xgcc" >> $@
+	echo "CompilerTable.c_options=-B${objdir}/" >> $@
+	echo "CompilerTable.cplusplus_kind=GCC" >> $@
+	echo "CompilerTable.cplusplus_path=${objdir}/g++" >> $@
+	echo "CompilerTable.cplusplus_options=-B${objdir}/" >> $@
+	echo "DejaGNUTest.target=${target_noncanonical}" >> $@
+
+# Run the G++ testsuite using QMTest.
+qmtest-g++: ${QMTEST_DIR}/context
+	cd ${QMTEST_DIR} && ${QMTEST} run ${QMTESTRUNFLAGS} -C context \
+	   -o g++.qmr ${QMTEST_GPP_TESTS}
+
+# Use the QMTest GUI.
+qmtest-gui: ${QMTEST_DIR}/context
+	cd ${QMTEST_DIR} && ${QMTEST} gui -C context
+
+.PHONY: qmtest-g++
+
+# Run Paranoia on real.c.
+
+paranoia.o: $(srcdir)/../contrib/paranoia.cc $(CONFIG_H) $(SYSTEM_H) \
+  real.h $(TREE_H)
+	g++ -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+paranoia: paranoia.o real.o $(LIBIBERTY)
+	g++ -o $@ paranoia.o real.o $(LIBIBERTY)
+
+# These exist for maintenance purposes.
+
+# Update the tags table.
+TAGS: lang.tags
+	(cd $(srcdir);					\
+	incs= ;						\
+	list='$(SUBDIRS)'; for dir in $$list; do	\
+	  if test -f $$dir/TAGS; then			\
+	    incs="$$incs --include $$dir/TAGS.sub";	\
+	  fi;						\
+	done;						\
+	mkdir tmp-tags;					\
+	mv -f c-parse.[ch] tmp-tags;			\
+	etags -o TAGS.sub *.y *.h *.c;			\
+	mv tmp-tags/* .;				\
+	rmdir tmp-tags;					\
+	etags --include TAGS.sub $$incs)
+
+# ------------------------------------------------------
+# Bootstrap-related targets (not used during 'make all')
+# ------------------------------------------------------
+
+# A list of files to be destroyed during "lean" builds.
+VOL_FILES=`echo $(BACKEND) $(OBJS) $(C_OBJS) $(LIBCPP_OBJS) *.c *.h gen*`
+
+# Flags to pass to stage2 and later recursive makes.  Note that the
+# WARN_CFLAGS setting can't be to the expansion of GCC_WARN_CFLAGS in
+# the context of the stage_x rule.
+
+POSTSTAGE1_FLAGS_TO_PASS = \
+	ADAFLAGS="$(BOOT_ADAFLAGS)" \
+	CFLAGS="$(BOOT_CFLAGS)" \
+	LDFLAGS="$(BOOT_LDFLAGS)" \
+	WARN_CFLAGS="\$$(GCC_WARN_CFLAGS)" \
+	STRICT_WARN="$(STRICT2_WARN)" \
+	libdir=$(libdir) \
+	LANGUAGES="$(LANGUAGES)" \
+	MAKEINFO="$(MAKEINFO)" \
+	MAKEINFOFLAGS="$(MAKEINFOFLAGS)" \
+	MAKEOVERRIDES= \
+	OUTPUT_OPTION="-o \$$@"
+
+STAGE2_FLAGS_TO_PASS = \
+	CFLAGS="$(BOOT_CFLAGS)" \
+	WERROR="@WERROR@" \
+
+STAGEPROFILE_FLAGS_TO_PASS = \
+	CFLAGS="$(BOOT_CFLAGS) -fprofile-generate" 
+
+# Files never linked into the final executable produces warnings about missing
+# profile.
+STAGEFEEDBACK_FLAGS_TO_PASS = \
+	CFLAGS="$(BOOT_CFLAGS) -fprofile-use" 
+
+# Only build the C compiler for stage1, because that is the only one that
+# we can guarantee will build with the native compiler, and also it is the
+# only thing useful for building stage2. STAGE1_CFLAGS (via CFLAGS),
+# MAKEINFO and MAKEINFOFLAGS are explicitly passed here to make them
+# overrideable (for a bootstrap build stage1 also builds gcc.info).
+stage1_build:
+	$(MAKE) CC="$(CC)" libdir=$(libdir) LANGUAGES="$(BOOT_LANGUAGES)" \
+		CFLAGS="$(STAGE1_CFLAGS)" MAKEINFO="$(MAKEINFO)" \
+		MAKEINFOFLAGS="$(MAKEINFOFLAGS)" COVERAGE_FLAGS= \
+		OBJS-onestep="$(OBJS)"
+	$(STAMP) stage1_build
+	echo stage1_build > stage_last
+
+stage1_copy: stage1_build
+	$(MAKE) stage1
+	$(STAMP) stage1_copy
+	echo stage2_build > stage_last
+
+stage2_build: stage1_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage1/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGE2_FLAGS_TO_PASS)
+	$(STAMP) stage2_build
+	echo stage2_build > stage_last
+
+stage2_copy: stage2_build
+	$(MAKE) stage2
+	$(STAMP) stage2_copy
+	echo stage3_build > stage_last
+
+stageprofile_build: stage1_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage1/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGEPROFILE_FLAGS_TO_PASS)
+	$(STAMP) stageprofile_build
+	echo stageprofile_build > stage_last
+
+stageprofile_copy: stageprofile_build
+	$(MAKE) stageprofile
+	$(STAMP) stageprofile_copy
+	echo stagefeedback_build > stage_last
+
+stage3_build: stage2_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage2/xgcc$(exeext) -Bstage2/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage2/xgcc$(exeext) -Bstage2/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage2/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGE2_FLAGS_TO_PASS)
+	$(STAMP) stage3_build
+	echo stage3_build > stage_last
+
+stagefeedback_build: stageprofile_copy stage1_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage1/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGEFEEDBACK_FLAGS_TO_PASS)
+	$(STAMP) stagefeedback_build
+	echo stagefeedback_build > stage_last
+
+stagefeedback_copy: stagefeedback_build
+	$(MAKE) stagefeedback
+	$(STAMP) stagefeedback_copy
+	echo stagefeedback2_build > stage_last
+
+# For bootstrap4:
+stage3_copy: stage3_build
+	$(MAKE) stage3
+	$(STAMP) stage3_copy
+	echo stage4_build > stage_last
+
+stage4_build: stage3_copy
+	$(MAKE) CC="$(STAGE_CC_WRAPPER) stage3/xgcc$(exeext) -Bstage3/ -B$(build_tooldir)/bin/" CC_FOR_BUILD="$(STAGE_CC_WRAPPER) stage3/xgcc$(exeext) -Bstage3/ -B$(build_tooldir)/bin/" \
+		 STAGE_PREFIX=stage3/ \
+		 $(POSTSTAGE1_FLAGS_TO_PASS) \
+		 $(STAGE2_FLAGS_TO_PASS)
+	$(STAMP) stage4_build
+	echo stage4_build > stage_last
+
+# Additional steps for *-lean targets:
+clean_s1: stage1_copy
+	-(cd stage1 && rm -f $(VOL_FILES))
+	$(STAMP) clean_s1
+
+clean_s2: stage2_copy
+	-rm -rf stage1
+	$(STAMP) clean_s2
+
+# The various entry points for bootstrapping.
+
+bootstrap: stage3_build
+	@echo
+	@echo Bootstrap complete - make \"quickstrap\" to redo last build,
+	@echo \"restage1\" through \"restage3\" to rebuild specific stages,
+	@echo \"restrap\" to redo the bootstrap from stage1, or
+	@echo \"cleanstrap\" to redo the bootstrap from scratch.
+
+bootstrap-lean : clean_s1 clean_s2 stage3_build
+	@echo
+	@echo Bootstrap complete - make \"quickstrap\" to redo last build,
+	@echo or \"cleanstrap\" to redo the bootstrap from scratch.
+
+bootstrap2: bootstrap
+
+bootstrap2-lean : bootstrap-lean
+
+bootstrap3 bootstrap3-lean: bootstrap
+
+bootstrap4 bootstrap4-lean: stage4_build
+
+unstage1 unstage2 unstage3 unstage4 unstageprofile unstagefeedback:
+	-set -vx; stage=`echo $@ | sed -e 's/un//'`; \
+	rm -f $$stage/as$(exeext); \
+	rm -f $$stage/ld$(exeext); \
+	rm -f $$stage/collect-ld$(exeext); \
+	if test -d $$stage; then \
+	  mv $$stage/specs $(SPECS) 2>/dev/null || :; \
+	  mv $$stage/* . 2>/dev/null; \
+	  for i in `cd $$stage; echo *` ; do \
+	    if test -d $$stage/$$i; then \
+	      mv $$stage/$$i/* $$i/. 2>/dev/null; \
+	    else \
+	      mv $$stage/$$i .; \
+	    fi; \
+	  done \
+	fi ; \
+	rm -f $${stage}_build $${stage}_copy ;\
+	echo $${stage}_build > stage_last
+
+restage1: unstage1
+	$(MAKE) $(REMAKEFLAGS) stage1_build
+
+restage2: unstage2
+	$(MAKE) $(REMAKEFLAGS) stage2_build
+
+restage3: unstage3
+	$(MAKE) $(REMAKEFLAGS) stage3_build
+
+restage4: unstage4
+	$(MAKE) $(REMAKEFLAGS) stage4_build
+
+restageprofile: unstageprofile
+	$(MAKE) $(REMAKEFLAGS) stageprofile_build
+
+restagefeedback: unstagefeedback
+	$(MAKE) $(REMAKEFLAGS) stagefeedback_build
+
+# Bubble up a bugfix through all the stages.  Primarily useful for fixing
+# bugs that cause the compiler to crash while building stage 2.
+bubblestrap:
+	if test -f stage_last; then \
+	  LAST=`sed -e 's/_build//' < stage_last`; \
+	  if test "$$LAST" != "stage1"; then \
+	    $(MAKE) $(REMAKEFLAGS) $$LAST; \
+	    $(STAMP) $${LAST}_copy; \
+	  fi; \
+	fi
+	if test -f stage1_copy; then $(MAKE) unstage1; fi
+	$(MAKE) $(REMAKEFLAGS) stage1_copy
+	if test -f stage2_copy; then $(MAKE) unstage2; fi
+	$(MAKE) $(REMAKEFLAGS) stage2_copy
+	if test -f stage3_copy; then $(MAKE) unstage3; fi
+	$(MAKE) $(REMAKEFLAGS) stage3_build
+	if test -f stage4_copy; then \
+	  $(MAKE) $(REMAKEFLAGS) stage3_copy; $(MAKE) unstage4; \
+	  $(MAKE) $(REMAKEFLAGS) stage4_build || exit 1; \
+	fi
+
+quickstrap:
+	if test -f stage_last ; then \
+	  LAST=`cat stage_last`; rm $$LAST; $(MAKE) $(REMAKEFLAGS) $$LAST; \
+	else \
+	  $(MAKE) $(REMAKEFLAGS) stage1_build; \
+	fi
+
+cleanstrap:
+	-$(MAKE) clean
+	$(MAKE) $(REMAKEFLAGS) bootstrap
+
+unstrap:
+	-rm -rf stage[234]*
+	$(MAKE) unstage1
+	-rm -f stage_last
+
+# Differs from cleanstrap in that it starts from the earlier stage1 build,
+# not from scratch.
+restrap:
+	$(MAKE) unstrap
+	$(MAKE) $(REMAKEFLAGS) bootstrap
+
+# These targets compare the object files in the current directory with
+# those in a stage directory.  We need to skip the first N bytes of
+# each object file.  The "slow" mechanism assumes nothing special
+# about cmp and uses the tail command to skip.  ./ avoids a bug in
+# some versions of tail.  The "gnu" targets use gnu cmp (diffutils
+# v2.4 or later), to avoid running tail and the overhead of twice
+# copying each object file.  Likewise, the "fast" targets use the skip
+# parameter of cmp available on some systems to accomplish the same
+# thing.  An exit status of 1 is precisely the result we're looking
+# for (other values mean other problems).
+slowcompare slowcompare3 slowcompare4 slowcompare-lean slowcompare3-lean slowcompare4-lean \
+fastcompare fastcompare3 fastcompare4 fastcompare-lean fastcompare3-lean fastcompare4-lean \
+ gnucompare  gnucompare3  gnucompare4  gnucompare-lean  gnucompare3-lean  gnucompare4-lean: force
+	-rm -f .bad_compare
+	case "$@" in *compare | *compare-lean ) stage=2 ;; * ) stage=`echo $@ | sed -e 's,^[a-z]*compare\([0-9][0-9]*\).*,\1,'` ;; esac; \
+	for dir in . $(SUBDIRS); do \
+	  if [ "`echo $$dir/*$(objext)`" != "$$dir/*$(objext)" ] ; then \
+	    for file in $$dir/*$(objext); do \
+	      case "$@" in \
+		slowcompare* ) \
+		  tail +16c ./$$file > tmp-foo1; \
+		  tail +16c stage$$stage/$$file > tmp-foo2 \
+		    && (cmp tmp-foo1 tmp-foo2 > /dev/null 2>&1 || echo $$file differs >> .bad_compare) || true; \
+		  ;; \
+		fastcompare* ) \
+		  cmp $$file stage$$stage/$$file 16 16 > /dev/null 2>&1; \
+		  test $$? -eq 1 && echo $$file differs >> .bad_compare || true; \
+		  ;; \
+		gnucompare* ) \
+		  cmp --ignore-initial=16 $$file stage$$stage/$$file > /dev/null 2>&1; \
+		  test $$? -eq 1 && echo $$file differs >> .bad_compare || true; \
+		  ;; \
+	      esac ; \
+	    done; \
+	  else true; fi; \
+	done
+	-rm -f tmp-foo*
+	case "$@" in *compare | *compare-lean ) stage=2 ;; * ) stage=`echo $@ | sed -e 's,^[a-z]*compare\([0-9][0-9]*\).*,\1,'` ;; esac; \
+	if [ -f .bad_compare ]; then \
+	  echo "Bootstrap comparison failure!"; \
+	  cat .bad_compare; \
+	  exit 1; \
+	else \
+	  case "$@" in \
+	    *-lean ) rm -rf stage$$stage ;; \
+	    *) ;; \
+	  esac; true; \
+	fi
+
+# Forwarding wrappers to the most appropriate version.
+compare: @make_compare_target@
+compare3: @make_compare_target@3
+compare4: @make_compare_target@4
+compare-lean: @make_compare_target@-lean
+compare3-lean: @make_compare_target@3-lean
+compare4-lean: @make_compare_target@4-lean
+
+# Copy the object files from a particular stage into a subdirectory.
+stage1-start:
+	-if [ -d stage1 ] ; then true ; else mkdir stage1 ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stage1
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stage1/$$dir ] ; then true ; else mkdir stage1/$$dir ; fi ; \
+	 done
+# If SPECS is overridden, make sure it is `installed' as specs.
+	-mv $(SPECS) stage1/specs
+	-mv $(STAGESTUFF) stage1
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stage1 && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stage1 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stage1 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-rm -f stage1/libgcc.a stage1/libgcc_eh.a stage1/libgcov.a
+	-rm -f stage1/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage1/libunwind.a stage1/libunwind*$(SHLIB_EXT)
+	-cp libgcc.a stage1
+	-$(RANLIB_FOR_TARGET) stage1/libgcc.a
+	-cp libgcov.a stage1
+	-$(RANLIB_FOR_TARGET) stage1/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage1; \
+	   $(RANLIB_FOR_TARGET) stage1/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stage1
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage1
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stage1/$${f} . ; \
+	else true; \
+	fi; done
+stage1: force stage1-start lang.stage1
+	-for dir in . $(SUBDIRS) ; \
+	do \
+	  rm -f $$dir/*$(coverageexts) ; \
+	done
+
+stage2-start:
+	-if [ -d stage2 ] ; then true ; else mkdir stage2 ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stage2
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stage2/$$dir ] ; then true ; else mkdir stage2/$$dir ; fi ; \
+	 done
+# If SPECS is overridden, make sure it is `installed' as specs.
+	-mv $(SPECS) stage2/specs
+	-mv $(STAGESTUFF) stage2
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stage2 && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stage2 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stage2 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-rm -f stage2/libgcc.a stage2/libgcov.a stage2/libgcc_eh.a
+	-rm -f stage2/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage2/libunwind.a stage2/libunwind*$(SHLIB_EXT)
+	-cp libgcc.a stage2
+	-$(RANLIB_FOR_TARGET) stage2/libgcc.a
+	-cp libgcov.a stage2
+	-$(RANLIB_FOR_TARGET) stage2/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage2; \
+	   $(RANLIB_FOR_TARGET) stage2/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stage2
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage2
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stage2/$${f} . ; \
+	else true; \
+	fi; done
+stage2: force stage2-start lang.stage2
+
+stage3-start:
+	-if [ -d stage3 ] ; then true ; else mkdir stage3 ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stage3
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stage3/$$dir ] ; then true ; else mkdir stage3/$$dir ; fi ; \
+	 done
+# If SPECS is overridden, make sure it is `installed' as specs.
+	-mv $(SPECS) stage3/specs
+	-mv $(STAGESTUFF) stage3
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stage3 && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stage3 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stage3 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-rm -f stage3/libgcc.a stage3/libgcov.a stage3/libgcc_eh.a
+	-rm -f stage3/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage3/libunwind.a stage3/libunwind*$(SHLIB_EXT)
+	-cp libgcc.a stage3
+	-$(RANLIB_FOR_TARGET) stage3/libgcc.a
+	-cp libgcov.a stage3
+	-$(RANLIB_FOR_TARGET) stage3/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage3; \
+	   $(RANLIB_FOR_TARGET) stage3/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stage3
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage3
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stage3/$${f} . ; \
+	else true; \
+	fi; done
+stage3: force stage3-start lang.stage3
+
+stage4-start:
+	-if [ -d stage4 ] ; then true ; else mkdir stage4 ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stage4
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stage4/$$dir ] ; then true ; else mkdir stage4/$$dir ; fi ; \
+	 done
+# If SPECS is overridden, make sure it is `installed' as specs.
+	-mv $(SPECS) stage4/specs
+	-mv $(STAGESTUFF) stage4
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stage4 && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stage4 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stage4 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-rm -f stage4/libgcc.a stage4/libgcov.a stage4/libgcc_eh.a
+	-rm -f stage4/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage4/libunwind.a stage4/libunwind*$(SHLIB_EXT)
+	-cp libgcc.a stage4
+	-$(RANLIB_FOR_TARGET) stage4/libgcc.a
+	-cp libgcov.a stage4
+	-$(RANLIB_FOR_TARGET) stage4/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage4; \
+	   $(RANLIB_FOR_TARGET) stage4/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stage4
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage4
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stage4/$${f} . ; \
+	else true; \
+	fi; done
+stage4: force stage4-start lang.stage4
+
+stageprofile-start:
+	-if [ -d stageprofile ] ; then true ; else mkdir stageprofile ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stageprofile
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stageprofile/$$dir ] ; then true ; else mkdir stageprofile/$$dir ; fi ; \
+	 done
+	-mv $(STAGESTUFF) stageprofile
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stageprofile && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stageprofile && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stageprofile && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-rm -f stageprofile/libgcc.a stageprofile/libgcov.a stageprofile/libgcc_eh.a
+	-rm -f stageprofile/libgcc_s*$(SHLIB_EXT)
+	-rm -f stageprofile/libunwind.a stageprofile/libunwind*$(SHLIB_EXT)
+	-cp libgcc.a stageprofile
+	-$(RANLIB_FOR_TARGET) stageprofile/libgcc.a
+	-cp libgcov.a stageprofile
+	-$(RANLIB_FOR_TARGET) stageprofile/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stageprofile; \
+	   $(RANLIB_FOR_TARGET) stageprofile/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stageprofile
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stageprofile
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stageprofile/$${f} . ; \
+	else true; \
+	fi; done
+stageprofile: force stageprofile-start lang.stageprofile
+
+stagefeedback-start:
+	-if [ -d stagefeedback ] ; then true ; else mkdir stagefeedback ; fi
+	$(MAKE) -f libgcc.mk libgcc-stage-start stage=stagefeedback
+	-subdirs="$(SUBDIRS)"; for dir in $$subdirs; \
+	 do \
+	   if [ -d stagefeedback/$$dir ] ; then true ; else mkdir stagefeedback/$$dir ; fi ; \
+	 done
+	-mv $(STAGESTUFF) stagefeedback
+# Copy as/ld if they exist to stage dir, so that running xgcc from the stage
+# dir will work properly.
+	-if [ -f as$(exeext) ] ; then (cd stagefeedback && $(LN_S) ../as$(exeext) .) ; else true ; fi
+	-if [ -f ld$(exeext) ] ; then (cd stagefeedback && $(LN_S) ../ld$(exeext) .) ; else true ; fi
+	-if [ -f collect-ld$(exeext) ] ; then (cd stagefeedback && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
+	-rm -f stagefeedback/libgcc.a stagefeedback/libgcov.a stagefeedback/libgcc_eh.a
+	-rm -f stagefeedback/libgcc_s*$(SHLIB_EXT)
+	-rm -f stagefeedback/libunwind.a stagefeedback/libunwind*$(SHLIB_EXT)
+	-rm -f *.da
+	-for dir in fixinc po testsuite $(SUBDIRS); \
+	 do \
+	   rm -f $$dir/*.da ; \
+	 done
+	-cp libgcc.a stagefeedback
+	-$(RANLIB_FOR_TARGET) stagefeedback/libgcc.a
+	-cp libgcov.a stagefeedback
+	-$(RANLIB_FOR_TARGET) stagefeedback/libgcov.a
+	-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stagefeedback; \
+	   $(RANLIB_FOR_TARGET) stagefeedback/libgcc_eh.a; \
+	fi
+	-cp libgcc_s*$(SHLIB_EXT) stagefeedback
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stagefeedback
+	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
+	  cp stagefeedback/$${f} . ; \
+	else true; \
+	fi; done
+stagefeedback: force stagefeedback-start lang.stagefeedback
+
+# Copy just the executable files from a particular stage into a subdirectory,
+# and delete the object files.  Use this if you're just verifying a version
+# that is pretty sure to work, and you are short of disk space.
+risky-stage1: stage1
+	-$(MAKE) clean
+
+risky-stage2: stage2
+	-$(MAKE) clean
+
+risky-stage3: stage3
+	-$(MAKE) clean
+
+risky-stage4: stage4
+	-$(MAKE) clean
+
+#In GNU Make, ignore whether `stage*' exists.
+.PHONY: stage1 stage2 stage3 stage4 clean maintainer-clean TAGS bootstrap
+.PHONY: risky-stage1 risky-stage2 risky-stage3 risky-stage4
+.PHONY: stagefeedback stageprofile
+
+# -----------------------------------------------------
+# Rules for generating translated message descriptions.
+# Disabled by autoconf if the tools are not available.
+# -----------------------------------------------------
+
+XGETTEXT = @XGETTEXT@
+GMSGFMT = @GMSGFMT@
+MSGMERGE = msgmerge
+
+PACKAGE = @PACKAGE@
+CATALOGS = @CATALOGS@
+
+.PHONY: build- install- build-po install-po update-po
+
+# Dummy rules to deal with dependencies produced by use of
+# "build-@POSUB@" and "install-@POSUB@" above, when NLS is disabled.
+build-: ; @true
+install-: ; @true
+
+build-po: $(CATALOGS)
+
+# This notation should be acceptable to all Make implementations used
+# by people who are interested in updating .po files.
+update-po: $(CATALOGS:.gmo=.pox)
+
+# N.B. We do not attempt to copy these into $(srcdir).  The snapshot
+# script does that.
+.po.gmo:
+	-test -d po || mkdir po
+	$(GMSGFMT) --statistics -o $@ $<
+
+# The new .po has to be gone over by hand, so we deposit it into
+# build/po with a different extension.
+# If build/po/$(PACKAGE).pot exists, use it (it was just created),
+# else use the one in srcdir.
+.po.pox:
+	-test -d po || mkdir po
+	$(MSGMERGE) $< `if test -f po/$(PACKAGE).pot; \
+			then echo po/$(PACKAGE).pot; \
+			else echo $(srcdir)/po/$(PACKAGE).pot; fi` -o $@
+
+# This rule has to look for .gmo modules in both srcdir and
+# the cwd, and has to check that we actually have a catalog
+# for each language, in case they weren't built or included
+# with the distribution.
+install-po:
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(datadir)
+	cats="$(CATALOGS)"; for cat in $$cats; do \
+	  lang=`basename $$cat | sed 's/\.gmo$$//'`; \
+	  if [ -f $$cat ]; then :; \
+	  elif [ -f $(srcdir)/$$cat ]; then cat=$(srcdir)/$$cat; \
+	  else continue; \
+	  fi; \
+	  dir=$(localedir)/$$lang/LC_MESSAGES; \
+	  echo $(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$$dir; \
+	  $(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$$dir || exit 1; \
+	  echo $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/$(PACKAGE).mo; \
+	  $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/$(PACKAGE).mo; \
+	done
+
+# Rule for regenerating the message template (gcc.pot).
+# Instead of forcing everyone to edit POTFILES.in, which proved impractical,
+# this rule has no dependencies and always regenerates gcc.pot.  This is
+# relatively harmless since the .po files do not directly depend on it.
+# Note that exgettext has an awk script embedded in it which requires a
+# fairly modern (POSIX-compliant) awk.
+# The .pot file is left in the build directory.
+$(PACKAGE).pot: po/$(PACKAGE).pot
+po/$(PACKAGE).pot: force options.c
+	-test -d po || mkdir po
+	$(MAKE) srcextra
+	AWK=$(AWK) $(SHELL) $(srcdir)/po/exgettext \
+		$(XGETTEXT) $(PACKAGE) $(srcdir)
