diff -uNr newlib-1.15.0.orig/newlib/libc/include/machine/setjmp.h newlib-1.15.0/newlib/libc/include/machine/setjmp.h
--- newlib-1.15.0.orig/newlib/libc/include/machine/setjmp.h	2006-12-18 17:48:03.000000000 +0100
+++ newlib-1.15.0/newlib/libc/include/machine/setjmp.h	2007-01-12 11:31:17.000000000 +0100
@@ -27,7 +27,7 @@
 
 /* necv70 was 9 as well. */
 
-#ifdef __mc68000__
+#if defined(__m68k__) || defined(__mc68000__)
 /*
  * onsstack,sigmask,sp,pc,psl,d2-d7,a2-a6,
  * fp2-fp7	for 68881.
diff -uNr newlib-1.15.0.orig/newlib/libc/include/sys/errno.h newlib-1.15.0/newlib/libc/include/sys/errno.h
--- newlib-1.15.0.orig/newlib/libc/include/sys/errno.h	2002-09-24 16:10:12.000000000 +0200
+++ newlib-1.15.0/newlib/libc/include/sys/errno.h	2007-01-12 11:31:17.000000000 +0100
@@ -148,6 +148,7 @@
 #define ECASECLASH 137  /* Filename exists with different case */
 #define EILSEQ 138
 #define EOVERFLOW 139	/* Value too large for defined data type */
+#define ECANCELED 140	/* Operation canceled. */
 
 /* From cygwin32.  */
 #define EWOULDBLOCK EAGAIN	/* Operation would block */
diff -uNr newlib-1.15.0.orig/newlib/libc/include/sys/features.h newlib-1.15.0/newlib/libc/include/sys/features.h
--- newlib-1.15.0.orig/newlib/libc/include/sys/features.h	2006-09-14 00:09:27.000000000 +0200
+++ newlib-1.15.0/newlib/libc/include/sys/features.h	2007-01-12 11:30:37.000000000 +0100
@@ -45,9 +45,6 @@
 #define _POSIX_SHARED_MEMORY_OBJECTS	1
 #define _POSIX_SYNCHRONIZED_IO		1
 #define _POSIX_TIMERS			1
-#define _POSIX_BARRIERS                 200112L
-#define _POSIX_READER_WRITER_LOCKS      200112L
-#define _POSIX_SPIN_LOCKS               200112L
 
 
 /* In P1003.1b but defined by drafts at least as early as P1003.1c/D10  */
diff -uNr newlib-1.15.0.orig/newlib/libc/include/sys/_types.h newlib-1.15.0/newlib/libc/include/sys/_types.h
--- newlib-1.15.0.orig/newlib/libc/include/sys/_types.h	2004-06-11 22:37:09.000000000 +0200
+++ newlib-1.15.0/newlib/libc/include/sys/_types.h	2007-01-12 11:31:17.000000000 +0100
@@ -39,4 +39,7 @@
 /* Iconv descriptor type */
 typedef void *_iconv_t;
 
+typedef long * __intptr_t;
+typedef unsigned long* __uintptr_t;
+
 #endif	/* _SYS__TYPES_H */
diff -uNr newlib-1.15.0.orig/newlib/libc/machine/arm/machine/endian.h newlib-1.15.0/newlib/libc/machine/arm/machine/endian.h
--- newlib-1.15.0.orig/newlib/libc/machine/arm/machine/endian.h	2004-05-07 22:29:24.000000000 +0200
+++ newlib-1.15.0/newlib/libc/machine/arm/machine/endian.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-/* ARM configuration file */
-
-#ifndef _MACHINE_ENDIAN_H
-# define _MACHINE_ENDIAN_H
-
-#ifdef __ARMEB__
-#define BYTE_ORDER BIG_ENDIAN
-#else
-#define BYTE_ORDER LITTLE_ENDIAN
-#endif
-
-#endif
diff -uNr newlib-1.15.0.orig/newlib/libc/search/db_local.h newlib-1.15.0/newlib/libc/search/db_local.h
--- newlib-1.15.0.orig/newlib/libc/search/db_local.h	2002-06-25 01:05:08.000000000 +0200
+++ newlib-1.15.0/newlib/libc/search/db_local.h	2007-01-12 11:31:17.000000000 +0100
@@ -50,7 +50,7 @@
 #define	MAX_PAGE_NUMBER	0xffffffff	/* >= # of pages in a file */
 typedef __uint32_t	pgno_t;
 #define	MAX_PAGE_OFFSET	65535		/* >= # of bytes in a page */
-typedef __uint16_t	indx_t;
+typedef __uint_least16_t	indx_t;
 #define	MAX_REC_NUMBER	0xffffffff	/* >= # of records in a tree */
 typedef __uint32_t	recno_t;
 
@@ -191,12 +191,12 @@
  *	P_16_COPY	swap from one location to another
  */
 #define	M_16_SWAP(a) {							\
-	__uint16_t _tmp = a;						\
+	__uint_least16_t _tmp = a;						\
 	((char *)&a)[0] = ((char *)&_tmp)[1];				\
 	((char *)&a)[1] = ((char *)&_tmp)[0];				\
 }
 #define	P_16_SWAP(a) {							\
-	__uint16_t _tmp = *(__uint16_t *)a;				\
+	__uint_least16_t _tmp = *(__uint_least16_t *)a;				\
 	((char *)a)[0] = ((char *)&_tmp)[1];				\
 	((char *)a)[1] = ((char *)&_tmp)[0];				\
 }
diff -uNr newlib-1.15.0.orig/newlib/libc/search/extern.h newlib-1.15.0/newlib/libc/search/extern.h
--- newlib-1.15.0.orig/newlib/libc/search/extern.h	2002-06-20 21:51:31.000000000 +0200
+++ newlib-1.15.0/newlib/libc/search/extern.h	2007-01-12 11:31:17.000000000 +0100
@@ -48,7 +48,7 @@
 int	 __delpair(HTAB *, BUFHEAD *, int);
 int	 __expand_table(HTAB *);
 int	 __find_bigpair(HTAB *, BUFHEAD *, int, char *, int);
-__uint16_t	 __find_last_page(HTAB *, BUFHEAD **);
+__uint_least16_t	 __find_last_page(HTAB *, BUFHEAD **);
 void	 __free_ovflpage(HTAB *, BUFHEAD *);
 BUFHEAD	*__get_buf(HTAB *, __uint32_t, BUFHEAD *, int);
 int	 __get_page(HTAB *, char *, __uint32_t, int, int, int);
diff -uNr newlib-1.15.0.orig/newlib/libc/search/hash_bigkey.c newlib-1.15.0/newlib/libc/search/hash_bigkey.c
--- newlib-1.15.0.orig/newlib/libc/search/hash_bigkey.c	2006-06-07 21:22:59.000000000 +0200
+++ newlib-1.15.0/newlib/libc/search/hash_bigkey.c	2007-01-12 11:31:17.000000000 +0100
@@ -92,13 +92,13 @@
 	BUFHEAD *bufp;
 	const DBT *key, *val;
 {
-	__uint16_t *p;
+	__uint_least16_t *p;
 	int key_size, n, val_size;
-	__uint16_t space, move_bytes, off;
+	__uint_least16_t space, move_bytes, off;
 	char *cp, *key_data, *val_data;
 
 	cp = bufp->page;		/* Character pointer of p. */
-	p = (__uint16_t *)cp;
+	p = (__uint_least16_t *)cp;
 
 	key_data = (char *)key->data;
 	key_size = key->size;
@@ -136,7 +136,7 @@
 				OFFSET(p) = off;
 			} else
 				p[n - 2] = FULL_KEY;
-		p = (__uint16_t *)bufp->page;
+		p = (__uint_least16_t *)bufp->page;
 		cp = bufp->page;
 		bufp->flags |= BUF_MOD;
 	}
@@ -166,7 +166,7 @@
 			if (!bufp)
 				return (-1);
 			cp = bufp->page;
-			p = (__uint16_t *)cp;
+			p = (__uint_least16_t *)cp;
 		} else
 			p[n] = FULL_KEY_DATA;
 		bufp->flags |= BUF_MOD;
@@ -191,12 +191,12 @@
 	BUFHEAD *bufp;
 {
 	BUFHEAD *last_bfp, *rbufp;
-	__uint16_t *bp, pageno;
+	__uint_least16_t *bp, pageno;
 	int key_done, n;
 
 	rbufp = bufp;
 	last_bfp = NULL;
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	pageno = 0;
 	key_done = 0;
 
@@ -219,7 +219,7 @@
 		last_bfp = rbufp;
 		if (!rbufp)
 			return (-1);		/* Error. */
-		bp = (__uint16_t *)rbufp->page;
+		bp = (__uint_least16_t *)rbufp->page;
 	}
 
 	/*
@@ -234,7 +234,7 @@
 	pageno = bp[n - 1];
 
 	/* Now, bp is the first page of the pair. */
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	if (n > 2) {
 		/* There is an overflow page. */
 		bp[1] = pageno;
@@ -272,13 +272,13 @@
 	char *key;
 	int size;
 {
-	__uint16_t *bp;
+	__uint_least16_t *bp;
 	char *p;
 	int ksize;
-	__uint16_t bytes;
+	__uint_least16_t bytes;
 	char *kkey;
 
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	p = bufp->page;
 	ksize = size;
 	kkey = key;
@@ -294,7 +294,7 @@
 		if (!bufp)
 			return (-3);
 		p = bufp->page;
-		bp = (__uint16_t *)p;
+		bp = (__uint_least16_t *)p;
 		ndx = 1;
 	}
 
@@ -316,17 +316,17 @@
  * of the pair; 0 if there isn't any (i.e. big pair is the last key in the
  * bucket)
  */
-extern __uint16_t
+extern __uint_least16_t
 __find_last_page(hashp, bpp)
 	HTAB *hashp;
 	BUFHEAD **bpp;
 {
 	BUFHEAD *bufp;
-	__uint16_t *bp, pageno;
+	__uint_least16_t *bp, pageno;
 	int n;
 
 	bufp = *bpp;
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	for (;;) {
 		n = bp[0];
 
@@ -343,7 +343,7 @@
 		bufp = __get_buf(hashp, pageno, bufp, 0);
 		if (!bufp)
 			return (0);	/* Need to indicate an error! */
-		bp = (__uint16_t *)bufp->page;
+		bp = (__uint_least16_t *)bufp->page;
 	}
 
 	*bpp = bufp;
@@ -366,15 +366,15 @@
 	int set_current;
 {
 	BUFHEAD *save_p;
-	__uint16_t *bp, len, off, save_addr;
+	__uint_least16_t *bp, len, off, save_addr;
 	char *tp;
 
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	while (bp[ndx + 1] == PARTIAL_KEY) {
 		bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 		if (!bufp)
 			return (-1);
-		bp = (__uint16_t *)bufp->page;
+		bp = (__uint_least16_t *)bufp->page;
 		ndx = 1;
 	}
 
@@ -382,7 +382,7 @@
 		bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 		if (!bufp)
 			return (-1);
-		bp = (__uint16_t *)bufp->page;
+		bp = (__uint_least16_t *)bufp->page;
 		save_p = bufp;
 		save_addr = save_p->addr;
 		off = bp[1];
@@ -403,7 +403,7 @@
 			bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 			if (!bufp)
 				return (-1);
-			bp = (__uint16_t *)bufp->page;
+			bp = (__uint_least16_t *)bufp->page;
 		} else {
 			/* The data is all on one page. */
 			tp = (char *)bp;
@@ -422,7 +422,7 @@
 					if (!hashp->cpage)
 						return (-1);
 					hashp->cndx = 1;
-					if (!((__uint16_t *)
+					if (!((__uint_least16_t *)
 					    hashp->cpage->page)[0]) {
 						hashp->cbucket++;
 						hashp->cpage = NULL;
@@ -454,14 +454,14 @@
 	BUFHEAD *bufp;
 	int len, set;
 {
-	__uint16_t *bp;
+	__uint_least16_t *bp;
 	char *p;
 	BUFHEAD *xbp;
-	__uint16_t save_addr;
+	__uint_least16_t save_addr;
 	int mylen, totlen;
 
 	p = bufp->page;
-	bp = (__uint16_t *)p;
+	bp = (__uint_least16_t *)p;
 	mylen = hashp->BSIZE - bp[1];
 	save_addr = bufp->addr;
 
@@ -481,7 +481,7 @@
 				    __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 				if (!hashp->cpage)
 					return (-1);
-				else if (!((__uint16_t *)hashp->cpage->page)[0]) {
+				else if (!((__uint_least16_t *)hashp->cpage->page)[0]) {
 					hashp->cbucket++;
 					hashp->cpage = NULL;
 				}
@@ -533,10 +533,10 @@
 	BUFHEAD *xbp;
 	char *p;
 	int mylen, totlen;
-	__uint16_t *bp, save_addr;
+	__uint_least16_t *bp, save_addr;
 
 	p = bufp->page;
-	bp = (__uint16_t *)p;
+	bp = (__uint_least16_t *)p;
 	mylen = hashp->BSIZE - bp[1];
 
 	save_addr = bufp->addr;
@@ -579,11 +579,11 @@
 	SPLIT_RETURN *ret;
 {
 	BUFHEAD *tmpp;
-	__uint16_t *tp;
+	__uint_least16_t *tp;
 	BUFHEAD *bp;
 	DBT key, val;
 	__uint32_t change;
-	__uint16_t free_space, n, off;
+	__uint_least16_t free_space, n, off;
 
 	bp = big_keyp;
 
@@ -615,14 +615,14 @@
 	    (tmpp->ovfl ? tmpp->ovfl->addr : 0), (bp ? bp->addr : 0));
 #endif
 	tmpp->ovfl = bp;	/* one of op/np point to big_keyp */
-	tp = (__uint16_t *)tmpp->page;
+	tp = (__uint_least16_t *)tmpp->page;
 #ifdef DEBUG
 	assert(FREESPACE(tp) >= OVFLSIZE);
 #endif
 	n = tp[0];
 	off = OFFSET(tp);
 	free_space = FREESPACE(tp);
-	tp[++n] = (__uint16_t)addr;
+	tp[++n] = (__uint_least16_t)addr;
 	tp[++n] = OVFLPAGE;
 	tp[0] = n;
 	OFFSET(tp) = off;
@@ -638,7 +638,7 @@
 	ret->newp = np;
 	ret->oldp = op;
 
-	tp = (__uint16_t *)big_keyp->page;
+	tp = (__uint_least16_t *)big_keyp->page;
 	big_keyp->flags |= BUF_MOD;
 	if (tp[0] > 2) {
 		/*
diff -uNr newlib-1.15.0.orig/newlib/libc/search/hash_buf.c newlib-1.15.0/newlib/libc/search/hash_buf.c
--- newlib-1.15.0.orig/newlib/libc/search/hash_buf.c	2004-05-26 19:57:10.000000000 +0200
+++ newlib-1.15.0/newlib/libc/search/hash_buf.c	2007-01-12 11:31:17.000000000 +0100
@@ -176,7 +176,7 @@
 	BUFHEAD *next_xbp;
 	SEGMENT segp;
 	int segment_ndx;
-	__uint16_t oaddr, *shortp;
+	__uint_least16_t oaddr, *shortp;
 
 	oaddr = 0;
 	bp = LRU;
@@ -212,7 +212,7 @@
 			 * Set oaddr before __put_page so that you get it
 			 * before bytes are swapped.
 			 */
-			shortp = (__uint16_t *)bp->page;
+			shortp = (__uint_least16_t *)bp->page;
 			if (shortp[0])
 				oaddr = shortp[shortp[0] - 1];
 			if ((bp->flags & BUF_MOD) && __put_page(hashp, bp->page,
@@ -255,7 +255,7 @@
 				    (oaddr != xbp->addr))
 					break;
 
-				shortp = (__uint16_t *)xbp->page;
+				shortp = (__uint_least16_t *)xbp->page;
 				if (shortp[0])
 					/* set before __put_page */
 					oaddr = shortp[shortp[0] - 1];
diff -uNr newlib-1.15.0.orig/newlib/libc/search/hash.c newlib-1.15.0/newlib/libc/search/hash.c
--- newlib-1.15.0.orig/newlib/libc/search/hash.c	2004-05-26 19:57:10.000000000 +0200
+++ newlib-1.15.0/newlib/libc/search/hash.c	2007-01-12 11:31:17.000000000 +0100
@@ -628,10 +628,10 @@
 {
 	BUFHEAD *rbufp;
 	BUFHEAD *bufp, *save_bufp;
-	__uint16_t *bp;
+	__uint_least16_t *bp;
 	int n, ndx, off, size;
 	char *kp;
-	__uint16_t pageno;
+	__uint_least16_t pageno;
 
 #ifdef HASH_STATISTICS
 	hash_accesses++;
@@ -647,7 +647,7 @@
 
 	/* Pin the bucket chain */
 	rbufp->flags |= BUF_PIN;
-	for (bp = (__uint16_t *)rbufp->page, n = *bp++, ndx = 1; ndx < n;)
+	for (bp = (__uint_least16_t *)rbufp->page, n = *bp++, ndx = 1; ndx < n;)
 		if (bp[1] >= REAL_KEY) {
 			/* Real key/data pair */
 			if (size == off - *bp &&
@@ -666,7 +666,7 @@
 				return (ERROR);
 			}
 			/* FOR LOOP INIT */
-			bp = (__uint16_t *)rbufp->page;
+			bp = (__uint_least16_t *)rbufp->page;
 			n = *bp++;
 			ndx = 1;
 			off = hashp->BSIZE;
@@ -688,7 +688,7 @@
 					return (ERROR);
 				}
 				/* FOR LOOP INIT */
-				bp = (__uint16_t *)rbufp->page;
+				bp = (__uint_least16_t *)rbufp->page;
 				n = *bp++;
 				ndx = 1;
 				off = hashp->BSIZE;
@@ -722,7 +722,7 @@
 		save_bufp->flags &= ~BUF_PIN;
 		return (ABNORMAL);
 	case HASH_GET:
-		bp = (__uint16_t *)rbufp->page;
+		bp = (__uint_least16_t *)rbufp->page;
 		if (bp[ndx + 1] < REAL_KEY) {
 			if (__big_return(hashp, rbufp, ndx, val, 0))
 				return (ERROR);
@@ -758,7 +758,7 @@
 	__uint32_t bucket;
 	BUFHEAD *bufp;
 	HTAB *hashp;
-	__uint16_t *bp, ndx;
+	__uint_least16_t *bp, ndx;
 
 	hashp = (HTAB *)dbp->internal;
 	if (flag && flag != R_FIRST && flag != R_NEXT) {
@@ -783,7 +783,7 @@
 				if (!bufp)
 					return (ERROR);
 				hashp->cpage = bufp;
-				bp = (__uint16_t *)bufp->page;
+				bp = (__uint_least16_t *)bufp->page;
 				if (bp[0])
 					break;
 			}
@@ -793,7 +793,7 @@
 				return (ABNORMAL);
 			}
 		} else
-			bp = (__uint16_t *)hashp->cpage->page;
+			bp = (__uint_least16_t *)hashp->cpage->page;
 
 #ifdef DEBUG
 		assert(bp);
@@ -804,7 +804,7 @@
 			    __get_buf(hashp, bp[hashp->cndx], bufp, 0);
 			if (!bufp)
 				return (ERROR);
-			bp = (__uint16_t *)(bufp->page);
+			bp = (__uint_least16_t *)(bufp->page);
 			hashp->cndx = 1;
 		}
 		if (!bp[0]) {
diff -uNr newlib-1.15.0.orig/newlib/libc/search/hash.h newlib-1.15.0/newlib/libc/search/hash.h
--- newlib-1.15.0.orig/newlib/libc/search/hash.h	2002-07-02 20:18:58.000000000 +0200
+++ newlib-1.15.0/newlib/libc/search/hash.h	2007-01-12 11:31:17.000000000 +0100
@@ -102,7 +102,7 @@
 #define NCACHED	32			/* number of bit maps and spare 
 					 * points */
 	int		spares[NCACHED];/* spare pages for overflow */
-	__uint16_t	bitmaps[NCACHED];	/* address of overflow page 
+	__uint_least16_t	bitmaps[NCACHED];	/* address of overflow page 
 						 * bitmaps */
 } HASHHDR;
 
diff -uNr newlib-1.15.0.orig/newlib/libc/search/hash_page.c newlib-1.15.0/newlib/libc/search/hash_page.c
--- newlib-1.15.0.orig/newlib/libc/search/hash_page.c	2002-09-19 23:28:51.000000000 +0200
+++ newlib-1.15.0/newlib/libc/search/hash_page.c	2007-01-12 11:31:17.000000000 +0100
@@ -77,16 +77,16 @@
 static __uint32_t	*fetch_bitmap(HTAB *, int);
 static __uint32_t	 first_free(__uint32_t);
 static int	 open_temp(HTAB *);
-static __uint16_t	 overflow_page(HTAB *);
+static __uint_least16_t	 overflow_page(HTAB *);
 static void	 putpair(char *, const DBT *, const DBT *);
-static void	 squeeze_key(__uint16_t *, const DBT *, const DBT *);
+static void	 squeeze_key(__uint_least16_t *, const DBT *, const DBT *);
 static int	 ugly_split
 (HTAB *, __uint32_t, BUFHEAD *, BUFHEAD *, int, int);
 
 #define	PAGE_INIT(P) { \
-	((__uint16_t *)(P))[0] = 0; \
-	((__uint16_t *)(P))[1] = hashp->BSIZE - 3 * sizeof(__uint16_t); \
-	((__uint16_t *)(P))[2] = hashp->BSIZE; \
+	((__uint_least16_t *)(P))[0] = 0; \
+	((__uint_least16_t *)(P))[1] = hashp->BSIZE - 3 * sizeof(__uint_least16_t); \
+	((__uint_least16_t *)(P))[2] = hashp->BSIZE; \
 }
 
 /*
@@ -99,9 +99,9 @@
 	char *p;
 	const DBT *key, *val;
 {
-	__uint16_t *bp, n, off;
+	__uint_least16_t *bp, n, off;
 
-	bp = (__uint16_t *)p;
+	bp = (__uint_least16_t *)p;
 
 	/* Enter the key first. */
 	n = bp[0];
@@ -117,7 +117,7 @@
 
 	/* Adjust page info. */
 	bp[0] = n;
-	bp[n + 1] = off - ((n + 3) * sizeof(__uint16_t));
+	bp[n + 1] = off - ((n + 3) * sizeof(__uint_least16_t));
 	bp[n + 2] = off;
 }
 
@@ -132,11 +132,11 @@
 	BUFHEAD *bufp;
 	int ndx;
 {
-	__uint16_t *bp, newoff;
+	__uint_least16_t *bp, newoff;
 	int n;
-	__uint16_t pairlen;
+	__uint_least16_t pairlen;
 
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	n = bp[0];
 
 	if (bp[ndx + 1] < REAL_KEY)
@@ -167,7 +167,7 @@
 	}
 	/* Finally adjust the page data */
 	bp[n] = OFFSET(bp) + pairlen;
-	bp[n - 1] = bp[n + 1] + pairlen + 2 * sizeof(__uint16_t);
+	bp[n - 1] = bp[n + 1] + pairlen + 2 * sizeof(__uint_least16_t);
 	bp[0] = n - 2;
 	hashp->NKEYS--;
 
@@ -185,15 +185,15 @@
 	__uint32_t obucket, nbucket;
 {
 	BUFHEAD *new_bufp, *old_bufp;
-	__uint16_t *ino;
+	__uint_least16_t *ino;
 	char *np;
 	DBT key, val;
 	int n, ndx, retval;
-	__uint16_t copyto, diff, off, moved;
+	__uint_least16_t copyto, diff, off, moved;
 	char *op;
 
-	copyto = (__uint16_t)hashp->BSIZE;
-	off = (__uint16_t)hashp->BSIZE;
+	copyto = (__uint_least16_t)hashp->BSIZE;
+	off = (__uint_least16_t)hashp->BSIZE;
 	old_bufp = __get_buf(hashp, obucket, NULL, 0);
 	if (old_bufp == NULL)
 		return (-1);
@@ -204,7 +204,7 @@
 	old_bufp->flags |= (BUF_MOD | BUF_PIN);
 	new_bufp->flags |= (BUF_MOD | BUF_PIN);
 
-	ino = (__uint16_t *)(op = old_bufp->page);
+	ino = (__uint_least16_t *)(op = old_bufp->page);
 	np = new_bufp->page;
 
 	moved = 0;
@@ -246,13 +246,13 @@
 
 	/* Now clean up the page */
 	ino[0] -= moved;
-	FREESPACE(ino) = copyto - sizeof(__uint16_t) * (ino[0] + 3);
+	FREESPACE(ino) = copyto - sizeof(__uint_least16_t) * (ino[0] + 3);
 	OFFSET(ino) = copyto;
 
 #ifdef DEBUG3
 	(void)fprintf(stderr, "split %d/%d\n",
-	    ((__uint16_t *)np)[0] / 2,
-	    ((__uint16_t *)op)[0] / 2);
+	    ((__uint_least16_t *)np)[0] / 2,
+	    ((__uint_least16_t *)op)[0] / 2);
 #endif
 	/* unpin both pages */
 	old_bufp->flags &= ~BUF_PIN;
@@ -284,22 +284,22 @@
 	int moved;		/* Number of pairs moved to new page. */
 {
 	BUFHEAD *bufp;		/* Buffer header for ino */
-	__uint16_t *ino;		/* Page keys come off of */
-	__uint16_t *np;		/* New page */
-	__uint16_t *op;		/* Page keys go on to if they aren't moving */
+	__uint_least16_t *ino;		/* Page keys come off of */
+	__uint_least16_t *np;		/* New page */
+	__uint_least16_t *op;		/* Page keys go on to if they aren't moving */
 
 	BUFHEAD *last_bfp;	/* Last buf header OVFL needing to be freed */
 	DBT key, val;
 	SPLIT_RETURN ret;
-	__uint16_t n, off, ov_addr, scopyto;
+	__uint_least16_t n, off, ov_addr, scopyto;
 	char *cino;		/* Character value of ino */
 
 	bufp = old_bufp;
-	ino = (__uint16_t *)old_bufp->page;
-	np = (__uint16_t *)new_bufp->page;
-	op = (__uint16_t *)old_bufp->page;
+	ino = (__uint_least16_t *)old_bufp->page;
+	np = (__uint_least16_t *)new_bufp->page;
+	op = (__uint_least16_t *)old_bufp->page;
 	last_bfp = NULL;
-	scopyto = (__uint16_t)copyto;	/* ANSI */
+	scopyto = (__uint_least16_t)copyto;	/* ANSI */
 
 	n = ino[0] - 1;
 	while (n < ino[0]) {
@@ -310,16 +310,16 @@
 			old_bufp = ret.oldp;
 			if (!old_bufp)
 				return (-1);
-			op = (__uint16_t *)old_bufp->page;
+			op = (__uint_least16_t *)old_bufp->page;
 			new_bufp = ret.newp;
 			if (!new_bufp)
 				return (-1);
-			np = (__uint16_t *)new_bufp->page;
+			np = (__uint_least16_t *)new_bufp->page;
 			bufp = ret.nextp;
 			if (!bufp)
 				return (0);
 			cino = (char *)bufp->page;
-			ino = (__uint16_t *)cino;
+			ino = (__uint_least16_t *)cino;
 			last_bfp = ret.nextp;
 		} else if (ino[n + 1] == OVFLPAGE) {
 			ov_addr = ino[n];
@@ -329,14 +329,14 @@
 			 */
 			ino[0] -= (moved + 2);
 			FREESPACE(ino) =
-			    scopyto - sizeof(__uint16_t) * (ino[0] + 3);
+			    scopyto - sizeof(__uint_least16_t) * (ino[0] + 3);
 			OFFSET(ino) = scopyto;
 
 			bufp = __get_buf(hashp, ov_addr, bufp, 0);
 			if (!bufp)
 				return (-1);
 
-			ino = (__uint16_t *)bufp->page;
+			ino = (__uint_least16_t *)bufp->page;
 			n = 1;
 			scopyto = hashp->BSIZE;
 			moved = 0;
@@ -364,7 +364,7 @@
 					    __add_ovflpage(hashp, old_bufp);
 					if (!old_bufp)
 						return (-1);
-					op = (__uint16_t *)old_bufp->page;
+					op = (__uint_least16_t *)old_bufp->page;
 					putpair((char *)op, &key, &val);
 				}
 				old_bufp->flags |= BUF_MOD;
@@ -377,7 +377,7 @@
 					    __add_ovflpage(hashp, new_bufp);
 					if (!new_bufp)
 						return (-1);
-					np = (__uint16_t *)new_bufp->page;
+					np = (__uint_least16_t *)new_bufp->page;
 					putpair((char *)np, &key, &val);
 				}
 				new_bufp->flags |= BUF_MOD;
@@ -402,10 +402,10 @@
 	BUFHEAD *bufp;
 	const DBT *key, *val;
 {
-	__uint16_t *bp, *sop;
+	__uint_least16_t *bp, *sop;
 	int do_expand;
 
-	bp = (__uint16_t *)bufp->page;
+	bp = (__uint_least16_t *)bufp->page;
 	do_expand = 0;
 	while (bp[0] && (bp[2] < REAL_KEY || bp[bp[0]] < REAL_KEY))
 		/* Exception case */
@@ -417,7 +417,7 @@
 			bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 			if (!bufp)
 				return (-1);
-			bp = (__uint16_t *)bufp->page;
+			bp = (__uint_least16_t *)bufp->page;
 		} else
 			/* Try to squeeze key on this page */
 			if (FREESPACE(bp) > PAIRSIZE(key, val)) {
@@ -427,7 +427,7 @@
 				bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
 				if (!bufp)
 					return (-1);
-				bp = (__uint16_t *)bufp->page;
+				bp = (__uint_least16_t *)bufp->page;
 			}
 
 	if (PAIRFITS(bp, key, val))
@@ -437,7 +437,7 @@
 		bufp = __add_ovflpage(hashp, bufp);
 		if (!bufp)
 			return (-1);
-		sop = (__uint16_t *)bufp->page;
+		sop = (__uint_least16_t *)bufp->page;
 
 		if (PAIRFITS(sop, key, val))
 			putpair((char *)sop, key, val);
@@ -468,12 +468,12 @@
 	HTAB *hashp;
 	BUFHEAD *bufp;
 {
-	__uint16_t *sp;
-	__uint16_t ndx, ovfl_num;
+	__uint_least16_t *sp;
+	__uint_least16_t ndx, ovfl_num;
 #ifdef DEBUG1
 	int tmp1, tmp2;
 #endif
-	sp = (__uint16_t *)bufp->page;
+	sp = (__uint_least16_t *)bufp->page;
 
 	/* Check if we are dynamically determining the fill factor */
 	if (hashp->FFACTOR == DEF_FFACTOR) {
@@ -525,7 +525,7 @@
 {
 	int fd, page, size;
 	int rsize;
-	__uint16_t *bp;
+	__uint_least16_t *bp;
 
 	fd = hashp->fp;
 	size = hashp->BSIZE;
@@ -541,7 +541,7 @@
 	if ((lseek(fd, (off_t)page << hashp->BSHIFT, SEEK_SET) == -1) ||
 	    ((rsize = read(fd, p, size)) == -1))
 		return (-1);
-	bp = (__uint16_t *)p;
+	bp = (__uint_least16_t *)p;
 	if (!rsize)
 		bp[0] = 0;	/* We hit the EOF, so initialize a new page */
 	else
@@ -600,9 +600,9 @@
 			for (i = 0; i < max; i++)
 				M_32_SWAP(((int *)p)[i]);
 		} else {
-			max = ((__uint16_t *)p)[0] + 2;
+			max = ((__uint_least16_t *)p)[0] + 2;
 			for (i = 0; i <= max; i++)
-				M_16_SWAP(((__uint16_t *)p)[i]);
+				M_16_SWAP(((__uint_least16_t *)p)[i]);
 		}
 	}
 	if (is_bucket)
@@ -643,7 +643,7 @@
 	    hashp->BSIZE - clearbytes);
 	ip[clearints - 1] = ALL_SET << (nbits & BYTE_MASK);
 	SETBIT(ip, 0);
-	hashp->BITMAPS[ndx] = (__uint16_t)pnum;
+	hashp->BITMAPS[ndx] = (__uint_least16_t)pnum;
 	hashp->mapp[ndx] = ip;
 	return (0);
 }
@@ -663,13 +663,13 @@
 	return (i);
 }
 
-static __uint16_t
+static __uint_least16_t
 overflow_page(hashp)
 	HTAB *hashp;
 {
 	__uint32_t *freep;
 	int max_free, offset, splitnum;
-	__uint16_t addr;
+	__uint_least16_t addr;
 	int bit, first_page, free_bit, free_page, i, in_use_bits, j;
 #ifdef DEBUG2
 	int tmp1, tmp2;
@@ -816,16 +816,16 @@
 	HTAB *hashp;
 	BUFHEAD *obufp;
 {
-	__uint16_t addr;
+	__uint_least16_t addr;
 	__uint32_t *freep;
 	int bit_address, free_page, free_bit;
-	__uint16_t ndx;
+	__uint_least16_t ndx;
 
 	addr = obufp->addr;
 #ifdef DEBUG1
 	(void)fprintf(stderr, "Freeing %d\n", addr);
 #endif
-	ndx = (((__uint16_t)addr) >> SPLITSHIFT);
+	ndx = (((__uint_least16_t)addr) >> SPLITSHIFT);
 	bit_address =
 	    (ndx ? hashp->SPARES[ndx - 1] : 0) + (addr & SPLITMASK) - 1;
 	 if (bit_address < hashp->LAST_FREED)
@@ -883,11 +883,11 @@
  */
 static void
 squeeze_key(sp, key, val)
-	__uint16_t *sp;
+	__uint_least16_t *sp;
 	const DBT *key, *val;
 {
 	char *p;
-	__uint16_t free_space, n, off, pageno;
+	__uint_least16_t free_space, n, off, pageno;
 
 	p = (char *)sp;
 	n = sp[0];
diff -uNr newlib-1.15.0.orig/newlib/libc/search/page.h newlib-1.15.0/newlib/libc/search/page.h
--- newlib-1.15.0.orig/newlib/libc/search/page.h	2002-06-20 21:51:31.000000000 +0200
+++ newlib-1.15.0/newlib/libc/search/page.h	2007-01-12 11:31:17.000000000 +0100
@@ -74,20 +74,20 @@
  * You might as well do this up front.
  */
 
-#define	PAIRSIZE(K,D)	(2*sizeof(__uint16_t) + (K)->size + (D)->size)
-#define BIGOVERHEAD	(4*sizeof(__uint16_t))
-#define KEYSIZE(K)	(4*sizeof(__uint16_t) + (K)->size);
-#define OVFLSIZE	(2*sizeof(__uint16_t))
+#define	PAIRSIZE(K,D)	(2*sizeof(__uint_least16_t) + (K)->size + (D)->size)
+#define BIGOVERHEAD	(4*sizeof(__uint_least16_t))
+#define KEYSIZE(K)	(4*sizeof(__uint_least16_t) + (K)->size);
+#define OVFLSIZE	(2*sizeof(__uint_least16_t))
 #define FREESPACE(P)	((P)[(P)[0]+1])
 #define	OFFSET(P)	((P)[(P)[0]+2])
 #define PAIRFITS(P,K,D) \
 	(((P)[2] >= REAL_KEY) && \
 	    (PAIRSIZE((K),(D)) + OVFLSIZE) <= FREESPACE((P)))
-#define PAGE_META(N)	(((N)+3) * sizeof(__uint16_t))
+#define PAGE_META(N)	(((N)+3) * sizeof(__uint_least16_t))
 
 typedef struct {
 	BUFHEAD *newp;
 	BUFHEAD *oldp;
 	BUFHEAD *nextp;
-	__uint16_t next_addr;
+	__uint_least16_t next_addr;
 }       SPLIT_RETURN;
