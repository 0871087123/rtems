diff -Naur gdb-6.8.50.20090329.orig/bfd/sysdep.h gdb-6.8.50.20090329/bfd/sysdep.h
--- gdb-6.8.50.20090329.orig/bfd/sysdep.h	2007-07-03 16:26:42.000000000 +0200
+++ gdb-6.8.50.20090329/bfd/sysdep.h	2009-04-17 15:30:42.000000000 +0200
@@ -136,7 +136,7 @@
 #endif
 
 #if !HAVE_DECL_STRSTR
-extern char *strstr ();
+/* extern char *strstr (); */
 #endif
 
 #ifdef HAVE_FTELLO
diff -Naur gdb-6.8.50.20090329.orig/gdb/configure.tgt gdb-6.8.50.20090329/gdb/configure.tgt
--- gdb-6.8.50.20090329.orig/gdb/configure.tgt	2009-03-16 16:04:14.000000000 +0100
+++ gdb-6.8.50.20090329/gdb/configure.tgt	2009-04-17 15:30:42.000000000 +0200
@@ -231,6 +231,15 @@
 	gdb_sim=../sim/iq2000/libsim.a
 	;;
 
+lm32*-*-uclinux*)		
+        gdb_target_obs="lm32-tdep.o lm32-linux-tdep.o" 
+	gdb_sim=../sim/lm32/libsim.a
+	build_gdbserver=yes
+	;;
+lm32*-*-*)		
+        gdb_target_obs="lm32-tdep.o" 
+	gdb_sim=../sim/lm32/libsim.a
+	;;
 m32c-*-*)
 	# Target: Renesas M32C family
 	gdb_target_obs="m32c-tdep.o prologue-value.o"
diff -Naur gdb-6.8.50.20090329.orig/gdb/lm32-linux-tdep.c gdb-6.8.50.20090329/gdb/lm32-linux-tdep.c
--- gdb-6.8.50.20090329.orig/gdb/lm32-linux-tdep.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/gdb/lm32-linux-tdep.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,772 @@
+/* Target-dependent code for GNU/Linux running on the  Lattice Mico32.
+	 
+   Copyright (C) 2008 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "gdbcore.h"
+#include "target.h"
+#include "frame.h"
+#include "osabi.h"
+#include "elf-bfd.h"
+#include "frame-unwind.h"
+#include "regset.h"
+#include "gdb_string.h"
+#include "frame-base.h"
+#include "inferior.h"
+#include "dis-asm.h"   
+#include "symfile.h"
+#include "remote.h"
+#include "arch-utils.h"
+#include "regcache.h"
+#include "trad-frame.h"
+#include "reggroups.h"
+
+#include "elf/lm32.h"
+#include "lm32-linux-tdep.h"
+#include "../opcodes/lm32-desc.h"
+
+#include <signal.h>
+#include <string.h>
+
+int lm32_software_single_step (struct frame_info *frame);
+
+/* Define the size (in bytes) of an lm32 instruction.  */
+static const int lm32_instr_size = 4;
+
+enum {
+  NORMAL_SIGTRAMP = 1,
+  /* RT_SIGTRAMP = 2 */
+};
+
+#define LM32_ELF_NGREG 32
+typedef unsigned char lm32_elf_greg_t[4];
+typedef struct { lm32_elf_greg_t reg[LM32_ELF_NGREG]; } lm32_elf_gregset_t;
+
+/* Macros to extract fields from an instruction */
+#define LM32_OPCODE(insn)       ((insn >> 26) & 0x3f)
+#define LM32_REG0(insn)         ((insn >> 21) & 0x1f)
+#define LM32_REG1(insn)         ((insn >> 16) & 0x1f)
+#define LM32_REG2(insn)         ((insn >> 11) & 0x1f)
+#define LM32_UIMM16(insn)       (insn & 0xffff)
+#define LM32_IMM16(insn)        ((((long)insn & 0xffff) << 16) >> 16)
+#define LM32_IMM26(insn)        ((((long)insn & 0x3ffffff) << 6) >> 6)
+
+struct gdbarch_tdep
+{
+  /* gdbarch target dependent data here. Currently unused for LM32. */
+};
+
+struct lm32_unwind_cache
+{
+  /* The previous frame's inner most stack address.  Used as this
+     frame ID's stack_addr.  */
+  CORE_ADDR prev_sp;
+  /* The frame's base.  Used when constructing a frame ID.  */
+  CORE_ADDR base;
+  /* Size of frame */
+  int size;
+  /* Whether the function uses fp as a frame pointer */
+  int uses_fp;
+  /* Table indicating the location of each and every register.  */
+  struct trad_frame_saved_reg *saved_regs;
+};
+
+static int
+lm32_linux_pc_in_sigtramp (CORE_ADDR pc, char *name)
+{
+  char buf[lm32_instr_size];
+  LONGEST instr;
+  int retval = 0;
+
+  if (target_read_memory (pc, buf, sizeof buf) != 0)
+    return 0;
+
+  instr = extract_unsigned_integer (buf, sizeof buf);
+
+  if (instr == 0x34080077)	/* mvi  r8, __NR_sigreturn = addi  r8, r0, __NR_sigreturn */
+    retval = NORMAL_SIGTRAMP;
+  else
+    return 0;
+
+  if (target_read_memory (pc + lm32_instr_size, buf, sizeof buf) != 0)
+    return 0;
+  instr = extract_unsigned_integer (buf, sizeof buf);
+  if (instr != 0xac000007)	/* scall */
+    return 0;
+
+  /* If we get this far, we'll return a non-zero value, this means NORMAL_SIGTRAMP */
+  return retval;
+}
+
+static void 
+lm32_linux_supply_gregset (const struct regset *regset,
+                          struct regcache *regcache,
+			  int regnum, const void *gregs, size_t len)
+{
+  int regi;
+  char zerobuf[MAX_REGISTER_SIZE];
+  const lm32_elf_gregset_t *gregsetp = gregs;
+
+	fprintf(stderr, "%s:%d\n", __FILE__, __LINE__);
+  memset (zerobuf, 0, MAX_REGISTER_SIZE);
+
+  regcache_raw_supply (regcache, LM32_R0_REGNUM, zerobuf);
+
+  for (regi = 1; regi <= 32; regi++)
+    {
+	regcache_raw_supply (regcache, regi, &gregsetp->reg[regi]);
+    }
+}
+
+static struct regset lm32_linux_gregset =
+{
+  NULL,
+  lm32_linux_supply_gregset
+};
+   
+static const struct regset *
+lm32_linux_regset_from_core_section (struct gdbarch *gdbarch,
+				    const char *sect_name, size_t sect_size)
+{
+  if (strcmp (sect_name, ".reg") == 0 
+      && sect_size >= sizeof (lm32_elf_gregset_t))
+    return &lm32_linux_gregset;
+
+  return NULL;
+}
+
+static void
+lm32_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  /* Set the sigtramp frame sniffer.  */
+  //frame_unwind_append_sniffer (gdbarch, lm32_linux_sigtramp_frame_sniffer); 
+  set_gdbarch_regset_from_core_section (gdbarch,
+                                        lm32_linux_regset_from_core_section);
+}
+
+static enum gdb_osabi
+lm32_linux_elf_osabi_sniffer (bfd *abfd)
+{
+  int elf_flags;
+
+  elf_flags = elf_elfheader (abfd)->e_flags;
+
+  if (elf_flags & EF_LM32_MACH)
+    return GDB_OSABI_LINUX;
+	else
+    return GDB_OSABI_UNKNOWN;
+}
+/* Add the available register groups */
+
+static void
+lm32_add_reggroups (struct gdbarch *gdbarch)
+{
+  reggroup_add (gdbarch, general_reggroup);
+  reggroup_add (gdbarch, all_reggroup);
+  reggroup_add (gdbarch, system_reggroup);    
+}
+
+/* Return whether a given register is in a given group */
+
+static int 
+lm32_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
+                             struct reggroup *group)
+{
+  if (group == general_reggroup) 
+    {
+      return    ((regnum >= LM32_R0_REGNUM) && (regnum <= LM32_RA_REGNUM))
+             || (regnum == LM32_PC_REGNUM);
+    }
+  else if (group == system_reggroup) 
+    {
+      return (   (regnum >= LM32_EA_REGNUM)
+              && (regnum <= LM32_BA_REGNUM)
+             );
+    } 
+  return default_register_reggroup_p (gdbarch, regnum, group);
+}                        
+
+/* Return a name that corresponds to the given register number */
+
+static const char *
+lm32_register_name (struct gdbarch *gdbarch, int reg_nr)
+{
+  static char *register_names[] = 
+  {
+    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
+    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15", 
+    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23", 
+    "r24", "r25", "gp",  "fp",  "sp",  "ra",  "ea",  "ba",
+    "PC", "EID", "EBA", "DEBA", "IE"
+  };
+  
+  if ((reg_nr < 0) || (reg_nr >= sizeof (register_names) / sizeof (register_names[0])))
+    return NULL;
+  else
+    return register_names[reg_nr];
+}
+
+/* Return type of register */
+
+static struct type *
+lm32_register_type (struct gdbarch *gdbarch, int reg_nr)
+{
+  return builtin_type_int32;
+}
+
+/* Return non-zero if a register can't be written */
+
+static int
+lm32_cannot_store_register (struct gdbarch *gdbarch, int regno)
+{
+  return (regno == LM32_R0_REGNUM);
+}
+
+/* Parse a functions prologue */
+
+static CORE_ADDR
+lm32_parse_prologue (CORE_ADDR pc)
+{
+  CORE_ADDR prologue_pc;
+  unsigned long instruction;
+  int done;
+  int op;
+  int i;
+  int literal;
+
+  /* Keep reading though instructions, until we come accross an instruction 
+     that isn't likely to be part of the prologue */
+  prologue_pc = pc;
+  done = 0; 
+  while (!done) 
+    {         
+            
+      /* Read an instruction */   
+      instruction = read_memory_integer (prologue_pc, 4);
+      prologue_pc += 4;           
+
+      if (   (LM32_OPCODE(instruction) == OP_SW) 
+          && (LM32_REG0(instruction) == LM32_SP_REGNUM))
+        {
+          /* Any stack displaced store is likely part of the prologue */
+          pc = prologue_pc;
+        }
+      else if (   (LM32_OPCODE(instruction) == OP_ADDI) 
+               && (LM32_REG1(instruction) == LM32_SP_REGNUM))
+        {
+          /* An add to the SP is likely to be part of the prologue */
+          pc = prologue_pc;
+        }
+      else if (   /* add fp,fp,sp */
+                  (   (LM32_OPCODE(instruction) == OP_ADD) 
+                   && (LM32_REG2(instruction) == LM32_FP_REGNUM) 
+                   && (LM32_REG0(instruction) == LM32_FP_REGNUM)
+                   && (LM32_REG1(instruction) == LM32_SP_REGNUM)
+                  )
+                  /* mv fp,imm */
+               || (   (LM32_OPCODE(instruction) == OP_ADDI) 
+                   && (LM32_REG1(instruction) == LM32_FP_REGNUM) 
+                   && (LM32_REG0(instruction) == LM32_R0_REGNUM)
+                  )
+              )
+        {
+          /* Likely to be in the prologue for functions that require 
+             a frame pointer.  */
+          pc = prologue_pc;
+        }
+      else
+        done = 1;            
+    } 
+
+  return pc;
+}
+
+/* Return PC of first non prologue instruction, for the function at the 
+   specified address.  */
+
+static CORE_ADDR
+lm32_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+  CORE_ADDR func_addr, func_end;
+  struct symtab_and_line sal;
+
+  /* If we have line debugging information, then the end of the 
+     prologue should the first assembly instruction of the first source line */
+  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
+    {
+      sal = find_pc_line (func_addr, 0);
+      if (sal.end && sal.end < func_end) 
+        return sal.end;        
+    }
+  
+  return lm32_parse_prologue (pc);
+}
+
+/* Create a breakpoint instruction */
+
+static const unsigned char *
+lm32_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
+{
+  static const unsigned char breakpoint[4] = {OP_RAISE << 2, 0, 0, 2};
+  *lenptr = sizeof (breakpoint);
+  return breakpoint;
+}
+
+/* Setup registers and stack for faking a call to a function in the inferior */
+
+static CORE_ADDR
+lm32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
+		       struct regcache *regcache, CORE_ADDR bp_addr,
+		       int nargs, struct value **args, CORE_ADDR sp,
+		       int struct_return, CORE_ADDR struct_addr)
+{
+  int first_arg_reg = LM32_R1_REGNUM;
+  int num_arg_regs = 8;  
+  int i;
+  
+  /* Set the return address */
+  regcache_cooked_write_signed (regcache, LM32_RA_REGNUM, bp_addr);
+    
+  /* If we're returning a large struct, a pointer to the address to
+     store it at is passed as a first hidden parameter */
+  if (struct_return)
+    {
+      regcache_cooked_write_unsigned (regcache, first_arg_reg, struct_addr); 
+      first_arg_reg++;
+      num_arg_regs--;
+      sp -= 4;
+    }       
+    
+  /* Setup parameters */
+  for (i = 0; i < nargs; i++)
+    {
+      struct value *arg = args[i];
+      struct type *arg_type = check_typedef (value_type (arg));
+      char *contents;
+      int len;
+      int j;
+      int reg;
+      ULONGEST val;
+      
+      /* Promote small integer types to int */
+      switch (TYPE_CODE (arg_type))
+    	{
+    	case TYPE_CODE_INT:
+    	case TYPE_CODE_BOOL:
+    	case TYPE_CODE_CHAR:
+    	case TYPE_CODE_RANGE:
+    	case TYPE_CODE_ENUM:
+    	  if (TYPE_LENGTH (arg_type) < 4)
+    	    {
+	          arg_type = builtin_type_int32;
+	          arg = value_cast (arg_type, arg);
+    	    }
+    	  break;
+        }  
+
+      /* FIXME: Handle structures */  
+                
+      contents = (char *) value_contents (arg);        
+      len = TYPE_LENGTH (arg_type);
+      val = extract_unsigned_integer (contents, len);
+      
+      /* First num_arg_regs parameters go in registers, rest go on stack */
+      if (i < num_arg_regs)    
+        {
+          regcache_cooked_write_unsigned (regcache, first_arg_reg + i, val);
+        }
+      else 
+        {
+          write_memory (sp, (void *)&val, len);
+          sp -= 4;
+        }        
+    }
+    
+  /* Update stack pointer */
+  regcache_cooked_write_signed (regcache, LM32_SP_REGNUM, sp);
+        
+  /* Return adjusted stack pointer.  */
+  return sp;   
+}
+
+/* Extract return value after calling a function in the inferior */
+
+static void
+lm32_extract_return_value (struct type *type, struct regcache *regcache, 
+                           gdb_byte *valbuf)
+{
+  int offset;
+  ULONGEST l;
+  CORE_ADDR return_buffer;
+      
+  if (   TYPE_CODE(type) != TYPE_CODE_STRUCT
+      && TYPE_CODE(type) != TYPE_CODE_UNION
+      && TYPE_CODE(type) != TYPE_CODE_ARRAY
+      && TYPE_LENGTH (type) <= 4
+     )
+    {
+      /* Return value is returned in a single register */
+      regcache_cooked_read_unsigned (regcache, LM32_R1_REGNUM, &l);
+      store_unsigned_integer (valbuf, TYPE_LENGTH (type), l);
+    }
+  else if (   (TYPE_CODE(type) == TYPE_CODE_INT)
+           && (TYPE_LENGTH (type) == 8)
+          )
+    {
+      /* 64-bit values are returned in a register pair */
+      regcache_cooked_read_unsigned (regcache, LM32_R1_REGNUM, &l);
+      memcpy (valbuf, &l, 4);
+      regcache_cooked_read_unsigned (regcache, LM32_R2_REGNUM, &l);
+      memcpy (valbuf + 4, &l, 4);
+    }
+  else
+    {
+      /* Aggregate types greater than a single register are returned in memory: 
+         FIXME: Unless they are only 2 regs?.  */
+      regcache_cooked_read_unsigned (regcache, LM32_R1_REGNUM, &l);
+      return_buffer = l;
+      read_memory (return_buffer, valbuf, TYPE_LENGTH (type));
+    }    
+}
+
+/* Write into appropriate registers a function return value of type
+   TYPE, given in virtual format.  */
+static void
+lm32_store_return_value (struct type *type, struct regcache *regcache,
+			const gdb_byte *valbuf)
+{
+  ULONGEST val;
+  int len = TYPE_LENGTH (type);
+
+  if (len <= 4)
+    {
+      val = extract_unsigned_integer (valbuf, len);
+      regcache_cooked_write_unsigned (regcache, LM32_R1_REGNUM, val);
+    }
+  else if (len <= 8)
+    {
+      val = extract_unsigned_integer (valbuf, 4);
+      regcache_cooked_write_unsigned (regcache, LM32_R1_REGNUM, val);
+      val = extract_unsigned_integer ((char *)valbuf + 4, len - 4);
+      regcache_cooked_write_unsigned (regcache, LM32_R2_REGNUM, val);
+    }
+  else
+    error (_("lm32_store_return_value: type length too large."));
+}
+
+/* Determine whether a functions return value is in a register or memory */
+static enum return_value_convention
+lm32_return_value (struct gdbarch *gdbarch, struct type *func_type,
+		    struct type *valtype, struct regcache *regcache, 
+                    gdb_byte *readbuf, const gdb_byte *writebuf)
+{
+  enum type_code code = TYPE_CODE (valtype);
+
+  if ((code == TYPE_CODE_STRUCT
+       || code == TYPE_CODE_UNION
+       || code == TYPE_CODE_ARRAY
+       || TYPE_LENGTH (valtype) > 8))
+    return RETURN_VALUE_STRUCT_CONVENTION;
+
+  if (readbuf)
+    lm32_extract_return_value (valtype, regcache, readbuf);
+  if (writebuf)
+    lm32_store_return_value (valtype, regcache, writebuf);
+
+  return RETURN_VALUE_REGISTER_CONVENTION;
+}
+
+static CORE_ADDR
+lm32_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  return frame_unwind_register_unsigned (next_frame, LM32_PC_REGNUM);
+}
+
+static CORE_ADDR
+lm32_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  return frame_unwind_register_unsigned (next_frame, LM32_SP_REGNUM);
+}
+
+static struct frame_id
+lm32_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
+{
+  CORE_ADDR sp = lm32_unwind_sp (gdbarch, this_frame);
+  return frame_id_build (sp, get_frame_pc (this_frame));
+}
+
+struct lm32_unwind_cache *
+lm32_frame_unwind_cache (struct frame_info *this_frame, 
+                         void **this_prologue_cache)
+{
+  CORE_ADDR start_pc;
+  CORE_ADDR prologue_pc;
+  CORE_ADDR current_pc;
+  ULONGEST prev_sp;
+  ULONGEST this_base;
+  struct lm32_unwind_cache *info;
+  int done;
+  int prefixed;
+  unsigned long instruction;
+  int op;
+  int offsets[32];
+  int i;
+  long immediate;
+  int ra_on_stack;
+
+  if ((*this_prologue_cache))
+    return (*this_prologue_cache);
+
+  info = FRAME_OBSTACK_ZALLOC (struct lm32_unwind_cache);
+  (*this_prologue_cache) = info;
+  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);
+
+  info->size = 0;
+  info->uses_fp = 0;
+  
+  start_pc = get_frame_func (this_frame);
+  current_pc = get_frame_pc (this_frame);
+
+  /* Keep reading through instructions, until we come accross an instruction 
+     that isn't likely to be part of the prologue */
+  prologue_pc = start_pc;
+  ra_on_stack = 0;
+  done = 0;
+  
+  while (!done && (current_pc > prologue_pc)) 
+    {         
+            
+      /* Read an instruction */   
+      instruction = read_memory_integer (prologue_pc, 4);
+
+      if (   (LM32_OPCODE(instruction) == OP_SW) 
+          && (LM32_REG0(instruction) == LM32_SP_REGNUM))      
+        {
+          /* Any stack displaced store is likely part of the prologue.  
+             Record that the register is being saved, and the offset 
+             into the stack.  */
+          info->saved_regs[LM32_REG1(instruction)].addr = LM32_IMM16(instruction);
+          /* Check to see if the return address register is 
+             being stored on the stack.  */
+          if (   (LM32_REG1(instruction) == LM32_RA_REGNUM) 
+              && (current_pc > prologue_pc))
+            ra_on_stack = 1;
+        }
+      else if (   (LM32_OPCODE(instruction) == OP_ADDI) 
+               && (LM32_REG1(instruction) == LM32_SP_REGNUM))     
+        {
+          /* An add to the SP is likely to be part of the prologue.  
+             Adjust stack size by whatever the instruction adds to the sp.  */
+          info->size -= LM32_IMM16(instruction);
+        }
+      else if (   /* add fp,fp,sp */
+                  (   (LM32_OPCODE(instruction) == OP_ADD) 
+                   && (LM32_REG2(instruction) == LM32_FP_REGNUM) 
+                   && (LM32_REG0(instruction) == LM32_FP_REGNUM)
+                   && (LM32_REG1(instruction) == LM32_SP_REGNUM)
+                  )
+                  /* mv fp,imm */
+               || (   (LM32_OPCODE(instruction) == OP_ADDI) 
+                   && (LM32_REG1(instruction) == LM32_FP_REGNUM) 
+                   && (LM32_REG0(instruction) == LM32_R0_REGNUM)
+                  )
+              )
+        {
+          /* Used in functions with a frame pointer.  */          
+          info->uses_fp = 1;
+        }
+      else
+        {
+          /* Any other instruction is likely not to be part of the prologue */
+          done = 1;            
+        }
+
+      prologue_pc += 4;           
+        
+    } 
+    
+  /* Compute the frame's base, and the previous frame's SP.  */
+  this_base = get_frame_register_unsigned (this_frame, LM32_SP_REGNUM);   
+  prev_sp = this_base + info->size;
+  info->base = this_base;
+  info->prev_sp = prev_sp;
+
+  /* Convert callee save offsets into addresses */
+  for (i = 0; i < gdbarch_num_regs (get_frame_arch (this_frame)) - 1; i++)
+    {
+      if (trad_frame_addr_p (info->saved_regs, i))
+        info->saved_regs[i].addr = this_base + info->saved_regs[i].addr;
+    }
+
+  /* The call instruction moves the caller's PC in the callee's RA register.
+     Since this is an unwind, do the reverse.  Copy the location of RA register
+     into PC (the address / regnum) so that a request for PC will be
+     converted into a request for the RA register.  */
+  info->saved_regs[LM32_PC_REGNUM] = info->saved_regs[LM32_RA_REGNUM];
+    
+  /* The previous frame's SP needed to be computed.  Save the computed value. */
+  trad_frame_set_value (info->saved_regs, LM32_SP_REGNUM, info->prev_sp);
+
+  return info;
+}  
+
+/* Given a GDB frame, determine the address of the calling function's
+   frame.  This will be used to create a new GDB frame struct.  */
+
+static void
+lm32_frame_this_id (struct frame_info *this_frame,
+                      void **this_prologue_cache,
+                      struct frame_id *this_id)
+{
+  struct lm32_unwind_cache *info;
+  CORE_ADDR base;
+  CORE_ADDR func;
+  struct frame_id id;
+
+  info = lm32_frame_unwind_cache (this_frame, this_prologue_cache);
+  
+  /* The FUNC is easy.  */
+  func = get_frame_func (this_frame);
+    
+  /* Hopefully the prologue analysis either correctly determined the
+     frame's base (which is the SP from the previous frame), or set
+     that base to "NULL".  */
+  base = info->base; 
+  if (base == 0)
+    return;
+    
+  id = frame_id_build (base, func);
+  (*this_id) = id;  
+}
+
+static struct value *
+lm32_frame_prev_register (struct frame_info *this_frame,
+                            void **this_prologue_cache,
+                            int regnum)
+{
+  struct lm32_unwind_cache *info;
+  info = lm32_frame_unwind_cache (this_frame, this_prologue_cache);
+  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
+}
+
+static const struct frame_unwind lm32_frame_unwind = {
+  NORMAL_FRAME,
+  lm32_frame_this_id,
+  lm32_frame_prev_register,
+  NULL,
+  default_frame_sniffer
+};
+
+static CORE_ADDR
+lm32_frame_base_address (struct frame_info *this_frame, void **this_cache)
+{
+  struct lm32_unwind_cache *info
+    = lm32_frame_unwind_cache (this_frame, this_cache);
+
+  return info->base;
+}
+
+static const struct frame_base lm32_frame_base = {
+  &lm32_frame_unwind,
+  lm32_frame_base_address,
+  lm32_frame_base_address,
+  lm32_frame_base_address
+};
+
+static CORE_ADDR
+lm32_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
+{
+  /* Align to the size of an instruction (so that they can safely be
+     pushed onto the stack.  */
+  return sp & ~3;
+}
+
+static struct gdbarch *
+lm32_gdbarch_init (struct gdbarch_info info,  struct gdbarch_list *arches)
+{
+  struct gdbarch *gdbarch;
+  struct gdbarch_tdep *tdep;
+
+  /* If there is already a candidate, use it.  */
+  arches = gdbarch_list_lookup_by_info (arches, &info);
+  if (arches != NULL)
+    return arches->gdbarch;
+  
+  /* None found, create a new architecture from the information provided. */
+  tdep = XMALLOC (struct gdbarch_tdep);
+  gdbarch = gdbarch_alloc (&info, tdep);
+
+  /* Type sizes */
+  set_gdbarch_short_bit (gdbarch, 16);
+  set_gdbarch_int_bit (gdbarch, 32);
+  set_gdbarch_long_bit (gdbarch, 32);
+  set_gdbarch_long_long_bit (gdbarch, 64);
+  set_gdbarch_float_bit (gdbarch, 32);
+  set_gdbarch_double_bit (gdbarch, 64);
+  set_gdbarch_long_double_bit (gdbarch, 64);
+  set_gdbarch_ptr_bit (gdbarch, 32);
+  
+  /* Register info */
+  set_gdbarch_num_regs (gdbarch, LM32_NUM_REGS);
+  set_gdbarch_sp_regnum (gdbarch, LM32_SP_REGNUM);
+  set_gdbarch_pc_regnum (gdbarch, LM32_PC_REGNUM);  
+  set_gdbarch_register_name (gdbarch, lm32_register_name);
+  set_gdbarch_register_type (gdbarch, lm32_register_type);
+  set_gdbarch_cannot_store_register (gdbarch, lm32_cannot_store_register);
+
+  /* Frame info */
+  set_gdbarch_skip_prologue (gdbarch, lm32_skip_prologue);
+  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
+  set_gdbarch_decr_pc_after_break (gdbarch, 0);
+  set_gdbarch_frame_args_skip (gdbarch, 0);
+  
+  /* Frame unwinding */  
+  set_gdbarch_frame_align (gdbarch, lm32_frame_align);
+  frame_base_set_default (gdbarch, &lm32_frame_base);
+  set_gdbarch_unwind_pc (gdbarch, lm32_unwind_pc);
+  set_gdbarch_unwind_sp (gdbarch, lm32_unwind_sp);
+  set_gdbarch_dummy_id (gdbarch, lm32_dummy_id);
+  frame_unwind_append_unwinder (gdbarch, &lm32_frame_unwind);
+  
+  /* Breakpoints */
+  set_gdbarch_breakpoint_from_pc (gdbarch, lm32_breakpoint_from_pc);
+  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);
+  set_gdbarch_software_single_step (gdbarch, lm32_software_single_step);
+  
+  /* Calling functions in the inferior */
+  set_gdbarch_push_dummy_call (gdbarch, lm32_push_dummy_call);
+  set_gdbarch_return_value (gdbarch, lm32_return_value);
+
+  /* Instruction disassembler */
+  set_gdbarch_print_insn (gdbarch, print_insn_lm32);
+
+  lm32_add_reggroups (gdbarch);
+  set_gdbarch_register_reggroup_p (gdbarch, lm32_register_reggroup_p);
+            
+  return gdbarch;
+}
+
+void 
+_initialize_lm32_tdep (void)
+{
+  register_gdbarch_init (bfd_arch_lm32, lm32_gdbarch_init);
+  gdbarch_register_osabi (bfd_arch_lm32, 0, GDB_OSABI_LINUX, lm32_linux_init_abi);
+  gdbarch_register_osabi_sniffer (bfd_arch_lm32,
+				  bfd_target_elf_flavour,
+				  lm32_linux_elf_osabi_sniffer);
+}
diff -Naur gdb-6.8.50.20090329.orig/gdb/lm32-linux-tdep.h gdb-6.8.50.20090329/gdb/lm32-linux-tdep.h
--- gdb-6.8.50.20090329.orig/gdb/lm32-linux-tdep.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/gdb/lm32-linux-tdep.h	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,68 @@
+/* Target-dependent code for GNU/Linux running on the LM32.
+
+   Copyright (C) 2008 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#ifndef LINUX_TDEP_LM32_H
+#define LINUX_TDEP_LM32_H
+
+enum lm32_linux_regs
+{
+  LM32_R0_REGNUM = 0,
+  LM32_R1_REGNUM,     
+  LM32_R2_REGNUM,     
+  LM32_R3_REGNUM,     
+  LM32_R4_REGNUM,     
+  LM32_R5_REGNUM,     
+  LM32_R6_REGNUM,     
+  LM32_R7_REGNUM,     
+  LM32_R8_REGNUM,     
+  LM32_R9_REGNUM,     
+  LM32_R10_REGNUM,    
+  LM32_R11_REGNUM,    
+  LM32_R12_REGNUM,    
+  LM32_R13_REGNUM,    
+  LM32_R14_REGNUM,    
+  LM32_R15_REGNUM,    
+  LM32_R16_REGNUM,    
+  LM32_R17_REGNUM,    
+  LM32_R18_REGNUM,    
+  LM32_R19_REGNUM,    
+  LM32_R20_REGNUM,    
+  LM32_R21_REGNUM,    
+  LM32_R22_REGNUM,    
+  LM32_R23_REGNUM,    
+  LM32_R24_REGNUM,    
+  LM32_R25_REGNUM,    
+  LM32_GP_REGNUM,     
+  LM32_FP_REGNUM,     
+  LM32_SP_REGNUM,     
+  LM32_RA_REGNUM,     
+  LM32_EA_REGNUM, /* 30 = 0x1e */    
+  LM32_BA_REGNUM,
+  LM32_PC_REGNUM,
+  LM32_NUM_REGS      
+};
+
+/* Fetch the executable load address for the PIC/FDPIC ABI.
+	 Return 0 if successful, -1 if not. */
+int lm32_load_address(struct gdbarch *gdbarch,
+		CORE_ADDR *load_addr);
+
+#endif
diff -Naur gdb-6.8.50.20090329.orig/gdb/lm32-tdep.c gdb-6.8.50.20090329/gdb/lm32-tdep.c
--- gdb-6.8.50.20090329.orig/gdb/lm32-tdep.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/gdb/lm32-tdep.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,677 @@
+/* Target-dependent code for Lattice Mico32 processor, for GDB.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+   Copyright (C) 2008 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "frame.h"
+#include "frame-unwind.h"
+#include "frame-base.h"
+#include "inferior.h"
+#include "dis-asm.h"   
+#include "symfile.h"
+#include "remote.h"
+#include "gdbcore.h"
+#include "gdb/sim-lm32.h"
+#include "gdb/callback.h"
+#include "gdb/remote-sim.h"
+#include "sim-regno.h"
+#include "arch-utils.h"
+#include "regcache.h"
+#include "trad-frame.h"
+#include "reggroups.h"
+#include "../opcodes/lm32-desc.h"
+
+#include <signal.h>
+#include <string.h>
+
+/* Macros to extract fields from an instruction */
+#define LM32_OPCODE(insn)       ((insn >> 26) & 0x3f)
+#define LM32_REG0(insn)         ((insn >> 21) & 0x1f)
+#define LM32_REG1(insn)         ((insn >> 16) & 0x1f)
+#define LM32_REG2(insn)         ((insn >> 11) & 0x1f)
+#define LM32_UIMM16(insn)       (insn & 0xffff)
+#define LM32_IMM16(insn)        ((((long)insn & 0xffff) << 16) >> 16)
+#define LM32_IMM26(insn)        ((((long)insn & 0x3ffffff) << 6) >> 6)
+
+struct gdbarch_tdep
+{
+  /* gdbarch target dependent data here. Currently unused for LM32. */
+};
+
+struct lm32_unwind_cache
+{
+  /* The previous frame's inner most stack address.  Used as this
+     frame ID's stack_addr.  */
+  CORE_ADDR prev_sp;
+  /* The frame's base.  Used when constructing a frame ID.  */
+  CORE_ADDR base;
+  /* Size of frame */
+  int size;
+  /* Whether the function uses fp as a frame pointer */
+  int uses_fp;
+  /* Table indicating the location of each and every register.  */
+  struct trad_frame_saved_reg *saved_regs;
+};
+
+/* Add the available register groups */
+
+static void
+lm32_add_reggroups (struct gdbarch *gdbarch)
+{
+  reggroup_add (gdbarch, general_reggroup);
+  reggroup_add (gdbarch, all_reggroup);
+  reggroup_add (gdbarch, system_reggroup);    
+}
+
+/* Return whether a given register is in a given group */
+
+static int 
+lm32_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
+                             struct reggroup *group)
+{
+  if (group == general_reggroup) 
+    {
+      return    ((regnum >= SIM_LM32_R0_REGNUM) && (regnum <= SIM_LM32_RA_REGNUM))
+             || (regnum == SIM_LM32_PC_REGNUM);
+    }
+  else if (group == system_reggroup) 
+    {
+      return (   (regnum >= SIM_LM32_EA_REGNUM)
+              && (regnum <= SIM_LM32_BA_REGNUM)
+             )
+          || (   (regnum >= SIM_LM32_EID_REGNUM)
+              && (regnum <= SIM_LM32_IE_REGNUM) 
+             )    
+             ;
+    } 
+  return default_register_reggroup_p (gdbarch, regnum, group);
+}                        
+
+/* Return a name that corresponds to the given register number */
+
+static const char *
+lm32_register_name (struct gdbarch *gdbarch, int reg_nr)
+{
+  static char *register_names[] = 
+  {
+    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
+    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15", 
+    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23", 
+    "r24", "r25", "gp",  "fp",  "sp",  "ra",  "ea",  "ba",
+    "PC", "EID", "EBA", "DEBA", "IE"
+  };
+  
+  if ((reg_nr < 0) || (reg_nr >= sizeof (register_names) / sizeof (register_names[0])))
+    return NULL;
+  else
+    return register_names[reg_nr];
+}
+
+/* Return type of register */
+
+static struct type *
+lm32_register_type (struct gdbarch *gdbarch, int reg_nr)
+{
+  return builtin_type_int32;
+}
+
+/* Return non-zero if a register can't be written */
+
+static int
+lm32_cannot_store_register (struct gdbarch *gdbarch, int regno)
+{
+  return (regno == SIM_LM32_R0_REGNUM) || (regno == SIM_LM32_EID_REGNUM);
+}
+
+/* Parse a functions prologue */
+
+static CORE_ADDR
+lm32_parse_prologue (CORE_ADDR pc)
+{
+  CORE_ADDR prologue_pc;
+  unsigned long instruction;
+  int done;
+  int op;
+  int i;
+  int literal;
+
+  /* Keep reading though instructions, until we come accross an instruction 
+     that isn't likely to be part of the prologue */
+  prologue_pc = pc;
+  done = 0; 
+  while (!done) 
+    {         
+            
+      /* Read an instruction */   
+      instruction = read_memory_integer (prologue_pc, 4);
+      prologue_pc += 4;           
+
+      if (   (LM32_OPCODE(instruction) == OP_SW) 
+          && (LM32_REG0(instruction) == SIM_LM32_SP_REGNUM))
+        {
+          /* Any stack displaced store is likely part of the prologue */
+          pc = prologue_pc;
+        }
+      else if (   (LM32_OPCODE(instruction) == OP_ADDI) 
+               && (LM32_REG1(instruction) == SIM_LM32_SP_REGNUM))
+        {
+          /* An add to the SP is likely to be part of the prologue */
+          pc = prologue_pc;
+        }
+      else if (   /* add fp,fp,sp */
+                  (   (LM32_OPCODE(instruction) == OP_ADD) 
+                   && (LM32_REG2(instruction) == SIM_LM32_FP_REGNUM) 
+                   && (LM32_REG0(instruction) == SIM_LM32_FP_REGNUM)
+                   && (LM32_REG1(instruction) == SIM_LM32_SP_REGNUM)
+                  )
+                  /* mv fp,imm */
+               || (   (LM32_OPCODE(instruction) == OP_ADDI) 
+                   && (LM32_REG1(instruction) == SIM_LM32_FP_REGNUM) 
+                   && (LM32_REG0(instruction) == SIM_LM32_R0_REGNUM)
+                  )
+              )
+        {
+          /* Likely to be in the prologue for functions that require 
+             a frame pointer.  */
+          pc = prologue_pc;
+        }
+      else
+        done = 1;            
+    } 
+
+  return pc;
+}
+
+/* Return PC of first non prologue instruction, for the function at the 
+   specified address.  */
+
+static CORE_ADDR
+lm32_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+  CORE_ADDR func_addr, func_end;
+  struct symtab_and_line sal;
+
+  /* If we have line debugging information, then the end of the 
+     prologue should the first assembly instruction of the first source line */
+  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
+    {
+      sal = find_pc_line (func_addr, 0);
+      if (sal.end && sal.end < func_end) 
+        return sal.end;        
+    }
+  
+  return lm32_parse_prologue (pc);
+}
+
+/* Create a breakpoint instruction */
+
+static const unsigned char *
+lm32_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
+{
+  static const unsigned char breakpoint[4] = {OP_RAISE << 2, 0, 0, 2};
+  *lenptr = sizeof (breakpoint);
+  return breakpoint;
+}
+
+/* Setup registers and stack for faking a call to a function in the inferior */
+
+static CORE_ADDR
+lm32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
+		       struct regcache *regcache, CORE_ADDR bp_addr,
+		       int nargs, struct value **args, CORE_ADDR sp,
+		       int struct_return, CORE_ADDR struct_addr)
+{
+  int first_arg_reg = SIM_LM32_R1_REGNUM;
+  int num_arg_regs = 8;  
+  int i;
+  
+  /* Set the return address */
+  regcache_cooked_write_signed (regcache, SIM_LM32_RA_REGNUM, bp_addr);
+    
+  /* If we're returning a large struct, a pointer to the address to
+     store it at is passed as a first hidden parameter */
+  if (struct_return)
+    {
+      regcache_cooked_write_unsigned (regcache, first_arg_reg, struct_addr); 
+      first_arg_reg++;
+      num_arg_regs--;
+      sp -= 4;
+    }       
+    
+  /* Setup parameters */
+  for (i = 0; i < nargs; i++)
+    {
+      struct value *arg = args[i];
+      struct type *arg_type = check_typedef (value_type (arg));
+      char *contents;
+      int len;
+      int j;
+      int reg;
+      ULONGEST val;
+      
+      /* Promote small integer types to int */
+      switch (TYPE_CODE (arg_type))
+    	{
+    	case TYPE_CODE_INT:
+    	case TYPE_CODE_BOOL:
+    	case TYPE_CODE_CHAR:
+    	case TYPE_CODE_RANGE:
+    	case TYPE_CODE_ENUM:
+    	  if (TYPE_LENGTH (arg_type) < 4)
+    	    {
+	          arg_type = builtin_type_int32;
+	          arg = value_cast (arg_type, arg);
+    	    }
+    	  break;
+        }  
+
+      /* FIXME: Handle structures */  
+                
+      contents = (char *) value_contents (arg);        
+      len = TYPE_LENGTH (arg_type);
+      val = extract_unsigned_integer (contents, len);
+      
+      /* First num_arg_regs parameters go in registers, rest go on stack */
+      if (i < num_arg_regs)    
+        {
+          regcache_cooked_write_unsigned (regcache, first_arg_reg + i, val);
+        }
+      else 
+        {
+          write_memory (sp, (void *)&val, len);
+          sp -= 4;
+        }        
+    }
+    
+  /* Update stack pointer */
+  regcache_cooked_write_signed (regcache, SIM_LM32_SP_REGNUM, sp);
+        
+  /* Return adjusted stack pointer.  */
+  return sp;   
+}
+
+/* Extract return value after calling a function in the inferior */
+
+static void
+lm32_extract_return_value (struct type *type, struct regcache *regcache, 
+                           gdb_byte *valbuf)
+{
+  int offset;
+  ULONGEST l;
+  CORE_ADDR return_buffer;
+      
+  if (   TYPE_CODE(type) != TYPE_CODE_STRUCT
+      && TYPE_CODE(type) != TYPE_CODE_UNION
+      && TYPE_CODE(type) != TYPE_CODE_ARRAY
+      && TYPE_LENGTH (type) <= 4
+     )
+    {
+      /* Return value is returned in a single register */
+      regcache_cooked_read_unsigned (regcache, SIM_LM32_R1_REGNUM, &l);
+      store_unsigned_integer (valbuf, TYPE_LENGTH (type), l);
+    }
+  else if (   (TYPE_CODE(type) == TYPE_CODE_INT)
+           && (TYPE_LENGTH (type) == 8)
+          )
+    {
+      /* 64-bit values are returned in a register pair */
+      regcache_cooked_read_unsigned (regcache, SIM_LM32_R1_REGNUM, &l);
+      memcpy (valbuf, &l, 4);
+      regcache_cooked_read_unsigned (regcache, SIM_LM32_R2_REGNUM, &l);
+      memcpy (valbuf + 4, &l, 4);
+    }
+  else
+    {
+      /* Aggregate types greater than a single register are returned in memory: 
+         FIXME: Unless they are only 2 regs?.  */
+      regcache_cooked_read_unsigned (regcache, SIM_LM32_R1_REGNUM, &l);
+      return_buffer = l;
+      read_memory (return_buffer, valbuf, TYPE_LENGTH (type));
+    }    
+}
+
+/* Write into appropriate registers a function return value of type
+   TYPE, given in virtual format.  */
+static void
+lm32_store_return_value (struct type *type, struct regcache *regcache,
+			const gdb_byte *valbuf)
+{
+  ULONGEST val;
+  int len = TYPE_LENGTH (type);
+
+  if (len <= 4)
+    {
+      val = extract_unsigned_integer (valbuf, len);
+      regcache_cooked_write_unsigned (regcache, SIM_LM32_R1_REGNUM, val);
+    }
+  else if (len <= 8)
+    {
+      val = extract_unsigned_integer (valbuf, 4);
+      regcache_cooked_write_unsigned (regcache, SIM_LM32_R1_REGNUM, val);
+      val = extract_unsigned_integer ((char *)valbuf + 4, len - 4);
+      regcache_cooked_write_unsigned (regcache, SIM_LM32_R2_REGNUM, val);
+    }
+  else
+    error (_("lm32_store_return_value: type length too large."));
+}
+
+/* Determine whether a functions return value is in a register or memory */
+static enum return_value_convention
+lm32_return_value (struct gdbarch *gdbarch, struct type *func_type,
+		    struct type *valtype, struct regcache *regcache, 
+                    gdb_byte *readbuf, const gdb_byte *writebuf)
+{
+  enum type_code code = TYPE_CODE (valtype);
+
+  if ((code == TYPE_CODE_STRUCT
+       || code == TYPE_CODE_UNION
+       || code == TYPE_CODE_ARRAY
+       || TYPE_LENGTH (valtype) > 8))
+    return RETURN_VALUE_STRUCT_CONVENTION;
+
+  if (readbuf)
+    lm32_extract_return_value (valtype, regcache, readbuf);
+  if (writebuf)
+    lm32_store_return_value (valtype, regcache, writebuf);
+
+  return RETURN_VALUE_REGISTER_CONVENTION;
+}
+
+static CORE_ADDR
+lm32_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  return frame_unwind_register_unsigned (next_frame, SIM_LM32_PC_REGNUM);
+}
+
+static CORE_ADDR
+lm32_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  return frame_unwind_register_unsigned (next_frame, SIM_LM32_SP_REGNUM);
+}
+
+static struct frame_id
+lm32_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
+{
+  CORE_ADDR sp = lm32_unwind_sp (gdbarch, this_frame);
+  return frame_id_build (sp, get_frame_pc (this_frame));
+}
+
+/* Put here the code to store, into fi->saved_regs, the addresses of
+   the saved registers of frame described by FRAME_INFO.  This
+   includes special registers such as pc and fp saved in special ways
+   in the stack frame.  sp is even more special: the address we return
+   for it IS the sp for the next frame. */
+
+struct lm32_unwind_cache *
+lm32_frame_unwind_cache (struct frame_info *this_frame, 
+                         void **this_prologue_cache)
+{
+  CORE_ADDR start_pc;
+  CORE_ADDR prologue_pc;
+  CORE_ADDR current_pc;
+  ULONGEST prev_sp;
+  ULONGEST this_base;
+  struct lm32_unwind_cache *info;
+  int done;
+  int prefixed;
+  unsigned long instruction;
+  int op;
+  int offsets[32];
+  int i;
+  long immediate;
+  int ra_on_stack;
+
+  if ((*this_prologue_cache))
+    return (*this_prologue_cache);
+
+  info = FRAME_OBSTACK_ZALLOC (struct lm32_unwind_cache);
+  (*this_prologue_cache) = info;
+  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);
+
+  info->size = 0;
+  info->uses_fp = 0;
+  
+  start_pc = get_frame_func (this_frame);
+  current_pc = get_frame_pc (this_frame);
+
+  /* Keep reading through instructions, until we come accross an instruction 
+     that isn't likely to be part of the prologue */
+  prologue_pc = start_pc;
+  ra_on_stack = 0;
+  done = 0;
+  
+  while (!done && (current_pc > prologue_pc)) 
+    {         
+            
+      /* Read an instruction */   
+      instruction = read_memory_integer (prologue_pc, 4);
+
+      if (   (LM32_OPCODE(instruction) == OP_SW) 
+          && (LM32_REG0(instruction) == SIM_LM32_SP_REGNUM))      
+        {
+          /* Any stack displaced store is likely part of the prologue.  
+             Record that the register is being saved, and the offset 
+             into the stack.  */
+          info->saved_regs[LM32_REG1(instruction)].addr = LM32_IMM16(instruction);
+          /* Check to see if the return address register is 
+             being stored on the stack.  */
+          if (   (LM32_REG1(instruction) == SIM_LM32_RA_REGNUM) 
+              && (current_pc > prologue_pc))
+            ra_on_stack = 1;
+        }
+      else if (   (LM32_OPCODE(instruction) == OP_ADDI) 
+               && (LM32_REG1(instruction) == SIM_LM32_SP_REGNUM))     
+        {
+          /* An add to the SP is likely to be part of the prologue.  
+             Adjust stack size by whatever the instruction adds to the sp.  */
+          info->size -= LM32_IMM16(instruction);
+        }
+      else if (   /* add fp,fp,sp */
+                  (   (LM32_OPCODE(instruction) == OP_ADD) 
+                   && (LM32_REG2(instruction) == SIM_LM32_FP_REGNUM) 
+                   && (LM32_REG0(instruction) == SIM_LM32_FP_REGNUM)
+                   && (LM32_REG1(instruction) == SIM_LM32_SP_REGNUM)
+                  )
+                  /* mv fp,imm */
+               || (   (LM32_OPCODE(instruction) == OP_ADDI) 
+                   && (LM32_REG1(instruction) == SIM_LM32_FP_REGNUM) 
+                   && (LM32_REG0(instruction) == SIM_LM32_R0_REGNUM)
+                  )
+              )
+        {
+          /* Used in functions with a frame pointer.  */          
+          info->uses_fp = 1;
+        }
+      else
+        {
+          /* Any other instruction is likely not to be part of the prologue */
+          done = 1;            
+        }
+
+      prologue_pc += 4;           
+        
+    } 
+    
+  /* Compute the frame's base, and the previous frame's SP.  */
+  this_base = get_frame_register_unsigned (this_frame, SIM_LM32_SP_REGNUM);   
+  prev_sp = this_base + info->size;
+  info->base = this_base;
+  info->prev_sp = prev_sp;
+
+  /* Convert callee save offsets into addresses */
+  for (i = 0; i < gdbarch_num_regs (get_frame_arch (this_frame)) - 1; i++)
+    {
+      if (trad_frame_addr_p (info->saved_regs, i))
+        info->saved_regs[i].addr = this_base + info->saved_regs[i].addr;
+    }
+
+  /* The call instruction moves the caller's PC in the callee's RA register.
+     Since this is an unwind, do the reverse.  Copy the location of RA register
+     into PC (the address / regnum) so that a request for PC will be
+     converted into a request for the RA register.  */
+  info->saved_regs[SIM_LM32_PC_REGNUM] = info->saved_regs[SIM_LM32_RA_REGNUM];
+    
+  /* The previous frame's SP needed to be computed.  Save the computed value. */
+  trad_frame_set_value (info->saved_regs, SIM_LM32_SP_REGNUM, info->prev_sp);
+
+  return info;
+}  
+
+/* Given a GDB frame, determine the address of the calling function's
+   frame.  This will be used to create a new GDB frame struct.  */
+
+static void
+lm32_frame_this_id (struct frame_info *this_frame,
+                      void **this_prologue_cache,
+                      struct frame_id *this_id)
+{
+  struct lm32_unwind_cache *info;
+  CORE_ADDR base;
+  CORE_ADDR func;
+  struct frame_id id;
+
+  info = lm32_frame_unwind_cache (this_frame, this_prologue_cache);
+  
+  /* The FUNC is easy.  */
+  func = get_frame_func (this_frame);
+    
+  /* Hopefully the prologue analysis either correctly determined the
+     frame's base (which is the SP from the previous frame), or set
+     that base to "NULL".  */
+  base = info->base; 
+  
+  if (base == 0)
+    return;
+    
+  id = frame_id_build (base, func);
+  (*this_id) = id;  
+}
+
+static struct value *
+lm32_frame_prev_register (struct frame_info *this_frame,
+                            void **this_prologue_cache,
+                            int regnum)
+{
+  struct lm32_unwind_cache *info;
+  info = lm32_frame_unwind_cache (this_frame, this_prologue_cache);
+  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
+}
+
+static const struct frame_unwind lm32_frame_unwind = {
+  NORMAL_FRAME,
+  lm32_frame_this_id,
+  lm32_frame_prev_register,
+  NULL,
+  default_frame_sniffer
+};
+
+static CORE_ADDR
+lm32_frame_base_address (struct frame_info *this_frame, void **this_cache)
+{
+  struct lm32_unwind_cache *info
+    = lm32_frame_unwind_cache (this_frame, this_cache);
+
+  return info->base;
+}
+
+static const struct frame_base lm32_frame_base = {
+  &lm32_frame_unwind,
+  lm32_frame_base_address,
+  lm32_frame_base_address,
+  lm32_frame_base_address
+};
+
+static CORE_ADDR
+lm32_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
+{
+  /* Align to the size of an instruction (so that they can safely be
+     pushed onto the stack.  */
+  return sp & ~3;
+}
+
+static struct gdbarch *
+lm32_gdbarch_init (struct gdbarch_info info,  struct gdbarch_list *arches)
+{
+  struct gdbarch *gdbarch;
+  struct gdbarch_tdep *tdep;
+
+  /* If there is already a candidate, use it.  */
+  arches = gdbarch_list_lookup_by_info (arches, &info);
+  if (arches != NULL)
+    return arches->gdbarch;
+  
+  /* None found, create a new architecture from the information provided. */
+  tdep = XMALLOC (struct gdbarch_tdep);
+  gdbarch = gdbarch_alloc (&info, tdep);
+      
+  /* Type sizes */
+  set_gdbarch_short_bit (gdbarch, 16);
+  set_gdbarch_int_bit (gdbarch, 32);
+  set_gdbarch_long_bit (gdbarch, 32);
+  set_gdbarch_long_long_bit (gdbarch, 64);
+  set_gdbarch_float_bit (gdbarch, 32);
+  set_gdbarch_double_bit (gdbarch, 64);
+  set_gdbarch_long_double_bit (gdbarch, 64);
+  set_gdbarch_ptr_bit (gdbarch, 32);
+  
+  /* Register info */
+  set_gdbarch_num_regs (gdbarch, SIM_LM32_NUM_REGS);
+  set_gdbarch_sp_regnum (gdbarch, SIM_LM32_SP_REGNUM);
+  set_gdbarch_pc_regnum (gdbarch, SIM_LM32_PC_REGNUM);  
+  set_gdbarch_register_name (gdbarch, lm32_register_name);
+  set_gdbarch_register_type (gdbarch, lm32_register_type);
+  set_gdbarch_cannot_store_register (gdbarch, lm32_cannot_store_register);
+
+  /* Frame info */
+  set_gdbarch_skip_prologue (gdbarch, lm32_skip_prologue);
+  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
+  set_gdbarch_decr_pc_after_break (gdbarch, 0);
+  set_gdbarch_frame_args_skip (gdbarch, 0);
+  
+  /* Frame unwinding */  
+  set_gdbarch_frame_align (gdbarch, lm32_frame_align);
+  frame_base_set_default (gdbarch, &lm32_frame_base);
+  set_gdbarch_unwind_pc (gdbarch, lm32_unwind_pc);
+  set_gdbarch_unwind_sp (gdbarch, lm32_unwind_sp);
+  set_gdbarch_dummy_id (gdbarch, lm32_dummy_id);
+  frame_unwind_append_unwinder (gdbarch, &lm32_frame_unwind);
+  
+  /* Breakpoints */
+  set_gdbarch_breakpoint_from_pc (gdbarch, lm32_breakpoint_from_pc);
+  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);
+  
+  /* Calling functions in the inferior */
+  set_gdbarch_push_dummy_call (gdbarch, lm32_push_dummy_call);
+  set_gdbarch_return_value (gdbarch, lm32_return_value);
+  
+  /* Instruction disassembler */
+  set_gdbarch_print_insn (gdbarch, print_insn_lm32);
+            
+  lm32_add_reggroups (gdbarch);
+  set_gdbarch_register_reggroup_p (gdbarch, lm32_register_reggroup_p);
+            
+  return gdbarch;
+}
+   
+void 
+_initialize_lm32_tdep (void)
+{
+  register_gdbarch_init (bfd_arch_lm32, lm32_gdbarch_init);
+}
+
diff -Naur gdb-6.8.50.20090329.orig/gdb/MAINTAINERS gdb-6.8.50.20090329/gdb/MAINTAINERS
--- gdb-6.8.50.20090329.orig/gdb/MAINTAINERS	2009-02-27 16:03:47.000000000 +0100
+++ gdb-6.8.50.20090329/gdb/MAINTAINERS	2009-04-17 15:30:42.000000000 +0200
@@ -270,6 +270,9 @@
 	ia64		--target=ia64-linux-gnu ,-Werror
 			(--target=ia64-elf broken)
 
+        lm32            --target=lm32-elf ,-Werror
+                        Jon Beniston, jon@beniston.com
+
 	m32c		--target=m32c-elf ,-Werror
 			Jim Blandy, jimb@codesourcery.com
 
diff -Naur gdb-6.8.50.20090329.orig/gdb/Makefile.in gdb-6.8.50.20090329/gdb/Makefile.in
--- gdb-6.8.50.20090329.orig/gdb/Makefile.in	2009-03-25 01:58:33.000000000 +0100
+++ gdb-6.8.50.20090329/gdb/Makefile.in	2009-04-17 15:30:42.000000000 +0200
@@ -482,6 +482,7 @@
 	i386-sol2-tdep.o i386-tdep.o i387-tdep.o \
 	i386-dicos-tdep.o \
 	iq2000-tdep.o \
+	lm32-linux-tdep.o lm32-tdep.o \
 	linux-tdep.o \
 	m32c-tdep.o \
 	m32r-linux-tdep.o m32r-tdep.o \
@@ -1306,6 +1307,7 @@
 	libunwind-frame.c \
 	linux-fork.c \
 	linux-tdep.c \
+	lm32-linux-tdep.c lm32-tdep.c \
 	m68hc11-tdep.c \
 	m32r-tdep.c \
 	m32r-linux-nat.c m32r-linux-tdep.c \
diff -Naur gdb-6.8.50.20090329.orig/gdb/Makefile.in.orig gdb-6.8.50.20090329/gdb/Makefile.in.orig
--- gdb-6.8.50.20090329.orig/gdb/Makefile.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/gdb/Makefile.in.orig	2009-03-25 01:58:33.000000000 +0100
@@ -0,0 +1,1901 @@
+# Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+# 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+# Free Software Foundation, Inc.
+
+# This file is part of GDB.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+host_alias = @host_alias@
+target_alias = @target_alias@
+program_transform_name = @program_transform_name@
+bindir = @bindir@
+libdir = @libdir@
+tooldir = $(libdir)/$(target_alias)
+
+datadir = @datadir@
+localedir = @localedir@
+mandir = @mandir@
+man1dir = $(mandir)/man1
+man2dir = $(mandir)/man2
+man3dir = $(mandir)/man3
+man4dir = $(mandir)/man4
+man5dir = $(mandir)/man5
+man6dir = $(mandir)/man6
+man7dir = $(mandir)/man7
+man8dir = $(mandir)/man8
+man9dir = $(mandir)/man9
+infodir = @infodir@
+pdfdir = $(prefix)/share/doc/gdb
+htmldir = $(prefix)/html
+includedir = @includedir@
+
+# This can be referenced by `LIBINTL' as computed by
+# ZW_GNU_GETTEXT_SISTER_DIR.
+top_builddir = .
+
+SHELL = @SHELL@
+EXEEXT = @EXEEXT@
+
+AWK = @AWK@
+LN_S = @LN_S@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+
+DESTDIR =
+
+AR = @AR@
+AR_FLAGS = qv
+RANLIB = @RANLIB@
+DLLTOOL = @DLLTOOL@
+WINDRES = @WINDRES@
+MIG = @MIG@
+
+XGETTEXT = @XGETTEXT@
+GMSGFMT = @GMSGFMT@
+MSGMERGE = msgmerge
+
+PACKAGE = @PACKAGE@
+CATALOGS = @CATALOGS@
+
+# If you are compiling with GCC, make sure that either 1) You have the
+# fixed include files where GCC can reach them, or 2) You use the
+# -traditional flag.  Otherwise the ioctl calls in inflow.c
+# will be incorrectly compiled.  The "fixincludes" script in the gcc
+# distribution will fix your include files up.
+CC=@CC@
+
+# Dependency tracking information.
+DEPMODE = @CCDEPMODE@
+DEPDIR = @DEPDIR@
+depcomp = $(SHELL) $(srcdir)/../depcomp
+
+# Note that these are overridden by GNU make-specific code below if
+# GNU make is used.  The overrides implement dependency tracking.
+COMPILE.pre = $(CC)
+COMPILE.post = -c -o $@
+COMPILE = $(COMPILE.pre) $(INTERNAL_CFLAGS) $(COMPILE.post)
+POSTCOMPILE = @true
+
+# Directory containing source files.
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+YACC=@YACC@
+
+# This is used to rebuild ada-lex.c from ada-lex.l.  If the program is
+# not defined, but ada-lex.c is present, compilation will continue,
+# possibly with a warning.
+FLEX = flex
+
+YLWRAP = $(srcdir)/../ylwrap
+
+# where to find makeinfo, preferably one designed for texinfo-2
+MAKEINFO=makeinfo
+
+# Contrary to documentation, the current directory is not
+# searched by texi2html, so specify it explicitly.
+# -macro 2007-07-26
+MAKEHTML = texi2html
+MAKEHTMLFLAGS = -menu -split_chapter -I .
+
+# Set this up with gcc if you have gnu ld and the loader will print out
+# line numbers for undefined references.
+#CC_LD=gcc -static
+CC_LD=$(CC)
+
+# Where is our "include" directory?  Typically $(srcdir)/../include.
+# This is essentially the header file directory for the library
+# routines in libiberty.
+INCLUDE_DIR =  $(srcdir)/../include
+INCLUDE_CFLAGS = -I$(INCLUDE_DIR)
+
+# Where is the "-liberty" library?  Typically in ../libiberty.
+LIBIBERTY = ../libiberty/libiberty.a
+
+# Where is the BFD library?  Typically in ../bfd.
+BFD_DIR = ../bfd
+BFD = $(BFD_DIR)/libbfd.a
+BFD_SRC = $(srcdir)/$(BFD_DIR)
+BFD_CFLAGS = -I$(BFD_DIR) -I$(BFD_SRC)
+
+# Where is the decnumber library?  Typically in ../libdecnumber.
+LIBDECNUMBER_DIR = ../libdecnumber
+LIBDECNUMBER = $(LIBDECNUMBER_DIR)/libdecnumber.a
+LIBDECNUMBER_SRC = $(srcdir)/$(LIBDECNUMBER_DIR)
+LIBDECNUMBER_CFLAGS = -I$(LIBDECNUMBER_DIR) -I$(LIBDECNUMBER_SRC)
+
+# Where is the READLINE library?  Typically in ../readline.
+READLINE_DIR = ../readline
+READLINE_SRC = $(srcdir)/$(READLINE_DIR)
+READLINE = @READLINE@
+READLINE_DEPS = @READLINE_DEPS@
+READLINE_CFLAGS = @READLINE_CFLAGS@
+
+# Where is expat?  This will be empty if expat was not available.
+LIBEXPAT = @LIBEXPAT@
+
+WARN_CFLAGS = @WARN_CFLAGS@
+WERROR_CFLAGS = @WERROR_CFLAGS@
+GDB_WARN_CFLAGS = $(WARN_CFLAGS)
+GDB_WERROR_CFLAGS = $(WERROR_CFLAGS)
+
+GDB_WARN_CFLAGS_NO_FORMAT = `echo " $(GDB_WARN_CFLAGS) " | sed "s/ -Wformat-nonliteral / /g"`
+
+# Where is the INTL library?  Typically in ../intl.
+INTL = @LIBINTL@
+INTL_DEPS = @LIBINTL_DEP@
+INTL_CFLAGS = @INCINTL@
+
+# Did the user give us a --with-sysroot option?
+TARGET_SYSTEM_ROOT = @TARGET_SYSTEM_ROOT@
+TARGET_SYSTEM_ROOT_DEFINE = @TARGET_SYSTEM_ROOT_DEFINE@
+
+# Helper code from gnulib.
+LIBGNU = gnulib/libgnu.a
+INCGNU = -I$(srcdir)/gnulib -Ignulib
+
+# Generated headers in the gnulib directory.  These must be listed
+# so that they are generated before other files are compiled.
+GNULIB_H = gnulib/string.h @GNULIB_STDINT_H@
+
+#
+# CLI sub directory definitons
+#
+SUBDIR_CLI_OBS = \
+	cli-dump.o \
+	cli-decode.o cli-script.o cli-cmds.o cli-setshow.o \
+	cli-logging.o \
+	cli-interp.o
+SUBDIR_CLI_SRCS = \
+	cli/cli-dump.c \
+	cli/cli-decode.c cli/cli-script.c cli/cli-cmds.c cli/cli-setshow.c \
+	cli/cli-logging.c \
+	cli/cli-interp.c
+SUBDIR_CLI_DEPS =
+SUBDIR_CLI_LDFLAGS=
+SUBDIR_CLI_CFLAGS=
+
+#
+# MI sub directory definitons
+#
+SUBDIR_MI_OBS = \
+	mi-out.o mi-console.o \
+	mi-cmds.o mi-cmd-env.o mi-cmd-var.o mi-cmd-break.o mi-cmd-stack.o \
+	mi-cmd-file.o mi-cmd-disas.o mi-symbol-cmds.o mi-cmd-target.o \
+	mi-interp.o \
+	mi-main.o mi-parse.o mi-getopt.o mi-common.o
+SUBDIR_MI_SRCS = \
+	mi/mi-out.c mi/mi-console.c \
+	mi/mi-cmds.c mi/mi-cmd-env.c \
+	mi/mi-cmd-var.c mi/mi-cmd-break.c mi/mi-cmd-stack.c \
+	mi/mi-cmd-file.c mi/mi-cmd-disas.c mi/mi-symbol-cmds.c \
+	mi/mi-cmd-target.c mi/mi-interp.c \
+	mi/mi-main.c mi/mi-parse.c mi/mi-getopt.c mi/mi-common.c
+SUBDIR_MI_DEPS =
+SUBDIR_MI_LDFLAGS=
+SUBDIR_MI_CFLAGS= \
+	-DMI_OUT=1
+
+#
+# TUI sub directory definitions
+#
+
+# Name of the TUI program
+TUI=gdbtui
+
+SUBDIR_TUI_OBS = \
+	tui-command.o \
+	tui-data.o \
+	tui-disasm.o \
+	tui-file.o tui.o \
+	tui-hooks.o \
+	tui-interp.o \
+	tui-io.o \
+	tui-layout.o \
+	tui-out.o \
+	tui-regs.o \
+	tui-source.o \
+	tui-stack.o \
+	tui-win.o \
+	tui-windata.o \
+	tui-wingeneral.o \
+	tui-winsource.o
+SUBDIR_TUI_SRCS = \
+	tui/tui-command.c \
+	tui/tui-data.c \
+	tui/tui-disasm.c \
+	tui/tui-file.c \
+	tui/tui-hooks.c \
+	tui/tui-interp.c \
+	tui/tui-io.c \
+	tui/tui-layout.c \
+	tui/tui-out.c \
+	tui/tui-regs.c \
+	tui/tui-source.c \
+	tui/tui-stack.c \
+	tui/tui-win.c \
+	tui/tui-windata.c \
+	tui/tui-wingeneral.c \
+	tui/tui-winsource.c \
+	tui/tui.c
+SUBDIR_TUI_DEPS =
+SUBDIR_TUI_LDFLAGS=
+SUBDIR_TUI_CFLAGS= \
+	-DTUI=1
+
+#
+# python sub directory definitons
+#
+SUBDIR_PYTHON_OBS = \
+	python.o \
+	python-cmd.o \
+	python-function.o \
+	python-utils.o \
+	python-value.o
+SUBDIR_PYTHON_SRCS = \
+	python/python.c \
+	python/python-cmd.c \
+	python/python-function.c \
+	python/python-utils.c \
+	python/python-value.c
+SUBDIR_PYTHON_DEPS =
+SUBDIR_PYTHON_LDFLAGS=
+SUBDIR_PYTHON_CFLAGS=
+
+
+# Opcodes currently live in one of two places.  Either they are in the
+# opcode library, typically ../opcodes, or they are in a header file
+# in INCLUDE_DIR.
+# Where is the "-lopcodes" library, with (some of) the opcode tables and
+# disassemblers?
+OPCODES_DIR = ../opcodes
+OPCODES_SRC = $(srcdir)/$(OPCODES_DIR)
+OPCODES = $(OPCODES_DIR)/libopcodes.a
+# Where are the other opcode tables which only have header file
+# versions?
+OP_INCLUDE = $(INCLUDE_DIR)/opcode
+OPCODES_CFLAGS = -I$(OP_INCLUDE)
+
+# The simulator is usually nonexistent; targets that include one
+# should set this to list all the .o or .a files to be linked in.
+SIM = @SIM@
+
+WIN32LIBS = @WIN32LIBS@
+
+# Tcl et al cflags and libraries
+TCL = @TCL_LIBRARY@
+TCL_CFLAGS = @TCL_INCLUDE@
+GDBTKLIBS = @GDBTKLIBS@
+# Extra flags that the GDBTK files need:
+GDBTK_CFLAGS = @GDBTK_CFLAGS@
+
+TK = @TK_LIBRARY@
+TK_CFLAGS = @TK_INCLUDE@
+
+X11_CFLAGS = @TK_XINCLUDES@
+X11_LDFLAGS =
+X11_LIBS =
+
+WIN32LDAPP = @WIN32LDAPP@
+
+LIBGUI = @LIBGUI@
+GUI_CFLAGS_X = @GUI_CFLAGS_X@
+IDE_CFLAGS=$(GUI_CFLAGS_X) $(IDE_CFLAGS_X)
+
+ALL_TCL_CFLAGS = $(TCL_CFLAGS) $(TK_CFLAGS)
+
+# The version of gdbtk we're building. This should be kept
+# in sync with GDBTK_VERSION and friends in gdbtk.h.
+GDBTK_VERSION = 1.0
+GDBTK_LIBRARY = $(datadir)/insight$(GDBTK_VERSION)
+
+# Gdbtk requires an absolute path to the source directory or
+# the testsuite won't run properly.
+GDBTK_SRC_DIR = @GDBTK_SRC_DIR@
+
+SUBDIR_GDBTK_OBS = \
+	gdbtk.o gdbtk-bp.o gdbtk-cmds.o gdbtk-hooks.o gdbtk-interp.o \
+	gdbtk-register.o gdbtk-stack.o gdbtk-varobj.o gdbtk-wrapper.o
+SUBDIR_GDBTK_SRCS = \
+	gdbtk/generic/gdbtk.c gdbtk/generic/gdbtk-bp.c \
+	gdbtk/generic/gdbtk-cmds.c gdbtk/generic/gdbtk-hooks.c \
+	gdbtk/generic/gdbtk-interp.c \
+	gdbtk/generic/gdbtk-register.c gdbtk/generic/gdbtk-stack.c \
+	gdbtk/generic/gdbtk-varobj.c gdbtk/generic/gdbtk-wrapper.c \
+	gdbtk/generic/gdbtk-main.c
+SUBDIR_GDBTK_DEPS = $(LIBGUI) $(TCL_DEPS) $(TK_DEPS)
+SUBDIR_GDBTK_LDFLAGS=
+SUBDIR_GDBTK_CFLAGS= -DGDBTK
+
+CONFIG_OBS= @CONFIG_OBS@
+CONFIG_SRCS= @CONFIG_SRCS@
+CONFIG_DEPS= @CONFIG_DEPS@
+CONFIG_LDFLAGS = @CONFIG_LDFLAGS@
+ENABLE_CFLAGS= @ENABLE_CFLAGS@
+CONFIG_ALL= @CONFIG_ALL@
+CONFIG_CLEAN= @CONFIG_CLEAN@
+CONFIG_INSTALL = @CONFIG_INSTALL@
+CONFIG_UNINSTALL = @CONFIG_UNINSTALL@
+
+# -I. for config files.
+# -I$(srcdir) for gdb internal headers.
+# -I$(srcdir)/config for more generic config files.
+
+# It is also possible that you will need to add -I/usr/include/sys if
+# your system doesn't have fcntl.h in /usr/include (which is where it
+# should be according to Posix).
+DEFS = @DEFS@
+GDB_CFLAGS = -I. -I$(srcdir) -I$(srcdir)/common -I$(srcdir)/config \
+	-DLOCALEDIR="\"$(localedir)\"" $(DEFS)
+
+# MH_CFLAGS, if defined, has host-dependent CFLAGS from the config directory.
+GLOBAL_CFLAGS = $(MH_CFLAGS)
+
+PROFILE_CFLAGS = @PROFILE_CFLAGS@
+
+# CFLAGS is specifically reserved for setting from the command line
+# when running make.  I.E.  "make CFLAGS=-Wmissing-prototypes".
+CFLAGS = @CFLAGS@
+
+# Set by configure, for e.g. expat.
+INTERNAL_CPPFLAGS = @CPPFLAGS@
+
+# Need to pass this to testsuite for "make check".  Probably should be
+# consistent with top-level Makefile.in and gdb/testsuite/Makefile.in
+# so "make check" has the same result no matter where it is run.
+CXXFLAGS = -g -O
+
+# INTERNAL_CFLAGS is the aggregate of all other *CFLAGS macros.
+INTERNAL_CFLAGS_BASE = \
+	$(CFLAGS) $(GLOBAL_CFLAGS) $(PROFILE_CFLAGS) \
+	$(GDB_CFLAGS) $(OPCODES_CFLAGS) $(READLINE_CFLAGS) \
+	$(BFD_CFLAGS) $(INCLUDE_CFLAGS) $(LIBDECNUMBER_CFLAGS) \
+	$(INTL_CFLAGS) $(INCGNU) $(ENABLE_CFLAGS) $(INTERNAL_CPPFLAGS)
+INTERNAL_WARN_CFLAGS = $(INTERNAL_CFLAGS_BASE) $(GDB_WARN_CFLAGS)
+INTERNAL_CFLAGS = $(INTERNAL_WARN_CFLAGS) $(GDB_WERROR_CFLAGS)
+
+# LDFLAGS is specifically reserved for setting from the command line
+# when running make.
+LDFLAGS = @LDFLAGS@
+
+# Profiling options need to go here to work.
+# I think it's perfectly reasonable for a user to set -pg in CFLAGS
+# and have it work; that's why CFLAGS is here.
+# PROFILE_CFLAGS is _not_ included, however, because we use monstartup.
+INTERNAL_LDFLAGS = $(CFLAGS) $(GLOBAL_CFLAGS) $(MH_LDFLAGS) $(LDFLAGS) $(CONFIG_LDFLAGS)
+
+# If your system is missing alloca(), or, more likely, it's there but
+# it doesn't work, then refer to libiberty.
+
+# Libraries and corresponding dependencies for compiling gdb.
+# {X,T}M_CLIBS, defined in *config files, have host- and target-dependent libs.
+# LIBIBERTY appears twice on purpose.
+# If you have the Cygnus libraries installed,
+# you can use 'CLIBS=$(INSTALLED_LIBS)' 'CDEPS='
+INSTALLED_LIBS=-lbfd -lreadline -lopcodes -liberty -ldecnumber \
+	$(XM_CLIBS) $(NAT_CLIBS) $(GDBTKLIBS) @LIBS@ \
+	-lintl -liberty $(LIBGNU)
+CLIBS = $(SIM) $(READLINE) $(OPCODES) $(BFD) $(INTL) $(LIBIBERTY) $(LIBDECNUMBER) \
+	$(XM_CLIBS) $(NAT_CLIBS) $(GDBTKLIBS) @LIBS@ \
+	$(LIBEXPAT) \
+	$(LIBIBERTY) $(WIN32LIBS) $(LIBGNU)
+CDEPS = $(XM_CDEPS) $(NAT_CDEPS) $(SIM) $(BFD) $(READLINE_DEPS) \
+	$(OPCODES) $(INTL_DEPS) $(LIBIBERTY) $(CONFIG_DEPS) $(LIBGNU)
+
+ADD_FILES = $(XM_ADD_FILES) $(TM_ADD_FILES) $(NAT_ADD_FILES)
+ADD_DEPS = $(XM_ADD_FILES) $(TM_ADD_FILES) $(NAT_ADD_FILES)
+
+DIST=gdb
+
+LINT=/usr/5bin/lint
+LINTFLAGS= $(GDB_CFLAGS) $(OPCODES_CFLAGS) $(READLINE_CFLAGS) \
+	$(BFD_CFLAGS) $(INCLUDE_CFLAGS) \
+	$(INTL_CFLAGS)
+
+RUNTEST = runtest
+RUNTESTFLAGS=
+
+# XML files to build in to GDB.
+XMLFILES = $(srcdir)/features/gdb-target.dtd $(srcdir)/features/xinclude.dtd \
+	$(srcdir)/features/library-list.dtd $(srcdir)/features/osdata.dtd
+
+# This is ser-unix.o for any system which supports a v7/BSD/SYSV/POSIX
+# interface to the serial port.  Hopefully if get ported to OS/2, VMS,
+# etc., then there will be (as part of the C library or perhaps as
+# part of libiberty) a POSIX interface.  But at least for now the
+# host-dependent makefile fragment might need to use something else
+# besides ser-unix.o
+SER_HARDWIRE = @SER_HARDWIRE@
+
+# The `remote' debugging target is supported for most architectures,
+# but not all (e.g. 960)
+REMOTE_OBS = remote.o dcache.o tracepoint.o ax-general.o ax-gdb.o remote-fileio.o
+
+# This is remote-sim.o if a simulator is to be linked in.
+SIM_OBS = @SIM_OBS@
+
+# Target-dependent object files.
+TARGET_OBS = @TARGET_OBS@
+
+# All target-dependent objects files that require 64-bit CORE_ADDR
+# (used with --enable-targets=all --enable-64-bit-bfd).
+ALL_64_TARGET_OBS = \
+	alphabsd-tdep.o alphafbsd-tdep.o alpha-linux-tdep.o alpha-mdebug-tdep.o \
+	alphanbsd-tdep.o alphaobsd-tdep.o alpha-osf1-tdep.o alpha-tdep.o \
+	amd64fbsd-tdep.o amd64-dicos-tdep.o amd64-linux-tdep.o amd64nbsd-tdep.o \
+	amd64obsd-tdep.o amd64-sol2-tdep.o amd64-tdep.o \
+	ia64-linux-tdep.o ia64-tdep.o \
+	mips64obsd-tdep.o \
+	sparc64fbsd-tdep.o sparc64-linux-tdep.o sparc64nbsd-tdep.o \
+	sparc64obsd-tdep.o sparc64-sol2-tdep.o sparc64-tdep.o
+
+# All other target-dependent objects files (used with --enable-targets=all).
+ALL_TARGET_OBS = \
+	armbsd-tdep.o arm-linux-tdep.o armnbsd-tdep.o armobsd-tdep.o \
+	arm-tdep.o arm-wince-tdep.o \
+	avr-tdep.o \
+	cris-tdep.o \
+	dicos-tdep.o \
+	frv-linux-tdep.o frv-tdep.o \
+	h8300-tdep.o \
+	hppabsd-tdep.o hppanbsd-tdep.o hppaobsd-tdep.o \
+	hppa-hpux-tdep.o hppa-linux-tdep.o hppa-tdep.o \
+	i386bsd-tdep.o i386-cygwin-tdep.o i386fbsd-tdep.o i386gnu-tdep.o \
+	i386-linux-tdep.o i386nbsd-tdep.o i386-nto-tdep.o i386obsd-tdep.o \
+	i386-sol2-tdep.o i386-tdep.o i387-tdep.o \
+	i386-dicos-tdep.o \
+	iq2000-tdep.o \
+	linux-tdep.o \
+	m32c-tdep.o \
+	m32r-linux-tdep.o m32r-tdep.o \
+	m68hc11-tdep.o \
+	m68kbsd-tdep.o m68klinux-tdep.o m68k-tdep.o \
+	m88k-tdep.o \
+	mep-tdep.o \
+	mips-irix-tdep.o mips-linux-tdep.o \
+	mipsnbsd-tdep.o mips-tdep.o \
+	mn10300-linux-tdep.o mn10300-tdep.o \
+	mt-tdep.o \
+	nto-tdep.o \
+	ppc-linux-tdep.o ppcnbsd-tdep.o ppcobsd-tdep.o ppc-sysv-tdep.o \
+	rs6000-aix-tdep.o rs6000-tdep.o \
+	s390-tdep.o \
+	score-tdep.o \
+	sh64-tdep.o sh-linux-tdep.o shnbsd-tdep.o sh-tdep.o \
+	sparc-linux-tdep.o sparcnbsd-tdep.o sparcobsd-tdep.o \
+	sparc-sol2-tdep.o sparc-tdep.o \
+	spu-tdep.o \
+	v850-tdep.o \
+	vaxnbsd-tdep.o vaxobsd-tdep.o vax-tdep.o \
+	xstormy16-tdep.o \
+	xtensa-config.o xtensa-tdep.o xtensa-linux-tdep.o \
+	glibc-tdep.o \
+	bsd-uthread.o \
+	nbsd-tdep.o obsd-tdep.o \
+	sol2-tdep.o \
+	solib.o solib-frv.o solib-irix.o solib-svr4.o solib-target.o \
+	solib-som.o solib-pa64.o \
+	dbug-rom.o dink32-rom.o ppcbug-rom.o m32r-rom.o dsrec.o monitor.o \
+	remote-m32r-sdi.o \
+	xcoffread.o \
+	prologue-value.o \
+	symfile-mem.o \
+	corelow.o \
+	windows-tdep.o
+
+# Host-dependent makefile fragment comes in here.
+@host_makefile_frag@
+# End of host-dependent makefile fragment
+
+FLAGS_TO_PASS = \
+	"prefix=$(prefix)" \
+	"exec_prefix=$(exec_prefix)" \
+	"infodir=$(infodir)" \
+	"pdfdir=$(pdfdir)" \
+	"libdir=$(libdir)" \
+	"mandir=$(mandir)" \
+	"datadir=$(datadir)" \
+	"includedir=$(includedir)" \
+	"against=$(against)" \
+	"DESTDIR=$(DESTDIR)" \
+	"AR=$(AR)" \
+	"AR_FLAGS=$(AR_FLAGS)" \
+	"CC=$(CC)" \
+	"CFLAGS=$(CFLAGS)" \
+	"CXX=$(CXX)" \
+	"CXXFLAGS=$(CXXFLAGS)" \
+	"DLLTOOL=$(DLLTOOL)" \
+	"LDFLAGS=$(LDFLAGS)" \
+	"RANLIB=$(RANLIB)" \
+	"MAKEINFO=$(MAKEINFO)" \
+	"MAKEHTML=$(MAKEHTML)" \
+	"MAKEHTMLFLAGS=$(MAKEHTMLFLAGS)" \
+	"INSTALL=$(INSTALL)" \
+	"INSTALL_PROGRAM=$(INSTALL_PROGRAM)" \
+	"INSTALL_DATA=$(INSTALL_DATA)" \
+	"RUNTEST=$(RUNTEST)" \
+	"RUNTESTFLAGS=$(RUNTESTFLAGS)"
+
+# Flags that we pass when building the testsuite.
+
+# empty for native, $(target_alias)/ for cross
+target_subdir = @target_subdir@
+
+CC_FOR_TARGET = ` \
+  if [ -f $${rootme}/../gcc/xgcc ] ; then \
+    if [ -f $${rootme}/../$(target_subdir)newlib/Makefile ] ; then \
+      echo $${rootme}/../gcc/xgcc -B$${rootme}/../gcc/ -idirafter $${rootme}/$(target_subdir)newlib/targ-include -idirafter $${rootsrc}/../$(target_subdir)newlib/libc/include -nostdinc -B$${rootme}/../$(target_subdir)newlib/; \
+    else \
+      echo $${rootme}/../gcc/xgcc -B$${rootme}/../gcc/; \
+    fi; \
+  else \
+    if [ "$(host_canonical)" = "$(target_canonical)" ] ; then \
+      echo $(CC); \
+    else \
+      t='$(program_transform_name)'; echo gcc | sed -e '' $$t; \
+    fi; \
+  fi`
+
+CXX = gcc
+CXX_FOR_TARGET = ` \
+  if [ -f $${rootme}/../gcc/xgcc ] ; then \
+    if [ -f $${rootme}/../$(target_subdir)newlib/Makefile ] ; then \
+      echo $${rootme}/../gcc/xgcc -B$${rootme}/../gcc/ -idirafter $${rootme}/$(target_subdir)newlib/targ-include -idirafter $${rootsrc}/../$(target_subdir)newlib/libc/include -nostdinc -B$${rootme}/../$(target_subdir)newlib/; \
+    else \
+      echo $${rootme}/../gcc/xgcc -B$${rootme}/../gcc/; \
+    fi; \
+  else \
+    if [ "$(host_canonical)" = "$(target_canonical)" ] ; then \
+      echo $(CXX); \
+    else \
+      t='$(program_transform_name)'; echo gcc | sed -e '' $$t; \
+    fi; \
+  fi`
+
+# The use of $$(x_FOR_TARGET) reduces the command line length by not
+# duplicating the lengthy definition.
+TARGET_FLAGS_TO_PASS = \
+	"prefix=$(prefix)" \
+	"exec_prefix=$(exec_prefix)" \
+	"against=$(against)" \
+	'CC=$$(CC_FOR_TARGET)' \
+	"CC_FOR_TARGET=$(CC_FOR_TARGET)" \
+	"CFLAGS=$(CFLAGS)" \
+	'CXX=$$(CXX_FOR_TARGET)' \
+	"CXX_FOR_TARGET=$(CXX_FOR_TARGET)" \
+	"CXXFLAGS=$(CXXFLAGS)" \
+	"INSTALL=$(INSTALL)" \
+	"INSTALL_PROGRAM=$(INSTALL_PROGRAM)" \
+	"INSTALL_DATA=$(INSTALL_DATA)" \
+	"MAKEINFO=$(MAKEINFO)" \
+	"MAKEHTML=$(MAKEHTML)" \
+	"RUNTEST=$(RUNTEST)" \
+	"RUNTESTFLAGS=$(RUNTESTFLAGS)"
+
+# All source files that go into linking GDB.
+# Links made at configuration time should not be specified here, since
+# SFILES is used in building the distribution archive.
+
+SFILES = ada-exp.y ada-lang.c ada-typeprint.c ada-valprint.c ada-tasks.c \
+	addrmap.c \
+	auxv.c ax-general.c ax-gdb.c \
+	bcache.c \
+	bfd-target.c \
+	block.c blockframe.c breakpoint.c buildsym.c \
+	c-exp.y c-lang.c c-typeprint.c c-valprint.c \
+	charset.c cli-out.c coffread.c coff-pe-read.c \
+	complaints.c completer.c corefile.c \
+	cp-abi.c cp-support.c cp-namespace.c cp-valprint.c \
+	cp-name-parser.y \
+	dbxread.c demangle.c dictionary.c disasm.c doublest.c dummy-frame.c \
+	dwarf2expr.c dwarf2loc.c dwarf2read.c dwarf2-frame.c \
+	elfread.c environ.c eval.c event-loop.c event-top.c expprint.c \
+	f-exp.y f-lang.c f-typeprint.c f-valprint.c findcmd.c findvar.c \
+	frame.c frame-base.c frame-unwind.c \
+	gdbarch.c arch-utils.c gdbtypes.c gnu-v2-abi.c gnu-v3-abi.c \
+	inf-loop.c \
+	infcall.c \
+	infcmd.c inflow.c infrun.c \
+	interps.c \
+	jv-exp.y jv-lang.c jv-valprint.c jv-typeprint.c \
+	language.c linespec.c \
+	m2-exp.y m2-lang.c m2-typeprint.c m2-valprint.c \
+	macrotab.c macroexp.c macrocmd.c macroscope.c main.c maint.c \
+	mdebugread.c memattr.c mem-break.c minsyms.c mipsread.c memory-map.c \
+	objc-exp.y objc-lang.c \
+	objfiles.c osabi.c observer.c osdata.c \
+	p-exp.y p-lang.c p-typeprint.c p-valprint.c parse.c printcmd.c \
+	prologue-value.c \
+	regcache.c reggroups.c remote.c remote-fileio.c reverse.c \
+	scm-exp.c scm-lang.c scm-valprint.c \
+	sentinel-frame.c \
+	serial.c ser-base.c ser-unix.c \
+	solib.c solib-null.c source.c \
+	stabsread.c stack.c std-regs.c symfile.c symfile-mem.c symmisc.c \
+	symtab.c \
+	target.c target-descriptions.c target-memory.c \
+	thread.c top.c tracepoint.c \
+	trad-frame.c \
+	tramp-frame.c \
+	typeprint.c \
+	ui-out.c utils.c ui-file.h ui-file.c \
+	user-regs.c \
+	valarith.c valops.c valprint.c value.c varobj.c vec.c \
+	wrapper.c \
+	xml-tdesc.c xml-support.c \
+	inferior.c gdb_usleep.c
+
+LINTFILES = $(SFILES) $(YYFILES) $(CONFIG_SRCS) init.c
+
+# Header files that need to have srcdir added.  Note that in the cases
+# where we use a macro like $(gdbcmd_h), things are carefully arranged
+# so that each .h file is listed exactly once (M-x tags-search works
+# wrong if TAGS has files twice).  Because this is tricky to get
+# right, it is probably easiest just to list .h files here directly.
+
+HFILES_NO_SRCDIR = osf-share/cma_debug_client.h	\
+osf-share/HP800/cma_thread_io.h osf-share/cma_sequence.h \
+osf-share/cma_mutex.h osf-share/cma_semaphore_defs.h \
+osf-share/cma_list.h osf-share/cma_handle.h osf-share/cma_stack.h \
+osf-share/cma_util.h osf-share/RIOS/cma_thread_io.h \
+osf-share/cma_errors.h osf-share/cma_tcb_defs.h osf-share/cma_attr.h \
+osf-share/cma_stack_int.h osf-share/cma_init.h \
+osf-share/cma_deb_core.h osf-share/AT386/cma_thread_io.h \
+osf-share/cma_sched.h proc-utils.h arm-tdep.h ax-gdb.h ppcnbsd-tdep.h \
+cli-out.h gdb_expat.h breakpoint.h infcall.h obsd-tdep.h gnu-v2-abi.h \
+exec.h m32r-tdep.h osabi.h gdbcore.h solib-som.h \
+i386bsd-nat.h xml-support.h xml-tdesc.h alphabsd-tdep.h gdb_obstack.h \
+ia64-tdep.h ada-lang.h varobj.h frv-tdep.h nto-tdep.h serial.h \
+c-lang.h frame.h event-loop.h block.h cli/cli-setshow.h	\
+cli/cli-decode.h cli/cli-cmds.h cli/cli-dump.h \
+cli/cli-script.h macrotab.h symtab.h version.h gnulib/wchar.in.h \
+gnulib/string.in.h gnulib/str-two-way.h gnulib/extra/link-warning.h \
+gnulib/stdint.in.h remote.h gdb.h sparc-nat.h gdbserver/win32-low.h \
+gdbserver/i387-fp.h gdbserver/server.h gdbserver/terminal.h \
+gdbserver/mem-break.h gdbserver/wincecompat.h gdbserver/target.h \
+gdbserver/linux-low.h gdbserver/gdb_proc_service.h \
+gdbserver/regcache.h gdbthread.h dwarf2-frame.h nbsd-nat.h dcache.h \
+amd64-nat.h s390-tdep.h arm-linux-tdep.h exceptions.h macroscope.h \
+gdbarch.h bsd-uthread.h gdb_thread_db.h gdb_stat.h memory-map.h	\
+mdebugread.h m88k-tdep.h stabsread.h hppa-linux-offsets.h linux-fork.h \
+ser-unix.h scm-lang.h inf-ptrace.h terminal.h ui-out.h frame-base.h \
+f-lang.h dwarf2loc.h value.h sparc-tdep.h defs.h target-descriptions.h \
+objfiles.h vec.h disasm.h mips-tdep.h ser-base.h \
+gdb_curses.h bfd-target.h memattr.h inferior.h ax.h dummy-frame.h \
+inflow.h fbsd-nat.h libunwind-frame.h completer.h inf-ttrace.h \
+solib-target.h shnbsd-tdep.h gdb_vfork.h alpha-tdep.h dwarf2expr.h \
+m2-lang.h stack.h charset.h addrmap.h command.h solist.h source.h \
+target.h prologue-value.h cp-abi.h tui/tui-hooks.h tui/tui.h \
+tui/tui-file.h tui/tui-command.h tui/tui-disasm.h tui/tui-wingeneral.h \
+tui/tui-windata.h tui/tui-data.h tui/tui-win.h tui/tui-stack.h \
+tui/tui-winsource.h tui/tui-regs.h tui/tui-io.h tui/tui-layout.h \
+tui/tui-source.h xcoffsolib.h sol2-tdep.h gregset.h sh-tdep.h \
+expression.h score-tdep.h gdb_select.h ser-tcp.h buildsym.h valprint.h \
+call-cmds.h typeprint.h mi/mi-getopt.h mi/mi-parse.h mi/mi-console.h \
+mi/mi-out.h mi/mi-main.h mi/mi-common.h mi/mi-cmds.h linux-nat.h \
+complaints.h gdb_proc_service.h gdb_regex.h xtensa-tdep.h inf-loop.h \
+gdb_wait.h gdb_assert.h solib.h ppc-tdep.h cp-support.h glibc-tdep.h \
+interps.h auxv.h gdbcmd.h tramp-frame.h mipsnbsd-tdep.h	\
+amd64-linux-tdep.h linespec.h i387-tdep.h mn10300-tdep.h \
+sparc64-tdep.h monitor.h ppcobsd-tdep.h srec.h solib-pa64.h \
+coff-pe-read.h parser-defs.h gdb_ptrace.h mips-linux-tdep.h \
+m68k-tdep.h spu-tdep.h jv-lang.h environ.h solib-irix.h amd64-tdep.h \
+doublest.h regset.h hppa-tdep.h ppc-linux-tdep.h rs6000-tdep.h \
+gdb_locale.h gdb_dirent.h arch-utils.h trad-frame.h gnu-nat.h \
+language.h nbsd-tdep.h wrapper.h solib-svr4.h \
+macroexp.h ui-file.h regcache.h gdb_string.h tracepoint.h i386-tdep.h \
+inf-child.h p-lang.h event-top.h gdbtypes.h scm-tags.h user-regs.h \
+regformats/regdef.h config/alpha/nm-osf3.h config/i386/nm-cygwin.h \
+config/i386/nm-linux64.h config/i386/nm-i386gnu.h \
+config/i386/nm-fbsd.h config/i386/nm-i386sol2.h config/i386/nm-linux.h \
+config/i386/nm-i386.h config/i386/nm-go32.h config/nm-nto.h \
+config/sparc/nm-sol2.h config/nm-linux.h config/mips/nm-irix5.h	\
+config/rs6000/nm-rs6000.h top.h bsd-kvm.h gdb-stabs.h reggroups.h \
+annotate.h sim-regno.h dictionary.h dfp.h main.h frame-unwind.h	\
+remote-fileio.h i386-linux-tdep.h vax-tdep.h objc-lang.h \
+sentinel-frame.h bcache.h symfile.h windows-tdep.h linux-tdep.h \
+gdb_usleep.h
+
+# Header files that already have srcdir in them, or which are in objdir.
+
+HFILES_WITH_SRCDIR = ../bfd/bfd.h
+
+
+# GDB "info" files, which should be included in their entirety
+INFOFILES = gdb.info*
+
+REMOTE_EXAMPLES = m68k-stub.c i386-stub.c sparc-stub.c rem-multi.shar
+
+# {X,T,NAT}DEPFILES are something of a pain in that it's hard to
+# default their values the way we do for SER_HARDWIRE; in the future
+# maybe much of the stuff now in {X,T,NAT}DEPFILES will go into other
+# variables analogous to SER_HARDWIRE which get defaulted in this
+# Makefile.in
+
+DEPFILES = $(TARGET_OBS) $(SER_HARDWIRE) $(NATDEPFILES) \
+	   $(REMOTE_OBS) $(SIM_OBS)
+
+SOURCES = $(SFILES) $(ALLDEPFILES) $(YYFILES) $(CONFIG_SRCS)
+# Don't include YYFILES (*.c) because we already include *.y in SFILES,
+# and it's more useful to see it in the .y file.
+TAGFILES_NO_SRCDIR = $(SFILES) $(HFILES_NO_SRCDIR) $(ALLDEPFILES) \
+	$(CONFIG_SRCS)
+TAGFILES_WITH_SRCDIR = $(HFILES_WITH_SRCDIR)
+
+COMMON_OBS = $(DEPFILES) $(CONFIG_OBS) $(YYOBJ) \
+	version.o \
+	annotate.o \
+	addrmap.o \
+	auxv.o \
+	bfd-target.o \
+	blockframe.o breakpoint.o findvar.o regcache.o \
+	charset.o disasm.o dummy-frame.o dfp.o \
+	source.o value.o eval.o valops.o valarith.o valprint.o printcmd.o \
+	block.o symtab.o symfile.o symmisc.o linespec.o dictionary.o \
+	infcall.o \
+	infcmd.o infrun.o \
+	expprint.o environ.o stack.o thread.o \
+	exceptions.o \
+	inf-child.o \
+	interps.o \
+	main.o \
+	macrotab.o macrocmd.o macroexp.o macroscope.o \
+	event-loop.o event-top.o inf-loop.o completer.o \
+	gdbarch.o arch-utils.o gdbtypes.o osabi.o copying.o \
+	memattr.o mem-break.o target.o parse.o language.o buildsym.o \
+	findcmd.o \
+	std-regs.o \
+	signals.o \
+	exec.o reverse.o \
+	bcache.o objfiles.o observer.o minsyms.o maint.o demangle.o \
+	dbxread.o coffread.o coff-pe-read.o \
+	dwarf2read.o mipsread.o stabsread.o corefile.o \
+	dwarf2expr.o dwarf2loc.o dwarf2-frame.o \
+	ada-lang.o c-lang.o f-lang.o objc-lang.o \
+	ada-tasks.o \
+	ui-out.o cli-out.o \
+	varobj.o vec.o wrapper.o \
+	jv-lang.o jv-valprint.o jv-typeprint.o \
+	m2-lang.o p-lang.o p-typeprint.o p-valprint.o \
+	scm-exp.o scm-lang.o scm-valprint.o \
+	sentinel-frame.o \
+	complaints.o typeprint.o \
+	ada-typeprint.o c-typeprint.o f-typeprint.o m2-typeprint.o \
+	ada-valprint.o c-valprint.o cp-valprint.o f-valprint.o m2-valprint.o \
+	serial.o mdebugread.o top.o utils.o \
+	ui-file.o \
+	user-regs.o \
+	frame.o frame-unwind.o doublest.o \
+	frame-base.o \
+	gnu-v2-abi.o gnu-v3-abi.o cp-abi.o cp-support.o \
+	cp-namespace.o \
+	reggroups.o regset.o \
+	trad-frame.o \
+	tramp-frame.o \
+	solib.o solib-null.o \
+	prologue-value.o memory-map.o xml-support.o \
+	target-descriptions.o target-memory.o xml-tdesc.o xml-builtin.o \
+	inferior.o osdata.o gdb_usleep.o
+
+TSOBS = inflow.o
+
+SUBDIRS = @subdirs@
+CLEANDIRS = $(SUBDIRS) gnulib
+
+# For now, shortcut the "configure GDB for fewer languages" stuff.
+YYFILES = c-exp.c \
+	cp-name-parser.c \
+	objc-exp.c \
+	ada-lex.c \
+	ada-exp.c \
+	jv-exp.c \
+	f-exp.c m2-exp.c p-exp.c
+YYOBJ = c-exp.o \
+	cp-name-parser.o \
+	objc-exp.o \
+	ada-exp.o \
+	jv-exp.o \
+	f-exp.o m2-exp.o p-exp.o
+
+# Things which need to be built when making a distribution.
+
+DISTSTUFF = $(YYFILES)
+
+
+# All generated files which can be included by another file.
+generated_files = config.h observer.h observer.inc ada-lex.c \
+	$(GNULIB_H) $(NAT_GENERATED_FILES)
+
+.c.o:
+	$(COMPILE) $<
+	$(POSTCOMPILE)
+
+all: gdb$(EXEEXT) $(CONFIG_ALL)
+	@$(MAKE) $(FLAGS_TO_PASS) DO=all "DODIRS=`echo $(SUBDIRS) | sed 's/testsuite//'`" subdir_do
+.PHONY: all-tui
+all-tui: $(TUI)$(EXEEXT)
+
+installcheck:
+
+# The check target can not use subdir_do, because subdir_do does not
+# use TARGET_FLAGS_TO_PASS.
+check: force
+	@if [ -f testsuite/Makefile ]; then \
+	  rootme=`pwd`; export rootme; \
+	  rootsrc=`cd $(srcdir); pwd`; export rootsrc; \
+	  cd testsuite; \
+	  $(MAKE) $(TARGET_FLAGS_TO_PASS) check; \
+	else true; fi
+
+# The idea is to parallelize testing of multilibs, for example:
+#   make -j3 check//sh-hms-sim/{-m1,-m2,-m3,-m3e,-m4}/{,-nofpu}
+# will run 3 concurrent sessions of check, eventually testing all 10
+# combinations.  GNU make is required for the % pattern to work, as is
+# a shell that expands alternations within braces.  If GNU make is not
+# used, this rule will harmlessly fail to match.
+check//%: force
+	@if [ -f testsuite/config.status ]; then \
+	  rootme=`pwd`; export rootme; \
+	  rootsrc=`cd $(srcdir); pwd`; export rootsrc; \
+	  target=`echo "$@" | sed 's,//.*,,'`; \
+	  variant=`echo "$@" | sed 's,^[^/]*//,,'`; \
+	  vardots=`echo "$$variant" | sed 's,/,.,g'`; \
+	  testdir=testsuite.$$vardots; \
+	  if [ ! -f $$testdir/Makefile ]; then \
+	    (cd testsuite && find . -name config.status) | \
+	    sed s,/config.status$$,, | sort | while read subdir; do \
+	      $(SHELL) $(srcdir)/../mkinstalldirs $$testdir/$$subdir && \
+	      (cd $$testdir/$$subdir && \
+	       $(SHELL) $$rootme/testsuite/$$subdir/config.status \
+		 --recheck && \
+	       $(SHELL) ./config.status); done; \
+	  else :; fi && cd $$testdir && \
+	  $(MAKE) $(TARGET_FLAGS_TO_PASS) \
+	    RUNTESTFLAGS="--target_board=$$variant $(RUNTESTFLAGS)" \
+	    "$$target"; \
+	else true; fi
+
+info install-info clean-info dvi pdf install-pdf html install-html: force
+	@$(MAKE) $(FLAGS_TO_PASS) DO=$@ "DODIRS=$(SUBDIRS)" subdir_do
+
+gdb.z:gdb.1
+	nroff -man $(srcdir)/gdb.1 | col -b > gdb.t
+	pack gdb.t ; rm -f gdb.t
+	mv gdb.t.z gdb.z
+
+# Traditionally "install" depends on "all".  But it may be useful
+# not to; for example, if the user has made some trivial change to a
+# source file and doesn't care about rebuilding or just wants to save the
+# time it takes for make to check that all is up to date.
+# install-only is intended to address that need.
+install: all install-only
+install-only: $(CONFIG_INSTALL)
+	transformed_name=`t='$(program_transform_name)'; \
+			  echo gdb | sed -e "$$t"` ; \
+		if test "x$$transformed_name" = x; then \
+		  transformed_name=gdb ; \
+		else \
+		  true ; \
+		fi ; \
+		$(SHELL) $(srcdir)/../mkinstalldirs $(DESTDIR)$(bindir) ; \
+		$(INSTALL_PROGRAM) gdb$(EXEEXT) \
+			$(DESTDIR)$(bindir)/$$transformed_name$(EXEEXT) ; \
+		$(SHELL) $(srcdir)/../mkinstalldirs \
+			$(DESTDIR)$(man1dir) ; \
+		$(INSTALL_DATA) $(srcdir)/gdb.1 \
+			$(DESTDIR)$(man1dir)/$$transformed_name.1
+	@$(MAKE) DO=install "DODIRS=$(SUBDIRS)" $(FLAGS_TO_PASS) subdir_do
+.PHONY: install-tui
+install-tui:
+	transformed_name=`t='$(program_transform_name)'; \
+			  echo $(TUI) | sed -e "$$t"` ; \
+		if test "x$$transformed_name" = x; then \
+		  transformed_name=$(TUI) ; \
+		else \
+		  true ; \
+		fi ; \
+		$(SHELL) $(srcdir)/../mkinstalldirs $(DESTDIR)$(bindir) ; \
+		$(INSTALL_PROGRAM) $(TUI)$(EXEEXT) \
+			$(DESTDIR)$(bindir)/$$transformed_name$(EXEEXT) ; \
+		$(SHELL) $(srcdir)/../mkinstalldirs \
+			$(DESTDIR)$(man1dir) ; \
+		$(INSTALL_DATA) $(srcdir)/gdb.1 \
+			$(DESTDIR)$(man1dir)/$$transformed_name.1
+
+
+uninstall: force $(CONFIG_UNINSTALL)
+	transformed_name=`t='$(program_transform_name)'; \
+			  echo gdb | sed -e $$t` ; \
+		if test "x$$transformed_name" = x; then \
+		  transformed_name=gdb ; \
+		else \
+		  true ; \
+		fi ; \
+		rm -f $(DESTDIR)$(bindir)/$$transformed_name$(EXEEXT) \
+		      $(DESTDIR)$(man1dir)/$$transformed_name.1
+	@$(MAKE) DO=uninstall "DODIRS=$(SUBDIRS)" $(FLAGS_TO_PASS) subdir_do
+.PHONY: uninstall-tui
+uninstall-tui:
+	transformed_name=`t='$(program_transform_name)'; \
+			  echo $(TUI) | sed -e $$t` ; \
+		if test "x$$transformed_name" = x; then \
+		  transformed_name=$(TUI) ; \
+		else \
+		  true ; \
+		fi ; \
+		rm -f $(DESTDIR)$(bindir)/$$transformed_name$(EXEEXT) \
+		      $(DESTDIR)$(man1dir)/$$transformed_name.1
+
+# The C++ name parser can be built standalone for testing.
+test-cp-name-parser.o: cp-name-parser.c
+	$(COMPILE) -DTEST_CPNAMES cp-name-parser.c
+	$(POSTCOMPILE)
+
+test-cp-name-parser$(EXEEXT): test-cp-name-parser.o $(LIBIBERTY)
+	$(CC_LD) $(INTERNAL_LDFLAGS) -o test-cp-name-parser$(EXEEXT) \
+		test-cp-name-parser.o $(LIBIBERTY)
+
+# We do this by grepping through sources.  If that turns out to be too slow,
+# maybe we could just require every .o file to have an initialization routine
+# of a given name (top.o -> _initialize_top, etc.).
+#
+# Formatting conventions:  The name of the _initialize_* routines must start
+# in column zero, and must not be inside #if.
+#
+# Note that the set of files with init functions might change, or the names
+# of the functions might change, so this files needs to depend on all the
+# object files that will be linked into gdb.
+
+# FIXME: There is a problem with this approach - init.c may force
+# unnecessary files to be linked in.
+
+# FIXME: cagney/2002-06-09: gdb/564: gdb/563: Force the order so that
+# the first call is to _initialize_gdbtypes (implemented by explicitly
+# putting that function's name first in the init.l-tmp file).  This is
+# a hack to ensure that all the architecture dependant global
+# builtin_type_* variables are initialized before anything else
+# (per-architecture code is called in the same order that it is
+# registered).  The ``correct fix'' is to have all the builtin types
+# made part of the architecture and initialize them on-demand (using
+# gdbarch_data) just like everything else.  The catch is that other
+# modules still take the address of these builtin types forcing them
+# to be variables, sigh!
+
+# NOTE: cagney/2003-03-18: The sed pattern ``s|^\([^ /]...'' is
+# anchored on the first column and excludes the ``/'' character so
+# that it doesn't add the $(srcdir) prefix to any file that already
+# has an absolute path.  It turns out that $(DEC)'s True64 make
+# automatically adds the $(srcdir) prefixes when it encounters files
+# in sub-directories such as cli/ and mi/.
+
+# NOTE: cagney/2004-02-08: The ``case "$$fs" in'' eliminates
+# duplicates.  Files in the gdb/ directory can end up appearing in
+# COMMON_OBS (as a .o file) and CONFIG_SRCS (as a .c file).
+
+INIT_FILES = $(COMMON_OBS) $(TSOBS) $(CONFIG_SRCS)
+init.c: $(INIT_FILES)
+	@echo Making init.c
+	@rm -f init.c-tmp init.l-tmp
+	@touch init.c-tmp
+	@echo gdbtypes > init.l-tmp
+	@-LANG=C ; export LANG ; \
+	LC_ALL=C ; export LC_ALL ; \
+	echo $(INIT_FILES) | \
+	tr ' ' '\012' | \
+	sed \
+	    -e '/^gdbtypes.[co]$$/d' \
+	    -e '/^init.[co]$$/d' \
+	    -e '/xdr_ld.[co]$$/d' \
+	    -e '/xdr_ptrace.[co]$$/d' \
+	    -e '/xdr_rdb.[co]$$/d' \
+	    -e '/udr.[co]$$/d' \
+	    -e '/udip2soc.[co]$$/d' \
+	    -e '/udi2go32.[co]$$/d' \
+	    -e '/version.[co]$$/d' \
+	    -e '/^[a-z0-9A-Z_]*_[SU].[co]$$/d' \
+	    -e '/[a-z0-9A-Z_]*-exp.tab.[co]$$/d' \
+	    -e 's/\.[co]$$/.c/' \
+	    -e 's,signals\.c,common/signals\.c,' \
+	    -e 's|^\([^  /][^     ]*\)|$(srcdir)/\1|g' | \
+	while read f; do \
+	    sed -n -e 's/^_initialize_\([a-z_0-9A-Z]*\).*/\1/p' $$f 2>/dev/null; \
+	done | \
+	while read f; do \
+	    case " $$fs " in \
+	        *" $$f "* ) ;; \
+	        * ) echo $$f ; fs="$$fs $$f";; \
+            esac; \
+	done >> init.l-tmp
+	@echo '/* Do not modify this file.  */' >>init.c-tmp
+	@echo '/* It is created automatically by the Makefile.  */'>>init.c-tmp
+	@echo '#include "defs.h"      /* For initialize_file_ftype.  */' >>init.c-tmp
+	@echo '#include "call-cmds.h" /* For initialize_all_files.  */' >>init.c-tmp
+	@sed -e 's/\(.*\)/extern initialize_file_ftype _initialize_\1;/' <init.l-tmp >>init.c-tmp
+	@echo 'void' >>init.c-tmp
+	@echo 'initialize_all_files (void)' >>init.c-tmp
+	@echo '{' >>init.c-tmp
+	@sed -e 's/\(.*\)/  _initialize_\1 ();/' <init.l-tmp >>init.c-tmp
+	@echo '}' >>init.c-tmp
+	@rm init.l-tmp
+	@mv init.c-tmp init.c
+
+.PRECIOUS: init.c
+
+# Removing the old gdb first works better if it is running, at least on SunOS.
+gdb$(EXEEXT): gdb.o libgdb.a $(ADD_DEPS) $(CDEPS) $(TDEPLIBS)
+	rm -f gdb$(EXEEXT)
+	$(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
+		-o gdb$(EXEEXT) gdb.o libgdb.a \
+		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
+
+$(TUI)$(EXEEXT): tui-main.o libgdb.a $(ADD_DEPS) $(CDEPS) $(TDEPLIBS)
+	rm -f $(TUI)$(EXEEXT)
+	$(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
+		-o $(TUI)$(EXEEXT) tui-main.o libgdb.a \
+		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
+
+# Convenience rule to handle recursion.
+$(LIBGNU) $(GNULIB_H): all-lib
+all-lib: gnulib/Makefile
+	@$(MAKE) $(FLAGS_TO_PASS) DO=all DODIRS=gnulib subdir_do
+.PHONY: all-lib
+
+# Create a library of the gdb object files and build GDB by linking
+# against that.
+#
+# init.o is very important.  It pulls in the rest of GDB.
+LIBGDB_OBS= $(COMMON_OBS) $(TSOBS) $(ADD_FILES) init.o
+libgdb.a: $(LIBGDB_OBS)
+	-rm -f libgdb.a
+	$(AR) q libgdb.a $(LIBGDB_OBS)
+	$(RANLIB) libgdb.a
+
+# This is useful when debugging GDB, because some Unix's don't let you run GDB
+# on itself without copying the executable.  So "make gdb1" will make
+# gdb and put a copy in gdb1, and you can run it with "gdb gdb1".
+# Removing gdb1 before the copy is the right thing if gdb1 is open
+# in another process.
+gdb1$(EXEEXT): gdb$(EXEEXT)
+	rm -f gdb1$(EXEEXT)
+	cp gdb$(EXEEXT) gdb1$(EXEEXT)
+
+# Put the proper machine-specific files first, so M-. on a machine
+# specific routine gets the one for the correct machine.  (FIXME: those
+# files go in twice; we should be removing them from the main list).
+
+# TAGS depends on all the files that go into it so you can rebuild TAGS
+# with `make TAGS' and not have to say `rm TAGS' first.
+
+TAGS: $(DEPFILES) $(TAGFILES_NO_SRCDIR) $(TAGFILES_WITH_SRCDIR)
+	@echo Making TAGS
+	@etags $(srcdir)/$(NAT_FILE) \
+	`(for i in $(DEPFILES) $(TAGFILES_NO_SRCDIR); do \
+		echo $(srcdir)/$$i ; \
+	done ; for i in $(TAGFILES_WITH_SRCDIR); do \
+		echo $$i ; \
+	done) | sed -e 's/\.o$$/\.c/'` \
+	`find $(srcdir)/config -name '*.h' -print`
+
+tags: TAGS
+
+clean mostlyclean: $(CONFIG_CLEAN)
+	@$(MAKE) $(FLAGS_TO_PASS) DO=clean "DODIRS=$(CLEANDIRS)" subdir_do
+	rm -f *.o *.a $(ADD_FILES) *~ init.c-tmp init.l-tmp version.c-tmp
+	rm -f init.c version.c
+	rm -f gdb$(EXEEXT) core make.log
+	rm -f gdb[0-9]$(EXEEXT)
+	rm -f test-cp-name-parser$(EXEEXT)
+	rm -f xml-builtin.c stamp-xml
+	rm -f $(DEPDIR)/*
+
+.PHONY: clean-tui
+clean-tui:
+	rm -f $(TUI)$(EXEEXT)
+
+# This used to depend on c-exp.c m2-exp.c TAGS
+# I believe this is wrong; the makefile standards for distclean just
+# describe removing files; the only sort of "re-create a distribution"
+# functionality described is if the distributed files are unmodified.
+# NB: While GDBSERVER might be configured on native systems, it isn't
+# always included in SUBDIRS.  Remove the gdbserver files explicitly.
+distclean: clean
+	@$(MAKE) $(FLAGS_TO_PASS) DO=distclean "DODIRS=$(CLEANDIRS)" subdir_do
+	rm -f gdbserver/config.status gdbserver/config.log
+	rm -f gdbserver/tm.h gdbserver/xm.h gdbserver/nm.h
+	rm -f gdbserver/Makefile gdbserver/config.cache
+	rm -f nm.h config.status config.h stamp-h .gdbinit
+	rm -f y.output yacc.acts yacc.tmp y.tab.h
+	rm -f config.log config.cache
+	rm -f Makefile
+	rm -rf $(DEPDIR)
+
+maintainer-clean: local-maintainer-clean do-maintainer-clean distclean
+realclean: maintainer-clean
+
+local-maintainer-clean:
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+	rm -f c-exp.c \
+		cp-name-parser.c \
+		ada-lex.c ada-exp.c \
+	        objc-exp.c \
+		jv-exp.tab \
+		f-exp.c m2-exp.c p-exp.c
+	rm -f TAGS $(INFOFILES)
+	rm -f $(YYFILES)
+	rm -f nm.h config.status
+
+do-maintainer-clean:
+	@$(MAKE) $(FLAGS_TO_PASS) DO=maintainer-clean "DODIRS=$(CLEANDIRS)" \
+		subdir_do
+
+diststuff: $(DISTSTUFF) $(PACKAGE).pot $(CATALOGS)
+	cd doc; $(MAKE) $(MFLAGS) diststuff
+
+subdir_do: force
+	@for i in $(DODIRS); do \
+		if [ -f ./$$i/Makefile ] ; then \
+			if (cd ./$$i; \
+				$(MAKE) $(FLAGS_TO_PASS) $(DO)) ; then true ; \
+			else exit 1 ; fi ; \
+		else true ; fi ; \
+	done
+
+Makefile: Makefile.in config.status @frags@
+	# Regenerate the Makefile and the tm.h / nm.h links.
+	CONFIG_FILES="Makefile" \
+	  CONFIG_COMMANDS= \
+	  CONFIG_HEADERS= \
+	  $(SHELL) config.status
+
+gnulib/Makefile: gnulib/Makefile.in gnulib/Makefile.in config.status @frags@
+	CONFIG_FILES="gnulib/Makefile" \
+	  CONFIG_COMMANDS="depfiles" \
+	  CONFIG_HEADERS= \
+	  CONFIG_LINKS= \
+	  $(SHELL) config.status
+
+config.h: stamp-h ; @true
+stamp-h: config.in config.status
+	CONFIG_HEADERS=config.h:config.in \
+	  CONFIG_COMMANDS="default depdir" \
+	  CONFIG_FILES= \
+	  CONFIG_LINKS= \
+	  $(SHELL) config.status
+
+config.status: configure configure.tgt configure.host
+	$(SHELL) config.status --recheck
+
+force:
+
+# Documentation!
+# GDB QUICK REFERENCE (TeX dvi file, CM fonts)
+doc/refcard.dvi:
+	cd doc; $(MAKE) refcard.dvi $(FLAGS_TO_PASS)
+
+# GDB QUICK REFERENCE (PostScript output, common PS fonts)
+doc/refcard.ps:
+	cd doc; $(MAKE) refcard.ps $(FLAGS_TO_PASS)
+
+# GDB MANUAL: TeX dvi file
+doc/gdb.dvi:
+	cd doc; $(MAKE) gdb.dvi $(FLAGS_TO_PASS)
+
+# GDB MANUAL: info file
+doc/gdb.info:
+	cd doc; $(MAKE) gdb.info $(FLAGS_TO_PASS)
+
+# Make copying.c from COPYING
+$(srcdir)/copying.c: @MAINTAINER_MODE_TRUE@ $(srcdir)/../COPYING3 $(srcdir)/copying.awk
+	awk -f $(srcdir)/copying.awk \
+		< $(srcdir)/../COPYING3 > $(srcdir)/copying.tmp
+	mv $(srcdir)/copying.tmp $(srcdir)/copying.c
+
+version.c: Makefile version.in
+	rm -f version.c-tmp version.c
+	echo '#include "version.h"' >> version.c-tmp
+	echo 'const char version[] = "'"`sed q ${srcdir}/version.in`"'";' >> version.c-tmp
+	echo 'const char host_name[] = "$(host_alias)";' >> version.c-tmp
+	echo 'const char target_name[] = "$(target_alias)";' >> version.c-tmp
+	mv version.c-tmp version.c
+
+observer.h: observer.sh doc/observer.texi
+	${srcdir}/observer.sh h ${srcdir}/doc/observer.texi observer.h
+
+observer.inc: observer.sh doc/observer.texi
+	${srcdir}/observer.sh inc ${srcdir}/doc/observer.texi observer.inc
+
+lint: $(LINTFILES)
+	$(LINT) $(INCLUDE_CFLAGS) $(LINTFLAGS) $(LINTFILES) \
+	   `echo $(DEPFILES) $(CONFIG_OBS) | sed 's/\.o /\.c /g'`
+
+gdb.cxref: $(SFILES)
+	cxref -I. $(SFILES) >gdb.cxref
+
+force_update:
+
+# GNU Make has an annoying habit of putting *all* the Makefile variables
+# into the environment, unless you include this target as a circumvention.
+# Rumor is that this will be fixed (and this target can be removed)
+# in GNU Make 4.0.
+.NOEXPORT:
+
+# GNU Make 3.63 has a different problem: it keeps tacking command line
+# overrides onto the definition of $(MAKE).  This variable setting
+# will remove them.
+MAKEOVERRIDES=
+
+ALLDEPFILES = \
+	aix-thread.c \
+	alpha-nat.c alphabsd-nat.c alpha-linux-nat.c \
+	alpha-tdep.c alpha-mdebug-tdep.c \
+	alpha-linux-tdep.c alpha-osf1-tdep.c \
+	alphabsd-tdep.c alphafbsd-tdep.c alphanbsd-tdep.c alphaobsd-tdep.c \
+	amd64-nat.c amd64-tdep.c \
+	amd64bsd-nat.c amd64fbsd-nat.c amd64fbsd-tdep.c \
+	amd64nbsd-nat.c amd64nbsd-tdep.c \
+	amd64obsd-nat.c amd64obsd-tdep.c \
+	amd64-dicos-tdep.c \
+	amd64-linux-nat.c amd64-linux-tdep.c \
+	amd64-sol2-tdep.c \
+	arm-linux-nat.c arm-linux-tdep.c arm-tdep.c \
+	armnbsd-nat.c armbsd-tdep.c armnbsd-tdep.c armobsd-tdep.c \
+	avr-tdep.c \
+	bsd-uthread.c bsd-kvm.c \
+	core-regset.c corelow.c \
+	dcache.c dicos-tdep.c \
+	exec.c \
+	fbsd-nat.c \
+	fork-child.c \
+	glibc-tdep.c \
+	go32-nat.c h8300-tdep.c \
+	hppa-tdep.c hppa-hpux-tdep.c hppa-hpux-nat.c \
+	hppa-linux-tdep.c hppa-linux-nat.c \
+	hppabsd-nat.c hppabsd-tdep.c \
+	hppaobsd-tdep.c \
+	hppanbsd-nat.c hppanbsd-tdep.c \
+	i386-tdep.c i386-linux-nat.c \
+	i386v4-nat.c i386-cygwin-tdep.c \
+	i386bsd-nat.c i386bsd-tdep.c i386fbsd-nat.c i386fbsd-tdep.c \
+	i386nbsd-nat.c i386nbsd-tdep.c i386obsd-nat.c i386obsd-tdep.c \
+	i387-tdep.c \
+	i386-dicos-tdep.c \
+	i386-linux-tdep.c i386-nat.c \
+	i386-sol2-nat.c i386-sol2-tdep.c \
+	i386gnu-nat.c i386gnu-tdep.c \
+	ia64-linux-nat.c ia64-linux-tdep.c ia64-tdep.c \
+	inf-ptrace.c inf-ttrace.c \
+	irix5-nat.c \
+	libunwind-frame.c \
+	linux-fork.c \
+	linux-tdep.c \
+	m68hc11-tdep.c \
+	m32r-tdep.c \
+	m32r-linux-nat.c m32r-linux-tdep.c \
+	m68k-tdep.c \
+	m68kbsd-nat.c m68kbsd-tdep.c \
+	m68klinux-nat.c m68klinux-tdep.c \
+	m88k-tdep.c m88kbsd-nat.c \
+	mingw-hdep.c \
+	mips-linux-nat.c mips-linux-tdep.c \
+	mips-irix-tdep.c \
+	mips-tdep.c \
+	mipsnbsd-nat.c mipsnbsd-tdep.c \
+	mips64obsd-nat.c mips64obsd-tdep.c \
+	nbsd-nat.c nbsd-tdep.c obsd-tdep.c \
+	solib-osf.c \
+	solib-target.c \
+	somread.c solib-som.c \
+	posix-hdep.c \
+	ppc-sysv-tdep.c ppc-linux-nat.c ppc-linux-tdep.c \
+	ppcnbsd-nat.c ppcnbsd-tdep.c \
+	ppcobsd-nat.c ppcobsd-tdep.c \
+	procfs.c \
+	remote-m32r-sdi.c remote-mips.c \
+	remote-sim.c \
+	dcache.c \
+	rs6000-nat.c rs6000-tdep.c \
+	s390-tdep.c s390-nat.c \
+	score-tdep.c \
+	ser-go32.c ser-pipe.c ser-tcp.c ser-mingw.c \
+	sh-tdep.c sh64-tdep.c shnbsd-tdep.c shnbsd-nat.c \
+	sol2-tdep.c \
+	solib-irix.c solib-svr4.c solib-sunos.c \
+	sparc-linux-nat.c \
+	sparc-linux-tdep.c sparc-nat.c sparc-sol2-nat.c sparc-sol2-tdep.c \
+	sparc-tdep.c sparc-sol2-nat.c sparc-sol2-tdep.c sparc64-linux-nat.c \
+	sparc64-linux-tdep.c sparc64-nat.c sparc64-sol2-tdep.c \
+	sparc64-tdep.c sparc64fbsd-nat.c sparc64fbsd-tdep.c \
+	sparc64nbsd-nat.c sparc64nbsd-tdep.c sparc64obsd-tdep.c \
+	sparcnbsd-nat.c sparcnbsd-tdep.c sparcobsd-tdep.c \
+	spu-linux-nat.c spu-tdep.c \
+	v850-tdep.c \
+	vax-nat.c vax-tdep.c vaxbsd-nat.c vaxnbsd-tdep.c \
+	windows-nat.c windows-tdep.c \
+	xcoffread.c xcoffsolib.c \
+	xstormy16-tdep.c \
+	xtensa-tdep.c xtensa-config.c \
+	xtensa-linux-tdep.c xtensa-linux-nat.c xtensa-xtregs.c
+
+# Some files need explicit build rules (due to -Werror problems) or due
+# to sub-directory fun 'n' games.
+
+hpux-thread.o: $(srcdir)/hpux-thread.c
+	$(COMPILE) -I$(srcdir)/osf-share -I$(srcdir)/osf-share/HP800 \
+		-I/usr/include/dce $(srcdir)/hpux-thread.c
+	$(POSTCOMPILE)
+
+# main.o needs an explicit build rule to get TARGET_SYSTEM_ROOT and BINDIR.
+main.o: $(srcdir)/main.c
+	$(COMPILE) $(TARGET_SYSTEM_ROOT_DEFINE) -DBINDIR=\"$(bindir)\" $(srcdir)/main.c
+	$(POSTCOMPILE)
+
+# FIXME: cagney/2003-08-10: "monitor.c" gets -Wformat-nonliteral
+# errors.  It turns out that that is the least of monitor.c's
+# problems.  The function print_vsprintf appears to be using
+# va_arg(long) to extract CORE_ADDR parameters - something that
+# definitly will not work.  "monitor.c" needs to be rewritten so that
+# it doesn't use format strings and instead uses callbacks.
+monitor.o: $(srcdir)/monitor.c
+	$(COMPILE.pre) $(INTERNAL_WARN_CFLAGS) $(COMPILE.post) $(srcdir)/monitor.c
+	$(POSTCOMPILE)
+
+# Do not try to build "printcmd.c" with -Wformat-nonliteral.  It manually
+# checks format strings.
+printcmd.o: $(srcdir)/printcmd.c
+	$(COMPILE.pre) $(INTERNAL_CFLAGS_BASE) $(GDB_WARN_CFLAGS_NO_FORMAT) \
+		$(GDB_WERROR_CFLAGS) $(COMPILE.post) $(srcdir)/printcmd.c
+	$(POSTCOMPILE)
+
+# Message files.  Based on code in gcc/Makefile.in.
+
+# Rules for generating translated message descriptions.  Disabled by
+# autoconf if the tools are not available.
+
+.SUFFIXES: .po .gmo .pox .pot
+.PHONY: all-po install-po uninstall-po clean-po update-po $(PACKAGE).pot
+
+all-po: $(CATALOGS)
+
+# This notation should be acceptable to all Make implementations used
+# by people who are interested in updating .po files.
+update-po: $(CATALOGS:.gmo=.pox)
+
+# N.B. We do not attempt to copy these into $(srcdir).  The snapshot
+# script does that.
+.po.gmo:
+	-test -d po || mkdir po
+	$(GMSGFMT) --statistics -o $@ $<
+
+# The new .po has to be gone over by hand, so we deposit it into
+# build/po with a different extension.  If build/po/$(PACKAGE).pot
+# exists, use it (it was just created), else use the one in srcdir.
+.po.pox:
+	-test -d po || mkdir po
+	$(MSGMERGE) $< `if test -f po/$(PACKAGE).pot; \
+			then echo po/$(PACKAGE).pot; \
+			else echo $(srcdir)/po/$(PACKAGE).pot; fi` -o $@
+
+# This rule has to look for .gmo modules in both srcdir and the cwd,
+# and has to check that we actually have a catalog for each language,
+# in case they weren't built or included with the distribution.
+install-po:
+	$(SHELL) $(srcdir)/../mkinstalldirs $(DESTDIR)$(datadir)
+	cats="$(CATALOGS)"; for cat in $$cats; do \
+	  lang=`basename $$cat | sed 's/\.gmo$$//'`; \
+	  if [ -f $$cat ]; then :; \
+	  elif [ -f $(srcdir)/$$cat ]; then cat=$(srcdir)/$$cat; \
+	  else continue; \
+	  fi; \
+	  dir=$(localedir)/$$lang/LC_MESSAGES; \
+	  echo $(SHELL) $(srcdir)/../mkinstalldirs $(DESTDIR)$$dir; \
+	  $(SHELL) $(srcdir)/../mkinstalldirs $(DESTDIR)$$dir || exit 1; \
+	  echo $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/$(PACKAGE).mo; \
+	  $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/$(PACKAGE).mo; \
+	done
+uninstall-po:
+	cats="$(CATALOGS)"; for cat in $$cats; do \
+	  lang=`basename $$cat | sed 's/\.gmo$$//'`; \
+	  if [ -f $$cat ]; then :; \
+	  elif [ -f $(srcdir)/$$cat ]; then cat=$(srcdir)/$$cat; \
+	  else continue; \
+	  fi; \
+	  dir=$(localedir)/$$lang/LC_MESSAGES; \
+	  rm -f $(DESTDIR)$$dir/$(PACKAGE).mo; \
+	done
+# Delete po/*.gmo only if we are not building in the source directory.
+clean-po:
+	-if [ ! -f Makefile.in ]; then rm -f po/*.gmo; fi
+
+# Rule for regenerating the message template (gdb.pot).  Instead of
+# forcing everyone to edit POTFILES.in, which proved impractical, this
+# rule has no dependencies and always regenerates gdb.pot.  This is
+# relatively harmless since the .po files do not directly depend on
+# it.  The .pot file is left in the build directory.  Since GDB's
+# Makefile lacks a cannonical list of sources (missing xm, tm and nm
+# files) force this rule.
+$(PACKAGE).pot: po/$(PACKAGE).pot
+po/$(PACKAGE).pot: force
+	-test -d po || mkdir po
+	sh -e $(srcdir)/po/gdbtext $(XGETTEXT) $(PACKAGE) . $(srcdir)
+
+
+#
+# YACC/LEX dependencies
+#
+# LANG-exp.c is generated in objdir from LANG-exp.y if it doesn't
+# exist in srcdir, then compiled in objdir to LANG-exp.o.  If we
+# said LANG-exp.c rather than ./c-exp.c some makes would
+# sometimes re-write it into $(srcdir)/c-exp.c.  Remove bogus
+# decls for malloc/realloc/free which conflict with everything else.
+# Strictly speaking c-exp.c should therefore depend on
+# Makefile.in, but that was a pretty big annoyance.
+
+.SUFFIXES: .y .l
+.y.c:
+	$(SHELL) $(YLWRAP) $< y.tab.c $@.tmp -- $(YACC) $(YFLAGS)
+	-sed -e '/extern.*malloc/d' \
+	     -e '/extern.*realloc/d' \
+	     -e '/extern.*free/d' \
+	     -e '/include.*malloc.h/d' \
+	     -e 's/\([^x]\)malloc/\1xmalloc/g' \
+	     -e 's/\([^x]\)realloc/\1xrealloc/g' \
+	     -e 's/\([ \t;,(]\)free\([ \t]*[&(),]\)/\1xfree\2/g' \
+	     -e 's/\([ \t;,(]\)free$$/\1xfree/g' \
+	     -e '/^#line.*y.tab.c/d' \
+	  < $@.tmp > $@.new
+	-rm $@.tmp
+	mv $@.new ./$*.c
+.l.c:
+	if [ "$(FLEX)" ] && $(FLEX) --version >/dev/null 2>&1; then \
+	    $(FLEX) -o$@ $< && \
+	    rm -f $@.new && \
+	    sed -e '/extern.*malloc/d' \
+	        -e '/extern.*realloc/d' \
+	        -e '/extern.*free/d' \
+	        -e '/include.*malloc.h/d' \
+	        -e 's/\([^x]\)malloc/\1xmalloc/g' \
+	        -e 's/\([^x]\)realloc/\1xrealloc/g' \
+	        -e 's/\([ \t;,(]\)free\([ \t]*[&(),]\)/\1xfree\2/g' \
+	        -e 's/\([ \t;,(]\)free$$/\1xfree/g' \
+		-e 's/yy_flex_xrealloc/yyxrealloc/g' \
+	      < $@ > $@.new && \
+	    rm -f $@ && \
+	    mv $@.new $@; \
+	elif [ -f $@ ]; then \
+	    echo "Warning: $*.c older than $*.l and flex not available."; \
+	else \
+	    echo "$@ missing and flex not available."; \
+	    false; \
+	fi
+
+.PRECIOUS: ada-exp.c ada-lex.c
+.PRECIOUS: c-exp.c
+.PRECIOUS: f-exp.c
+.PRECIOUS: jv-exp.c
+.PRECIOUS: m2-exp.c
+.PRECIOUS: objc-exp.c
+.PRECIOUS: p-exp.c
+
+# XML rules
+
+xml-builtin.c: stamp-xml; @true
+stamp-xml: $(srcdir)/features/feature_to_c.sh Makefile $(XMLFILES)
+	rm -f xml-builtin.tmp
+	AWK="$(AWK)" \
+	  $(SHELL) $(srcdir)/features/feature_to_c.sh \
+	  xml-builtin.tmp $(XMLFILES)
+	$(SHELL) $(srcdir)/../move-if-change xml-builtin.tmp xml-builtin.c
+	echo stamp > stamp-xml
+
+.PRECIOUS: xml-builtin.c
+
+#
+# gdb/cli/ dependencies
+#
+# Need to explicitly specify the compile rule as make will do nothing
+# or try to compile the object file into the sub-directory.
+
+cli-cmds.o: $(srcdir)/cli/cli-cmds.c
+	$(COMPILE) $(srcdir)/cli/cli-cmds.c
+	$(POSTCOMPILE)
+
+cli-decode.o: $(srcdir)/cli/cli-decode.c
+	$(COMPILE) $(srcdir)/cli/cli-decode.c
+	$(POSTCOMPILE)
+
+cli-dump.o: $(srcdir)/cli/cli-dump.c
+	$(COMPILE) $(srcdir)/cli/cli-dump.c
+	$(POSTCOMPILE)
+
+cli-interp.o: $(srcdir)/cli/cli-interp.c
+	$(COMPILE) $(srcdir)/cli/cli-interp.c
+	$(POSTCOMPILE)
+
+cli-logging.o: $(srcdir)/cli/cli-logging.c
+	$(COMPILE) $(srcdir)/cli/cli-logging.c
+	$(POSTCOMPILE)
+
+cli-script.o: $(srcdir)/cli/cli-script.c
+	$(COMPILE) $(srcdir)/cli/cli-script.c
+	$(POSTCOMPILE)
+
+cli-setshow.o: $(srcdir)/cli/cli-setshow.c
+	$(COMPILE) $(srcdir)/cli/cli-setshow.c
+	$(POSTCOMPILE)
+
+
+#
+# GDBTK sub-directory
+#
+# Need to explicitly specify the compile rule as make will do nothing
+# or try to compile the object file into the mi directory.
+
+all-gdbtk: insight$(EXEEXT)
+
+install-gdbtk:
+	transformed_name=`t='$(program_transform_name)'; \
+		  echo insight | sed -e $$t` ; \
+	if test "x$$transformed_name" = x; then \
+	  transformed_name=insight ; \
+	else \
+	  true ; \
+	fi ; \
+	$(SHELL) $(srcdir)/../mkinstalldirs $(DESTDIR)$(bindir); \
+	$(INSTALL_PROGRAM) insight$(EXEEXT) \
+		$(DESTDIR)$(bindir)/$$transformed_name$(EXEEXT) ; \
+	$(SHELL) $(srcdir)/../mkinstalldirs \
+		$(DESTDIR)$(GDBTK_LIBRARY) ; \
+	$(SHELL) $(srcdir)/../mkinstalldirs \
+		$(DESTDIR)$(libdir)/insight$(GDBTK_VERSION) ; \
+	$(INSTALL_DATA) $(srcdir)/gdbtk/plugins/plugins.tcl \
+		$(DESTDIR)$(libdir)/insight$(GDBTK_VERSION)/plugins.tcl ; \
+	$(SHELL) $(srcdir)/../mkinstalldirs \
+		$(DESTDIR)$(GDBTK_LIBRARY)/images \
+		$(DESTDIR)$(GDBTK_LIBRARY)/images2 ; \
+	$(SHELL) $(srcdir)/../mkinstalldirs \
+		$(DESTDIR)$(GDBTK_LIBRARY)/help \
+		$(DESTDIR)$(GDBTK_LIBRARY)/help/images \
+		$(DESTDIR)$(GDBTK_LIBRARY)/help/trace ; \
+	cd $(srcdir)/gdbtk/library ; \
+	for i in *.tcl *.itcl *.ith *.itb images/*.gif images2/*.gif images/icons.txt images2/icons.txt tclIndex help/*.html  help/trace/*.html help/trace/index.toc help/images/*.gif help/images/*.png; \
+	  do \
+		$(INSTALL_DATA) $$i $(DESTDIR)$(GDBTK_LIBRARY)/$$i ; \
+	  done ;
+
+uninstall-gdbtk:
+	transformed_name=`t='$(program_transform_name)'; \
+		  echo insight | sed -e $$t` ; \
+	if test "x$$transformed_name" = x; then \
+		transformed_name=insight ; \
+	else \
+		true ; \
+	fi ; \
+	rm -f $(DESTDIR)$(bindir)/$$transformed_name$(EXEEXT) ; \
+	rm -rf $(DESTDIR)$(GDBTK_LIBRARY)
+
+clean-gdbtk:
+	rm -f insight$(EXEEXT)
+
+# Removing the old gdb first works better if it is running, at least on SunOS.
+insight$(EXEEXT): gdbtk-main.o libgdb.a $(ADD_DEPS) \
+		$(CDEPS) $(TDEPLIBS)
+	rm -f insight$(EXEEXT)
+	$(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
+		-o insight$(EXEEXT) gdbtk-main.o libgdb.a \
+		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
+
+gdbres.o: $(srcdir)/gdbtk/gdb.rc $(srcdir)/gdbtk/gdbtool.ico
+	$(WINDRES) --include $(srcdir)/gdbtk $(srcdir)/gdbtk/gdb.rc gdbres.o
+
+all_gdbtk_cflags = $(IDE_CFLAGS) $(ITCL_CFLAGS) \
+		$(ITK_CFLAGS) $(TCL_CFLAGS) $(TK_CFLAGS) $(X11_CFLAGS) \
+		$(GDBTK_CFLAGS) \
+		-DGDBTK_LIBRARY=\"$(GDBTK_LIBRARY)\" \
+		-DSRC_DIR=\"$(GDBTK_SRC_DIR)\"
+
+gdbtk.o: $(srcdir)/gdbtk/generic/gdbtk.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk.c
+	$(POSTCOMPILE)
+
+gdbtk-bp.o: $(srcdir)/gdbtk/generic/gdbtk-bp.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk-bp.c
+	$(POSTCOMPILE)
+
+gdbtk-cmds.o: $(srcdir)/gdbtk/generic/gdbtk-cmds.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk-cmds.c
+	$(POSTCOMPILE)
+
+gdbtk-hooks.o: $(srcdir)/gdbtk/generic/gdbtk-hooks.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk-hooks.c
+	$(POSTCOMPILE)
+
+gdbtk-interp.o: $(srcdir)/gdbtk/generic/gdbtk-interp.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk-interp.c
+	$(POSTCOMPILE)
+
+gdbtk-main.o: $(srcdir)/gdbtk/generic/gdbtk-main.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk-main.c
+	$(POSTCOMPILE)
+
+gdbtk-register.o: $(srcdir)/gdbtk/generic/gdbtk-register.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk-register.c
+	$(POSTCOMPILE)
+
+gdbtk-stack.o: $(srcdir)/gdbtk/generic/gdbtk-stack.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk-stack.c
+	$(POSTCOMPILE)
+
+gdbtk-varobj.o: $(srcdir)/gdbtk/generic/gdbtk-varobj.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk-varobj.c
+	$(POSTCOMPILE)
+
+gdbtk-wrapper.o: $(srcdir)/gdbtk/generic/gdbtk-wrapper.c
+	$(COMPILE) $(all_gdbtk_cflags) $(srcdir)/gdbtk/generic/gdbtk-wrapper.c
+	$(POSTCOMPILE)
+
+
+#
+# gdb/mi/ dependencies
+#
+# Need to explicitly specify the compile rule as make will do nothing
+# or try to compile the object file into the sub-directory.
+
+mi-cmd-break.o: $(srcdir)/mi/mi-cmd-break.c
+	$(COMPILE) $(srcdir)/mi/mi-cmd-break.c
+	$(POSTCOMPILE)
+
+mi-cmd-disas.o: $(srcdir)/mi/mi-cmd-disas.c
+	$(COMPILE) $(srcdir)/mi/mi-cmd-disas.c
+	$(POSTCOMPILE)
+
+mi-cmd-env.o: $(srcdir)/mi/mi-cmd-env.c
+	$(COMPILE) $(srcdir)/mi/mi-cmd-env.c
+	$(POSTCOMPILE)
+
+mi-cmd-file.o: $(srcdir)/mi/mi-cmd-file.c
+	$(COMPILE) $(srcdir)/mi/mi-cmd-file.c
+	$(POSTCOMPILE)
+
+mi-cmds.o: $(srcdir)/mi/mi-cmds.c
+	$(COMPILE) $(srcdir)/mi/mi-cmds.c
+	$(POSTCOMPILE)
+
+mi-cmd-stack.o: $(srcdir)/mi/mi-cmd-stack.c
+	$(COMPILE) $(srcdir)/mi/mi-cmd-stack.c
+	$(POSTCOMPILE)
+
+mi-cmd-target.o: $(srcdir)/mi/mi-cmd-target.c
+	$(COMPILE) $(srcdir)/mi/mi-cmd-target.c
+	$(POSTCOMPILE)
+
+mi-cmd-var.o: $(srcdir)/mi/mi-cmd-var.c
+	$(COMPILE) $(srcdir)/mi/mi-cmd-var.c
+	$(POSTCOMPILE)
+
+mi-console.o: $(srcdir)/mi/mi-console.c
+	$(COMPILE) $(srcdir)/mi/mi-console.c
+	$(POSTCOMPILE)
+
+mi-getopt.o: $(srcdir)/mi/mi-getopt.c
+	$(COMPILE) $(srcdir)/mi/mi-getopt.c
+	$(POSTCOMPILE)
+
+mi-interp.o: $(srcdir)/mi/mi-interp.c
+	$(COMPILE) $(srcdir)/mi/mi-interp.c
+	$(POSTCOMPILE)
+
+mi-main.o: $(srcdir)/mi/mi-main.c
+	$(COMPILE) $(srcdir)/mi/mi-main.c
+	$(POSTCOMPILE)
+
+mi-out.o: $(srcdir)/mi/mi-out.c
+	$(COMPILE) $(srcdir)/mi/mi-out.c
+	$(POSTCOMPILE)
+
+mi-parse.o: $(srcdir)/mi/mi-parse.c
+	$(COMPILE) $(srcdir)/mi/mi-parse.c
+	$(POSTCOMPILE)
+
+mi-symbol-cmds.o: $(srcdir)/mi/mi-symbol-cmds.c
+	$(COMPILE) $(srcdir)/mi/mi-symbol-cmds.c
+	$(POSTCOMPILE)
+
+mi-common.o: $(srcdir)/mi/mi-common.c
+	$(COMPILE) $(srcdir)/mi/mi-common.c
+	$(POSTCOMPILE)
+
+#
+# gdb/common/ dependencies
+#
+# Need to explicitly specify the compile rule as make will do nothing
+# or try to compile the object file into the sub-directory.
+
+signals.o: $(srcdir)/common/signals.c
+	$(COMPILE) $(srcdir)/common/signals.c
+	$(POSTCOMPILE)
+
+#
+# gdb/tui/ dependencies
+#
+# Need to explicitly specify the compile rule as make will do nothing
+# or try to compile the object file into the sub-directory.
+
+tui.o: $(srcdir)/tui/tui.c
+	$(COMPILE) $(srcdir)/tui/tui.c
+	$(POSTCOMPILE)
+
+tui-command.o: $(srcdir)/tui/tui-command.c
+	$(COMPILE) $(srcdir)/tui/tui-command.c
+	$(POSTCOMPILE)
+
+tui-data.o: $(srcdir)/tui/tui-data.c
+	$(COMPILE) $(srcdir)/tui/tui-data.c
+	$(POSTCOMPILE)
+
+tui-disasm.o: $(srcdir)/tui/tui-disasm.c
+	$(COMPILE) $(srcdir)/tui/tui-disasm.c
+	$(POSTCOMPILE)
+
+tui-file.o: $(srcdir)/tui/tui-file.c
+	$(COMPILE) $(srcdir)/tui/tui-file.c
+	$(POSTCOMPILE)
+
+tui-hooks.o: $(srcdir)/tui/tui-hooks.c
+	$(COMPILE) $(srcdir)/tui/tui-hooks.c
+	$(POSTCOMPILE)
+
+tui-interp.o: $(srcdir)/tui/tui-interp.c
+	$(COMPILE) $(srcdir)/tui/tui-interp.c
+	$(POSTCOMPILE)
+
+tui-io.o: $(srcdir)/tui/tui-io.c
+	$(COMPILE) $(srcdir)/tui/tui-io.c
+	$(POSTCOMPILE)
+
+tui-layout.o: $(srcdir)/tui/tui-layout.c
+	$(COMPILE) $(srcdir)/tui/tui-layout.c
+	$(POSTCOMPILE)
+
+tui-main.o: $(srcdir)/tui/tui-main.c
+	$(COMPILE) $(srcdir)/tui/tui-main.c
+	$(POSTCOMPILE)
+
+tui-out.o: $(srcdir)/tui/tui-out.c
+	$(COMPILE) $(srcdir)/tui/tui-out.c
+	$(POSTCOMPILE)
+
+tui-regs.o: $(srcdir)/tui/tui-regs.c
+	$(COMPILE) $(srcdir)/tui/tui-regs.c
+	$(POSTCOMPILE)
+
+tui-source.o: $(srcdir)/tui/tui-source.c
+	$(COMPILE) $(srcdir)/tui/tui-source.c
+	$(POSTCOMPILE)
+
+tui-stack.o: $(srcdir)/tui/tui-stack.c
+	$(COMPILE) $(srcdir)/tui/tui-stack.c
+	$(POSTCOMPILE)
+
+tui-win.o: $(srcdir)/tui/tui-win.c
+	$(COMPILE) $(srcdir)/tui/tui-win.c
+	$(POSTCOMPILE)
+
+tui-windata.o: $(srcdir)/tui/tui-windata.c
+	$(COMPILE) $(srcdir)/tui/tui-windata.c
+	$(POSTCOMPILE)
+
+tui-wingeneral.o: $(srcdir)/tui/tui-wingeneral.c
+	$(COMPILE) $(srcdir)/tui/tui-wingeneral.c
+	$(POSTCOMPILE)
+
+tui-winsource.o: $(srcdir)/tui/tui-winsource.c
+	$(COMPILE) $(srcdir)/tui/tui-winsource.c
+	$(POSTCOMPILE)
+
+#
+# gdb/python/ dependencies
+#
+# Need to explicitly specify the compile rule as make will do nothing
+# or try to compile the object file into the sub-directory.
+
+# Flags needed to compile Python code
+PYTHON_CFLAGS=@PYTHON_CFLAGS@
+
+python.o: $(srcdir)/python/python.c
+	$(COMPILE) $(PYTHON_CFLAGS) $(srcdir)/python/python.c
+	$(POSTCOMPILE)
+
+python-cmd.o: $(srcdir)/python/python-cmd.c
+	$(COMPILE) $(PYTHON_CFLAGS) $(srcdir)/python/python-cmd.c
+	$(POSTCOMPILE)
+
+python-function.o: $(srcdir)/python/python-function.c
+	$(COMPILE) $(PYTHON_CFLAGS) $(srcdir)/python/python-function.c
+	$(POSTCOMPILE)
+
+python-utils.o: $(srcdir)/python/python-utils.c
+	$(COMPILE) $(PYTHON_CFLAGS) $(srcdir)/python/python-utils.c
+	$(POSTCOMPILE)
+
+python-value.o: $(srcdir)/python/python-value.c
+	$(COMPILE) $(PYTHON_CFLAGS) $(srcdir)/python/python-value.c
+	$(POSTCOMPILE)
+
+#
+# Dependency tracking.  Most of this is conditional on GNU Make being
+# found by configure; if GNU Make is not found, we fall back to a
+# simpler scheme.
+#
+
+@GMAKE_TRUE@ifeq ($(DEPMODE),depmode=gcc3)
+# Note that we put the dependencies into a .Tpo file, then move them
+# into place if the compile succeeds.  We need this because gcc does
+# not atomically write the dependency output file.
+@GMAKE_TRUE@override COMPILE.post = -c -o $@ -MT $@ -MMD -MP \
+@GMAKE_TRUE@	-MF $(DEPDIR)/$(basename $(@F)).Tpo
+@GMAKE_TRUE@override POSTCOMPILE = @mv $(DEPDIR)/$(basename $(@F)).Tpo \
+@GMAKE_TRUE@	$(DEPDIR)/$(basename $(@F)).Po
+@GMAKE_TRUE@else
+@GMAKE_TRUE@override COMPILE.pre = source='$<' object='$@' libtool=no \
+@GMAKE_TRUE@	DEPDIR=$(DEPDIR) $(DEPMODE) $(depcomp) $(CC)
+# depcomp handles atomicity for us, so we don't need a postcompile
+# step.
+@GMAKE_TRUE@override POSTCOMPILE =
+@GMAKE_TRUE@endif
+
+# A list of all the objects we might care about in this build, for
+# dependency tracking.
+all_object_files = gdb.o tui-main.o $(LIBGDB_OBS) gdbtk-main.o \
+	test-cp-name-parser.o
+
+# Ensure that generated files are created early.  Use order-only
+# dependencies if available.  They require GNU make 3.80 or newer,
+# and the .VARIABLES variable was introduced at the same time.
+@GMAKE_TRUE@ifdef .VARIABLES
+@GMAKE_TRUE@$(all_object_files): | $(generated_files)
+@GMAKE_TRUE@else
+$(all_object_files) : $(generated_files)
+@GMAKE_TRUE@endif
+
+# Dependencies.
+@GMAKE_TRUE@-include $(patsubst %.o, $(DEPDIR)/%.Po, $(all_object_files))
+
+### end of the gdb Makefile.in.
diff -Naur gdb-6.8.50.20090329.orig/gdb/testsuite/gdb.asm/asm-source.exp gdb-6.8.50.20090329/gdb/testsuite/gdb.asm/asm-source.exp
--- gdb-6.8.50.20090329.orig/gdb/testsuite/gdb.asm/asm-source.exp	2009-01-03 06:58:03.000000000 +0100
+++ gdb-6.8.50.20090329/gdb/testsuite/gdb.asm/asm-source.exp	2009-04-17 15:30:42.000000000 +0200
@@ -64,6 +64,9 @@
     "i\[3456\]86-*-*" {
         set asm-arch i386
     }
+    "lm32-*" {
+        set asm-arch lm32
+    }
     "m32r*-linux*" {
         set asm-arch m32r-linux
     }
diff -Naur gdb-6.8.50.20090329.orig/include/gdb/sim-lm32.h gdb-6.8.50.20090329/include/gdb/sim-lm32.h
--- gdb-6.8.50.20090329.orig/include/gdb/sim-lm32.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/include/gdb/sim-lm32.h	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,74 @@
+/* This file defines the interface between the LM32 simulator and GDB.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+   Copyright (C) 2008 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef SIM_LM32_H
+#define SIM_LM32_H
+
+#ifdef __cplusplus
+extern "C" { // }
+#endif
+
+enum sim_lm32_regs
+{
+  SIM_LM32_R0_REGNUM,
+  SIM_LM32_R1_REGNUM,     
+  SIM_LM32_R2_REGNUM,     
+  SIM_LM32_R3_REGNUM,     
+  SIM_LM32_R4_REGNUM,     
+  SIM_LM32_R5_REGNUM,     
+  SIM_LM32_R6_REGNUM,     
+  SIM_LM32_R7_REGNUM,     
+  SIM_LM32_R8_REGNUM,     
+  SIM_LM32_R9_REGNUM,     
+  SIM_LM32_R10_REGNUM,    
+  SIM_LM32_R11_REGNUM,    
+  SIM_LM32_R12_REGNUM,    
+  SIM_LM32_R13_REGNUM,    
+  SIM_LM32_R14_REGNUM,    
+  SIM_LM32_R15_REGNUM,    
+  SIM_LM32_R16_REGNUM,    
+  SIM_LM32_R17_REGNUM,    
+  SIM_LM32_R18_REGNUM,    
+  SIM_LM32_R19_REGNUM,    
+  SIM_LM32_R20_REGNUM,    
+  SIM_LM32_R21_REGNUM,    
+  SIM_LM32_R22_REGNUM,    
+  SIM_LM32_R23_REGNUM,    
+  SIM_LM32_R24_REGNUM,    
+  SIM_LM32_R25_REGNUM,    
+  SIM_LM32_GP_REGNUM,     
+  SIM_LM32_FP_REGNUM,     
+  SIM_LM32_SP_REGNUM,     
+  SIM_LM32_RA_REGNUM,     
+  SIM_LM32_BA_REGNUM,     
+  SIM_LM32_EA_REGNUM,     
+  SIM_LM32_PC_REGNUM,
+  SIM_LM32_EID_REGNUM,
+  SIM_LM32_EBA_REGNUM,  
+  SIM_LM32_DEBA_REGNUM, 
+  SIM_LM32_IE_REGNUM,  
+  SIM_LM32_NUM_REGS      
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur gdb-6.8.50.20090329.orig/sim/avr/config.in gdb-6.8.50.20090329/sim/avr/config.in
--- gdb-6.8.50.20090329.orig/sim/avr/config.in	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/avr/config.in	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,101 @@
+/* config.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#undef ENABLE_NLS
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <errno.h> header file. */
+#undef HAVE_ERRNO_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the <fpu_control.h> header file. */
+#undef HAVE_FPU_CONTROL_H
+
+/* Define to 1 if you have the `getrusage' function. */
+#undef HAVE_GETRUSAGE
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+#undef HAVE_LIBNSL
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+#undef HAVE_LIBSOCKET
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `sigaction' function. */
+#undef HAVE_SIGACTION
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#undef HAVE_SYS_RESOURCE_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the `time' function. */
+#undef HAVE_TIME
+
+/* Define to 1 if you have the <time.h> header file. */
+#undef HAVE_TIME_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#undef HAVE_ZLIB_H
+
+/* Define to 1 if you have the `__setfpucw' function. */
+#undef HAVE___SETFPUCW
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Additional package description */
+#undef PKGVERSION
+
+/* Bug reporting address */
+#undef REPORT_BUGS_TO
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#undef RETSIGTYPE
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
diff -Naur gdb-6.8.50.20090329.orig/sim/avr/configure gdb-6.8.50.20090329/sim/avr/configure
--- gdb-6.8.50.20090329.orig/sim/avr/configure	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/avr/configure	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,6272 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="Makefile.in"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# if HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#if HAVE_STRING_H
+# if !STDC_HEADERS && HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#if HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#if HAVE_INTTYPES_H
+# include <inttypes.h>
+#else
+# if HAVE_STDINT_H
+#  include <stdint.h>
+# endif
+#endif
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS sim_environment sim_alignment sim_assert sim_bitsize sim_endian sim_hostendian sim_float sim_scache sim_default_model sim_hw_cflags sim_hw_objs sim_hw sim_inline sim_packages sim_regparm sim_reserved_bits sim_smp sim_stdcall sim_xor_endian WARN_CFLAGS WERROR_CFLAGS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CC_FOR_BUILD HDEFINES AR RANLIB ac_ct_RANLIB USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CPP EGREP MAINT sim_bswap sim_cflags sim_debug sim_stdio sim_trace sim_profile PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI cgen_breaks LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CPP_set=${CPP+set}
+ac_env_CPP_value=$CPP
+ac_cv_env_CPP_set=${CPP+set}
+ac_cv_env_CPP_value=$CPP
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-maintainer-mode		Enable developer functionality.
+  --enable-sim-bswap			Use Host specific BSWAP instruction.
+  --enable-sim-cflags=opts		Extra CFLAGS for use in building simulator
+  --enable-sim-debug=opts		Enable debugging flags
+  --enable-sim-stdio			Specify whether to use stdio for console input/output.
+  --enable-sim-trace=opts		Enable tracing flags
+  --enable-sim-profile=opts		Enable profiling flags
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-pkgversion=PKG   Use PKG in the version string in place of "GDB"
+  --with-bugurl=URL       Direct users to URL to report a bug
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
+              headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+          ac_config_headers="$ac_config_headers config.h:config.in"
+
+
+# This file contains common code used by all simulators.
+#
+# SIM_AC_COMMON invokes AC macros used by all simulators and by the common
+# directory.  It is intended to be invoked before any target specific stuff.
+# SIM_AC_OUTPUT is a cover function to AC_OUTPUT to generate the Makefile.
+# It is intended to be invoked last.
+#
+# The simulator's configure.in should look like:
+#
+# dnl Process this file with autoconf to produce a configure script.
+# sinclude(../common/aclocal.m4)
+# AC_PREREQ(2.5)dnl
+# AC_INIT(Makefile.in)
+#
+# SIM_AC_COMMON
+#
+# ... target specific stuff ...
+#
+# SIM_AC_OUTPUT
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+sim_inline="-DDEFAULT_INLINE=0"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# intl sister-directory configuration rules.
+#
+
+# The idea behind this macro is that there's no need to repeat all the
+# autoconf probes done by the intl directory - it's already done them
+# for us.  In fact, there's no need even to look at the cache for the
+# answers.  All we need to do is nab a few pieces of information.
+# The intl directory is set up to make this easy, by generating a
+# small file which can be sourced as a shell script; then we produce
+# the necessary substitutions and definitions for this directory.
+
+
+
+# Autoconf M4 include file defining utility macros for complex Canadian
+# cross builds.
+
+
+
+
+
+
+
+
+
+####
+# _NCN_TOOL_PREFIXES:  Some stuff that oughtta be done in AC_CANONICAL_SYSTEM
+# or AC_INIT.
+# These demand that AC_CANONICAL_SYSTEM be called beforehand.
+
+####
+# NCN_STRICT_CHECK_TOOLS(variable, progs-to-check-for,[value-if-not-found],[path])
+# Like plain AC_CHECK_TOOLS, but require prefix if build!=host.
+
+
+####
+# NCN_STRICT_CHECK_TARGET_TOOLS(variable, progs-to-check-for,[value-if-not-found],[path])
+# Like CVS Autoconf AC_CHECK_TARGET_TOOLS, but require prefix if build!=target.
+
+
+
+# Backported from Autoconf 2.5x; can go away when and if
+# we switch.  Put the OS path separator in $PATH_SEPARATOR.
+
+
+
+
+# ACX_HAVE_GCC_FOR_TARGET
+# Check if the variable GCC_FOR_TARGET really points to a GCC binary.
+
+
+# ACX_CHECK_INSTALLED_TARGET_TOOL(VAR, PROG)
+# Searching for installed target binutils.  We need to take extra care,
+# else we may find the wrong assembler, linker, etc., and lose.
+#
+# First try --with-build-time-tools, if specified.
+#
+# For build != host, we ask the installed GCC for the name of the tool it
+# uses, and accept it if it is an absolute path.  This is because the
+# only good choice for a compiler is the same GCC version that is being
+# installed (or we couldn't make target libraries), and we assume that
+# on the host system we'll have not only the same GCC version, but also
+# the same binutils version.
+#
+# For build == host, search the same directories that the installed
+# compiler will search.  We used to do this for the assembler, linker,
+# and nm only; for simplicity of configuration, however, we extend this
+# criterion to tools (such as ar and ranlib) that are never invoked by
+# the compiler, to avoid mismatches.
+#
+# Also note we have to check MD_EXEC_PREFIX before checking the user's path
+# if build == target.  This makes the most sense only when bootstrapping,
+# but we also do so when build != host.  In this case, we hope that the
+# build and host systems will have similar contents of MD_EXEC_PREFIX.
+#
+# If we do not find a suitable binary, then try the user's path.
+
+
+###
+# AC_PROG_CPP_WERROR
+# Used for autoconf 2.5x to force AC_PREPROC_IFELSE to reject code which
+# triggers warnings from the preprocessor.  Will be in autoconf 2.58.
+# For now, using this also overrides header checks to use only the
+# preprocessor (matches 2.13 behavior; matching 2.58's behavior is a
+# bit harder from here).
+# Eventually autoconf will default to checking headers with the compiler
+# instead, and we'll have to do this differently.
+
+# AC_PROG_CPP_WERROR
+
+# Test for GNAT.
+# We require the gnatbind program, and a compiler driver that
+# understands Ada.  We use the user's CC setting, already found,
+# and possibly add $1 to the command-line parameters.
+#
+# Sets the shell variable have_gnat to yes or no as appropriate, and
+# substitutes GNATBIND and GNATMAKE.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Bugs in autoconf 2.59 break the call to SIM_AC_COMMON, hack around
+# it by inlining the macro's contents.
+# This file contains common code used by all simulators.
+#
+# common.m4 invokes AC macros used by all simulators and by the common
+# directory.  It is intended to be included before any target specific
+# stuff.  SIM_AC_OUTPUT is a cover function to AC_OUTPUT to generate
+# the Makefile.  It is intended to be invoked last.
+#
+# The simulator's configure.in should look like:
+#
+# dnl Process this file with autoconf to produce a configure script.
+# AC_PREREQ(2.5)dnl
+# AC_INIT(Makefile.in)
+# AC_CONFIG_HEADER(config.h:config.in)
+#
+# sinclude(../common/aclocal.m4)
+# sinclude(../common/common.m4)
+#
+# ... target specific stuff ...
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
+target=$ac_cv_target
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+test "$program_prefix" != NONE &&
+  program_transform_name="s,^,$program_prefix,;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s,\$,$program_suffix,;$program_transform_name"
+# Double any \ or $.  echo might interpret backslashes.
+# By default was `s,x,x', remove it if useless.
+cat <<\_ACEOF >conftest.sed
+s/[\\$]/&&/g;s/;s,x,x,$//
+_ACEOF
+program_transform_name=`echo $program_transform_name | sed -f conftest.sed`
+rm conftest.sed
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$ac_ct_CC" && break
+done
+
+  CC=$ac_ct_CC
+fi
+
+fi
+
+
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO:" \
+     "checking for C compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6
+ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
+  (eval $ac_link_default) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+	;;
+    conftest.$ac_ext )
+	# This is the source file.
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	# FIXME: I believe we export ac_cv_exeext for Libtool,
+	# but it would be cool to find out if it's true.  Does anybody
+	# maintain Libtool? --akim.
+	export ac_cv_exeext
+	break;;
+    * )
+	break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6
+
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6
+
+echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  export ac_cv_exeext
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
+if test "${ac_cv_objext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
+GCC=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
+  *)
+    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
+esac
+
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat >conftest.$ac_ext <<_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   '' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include <stdlib.h>
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
+fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+# Put a plausible default for CC_FOR_BUILD in Makefile.
+if test "x$cross_compiling" = "xno"; then
+  CC_FOR_BUILD='$(CC)'
+else
+  CC_FOR_BUILD=gcc
+fi
+
+
+
+
+AR=${AR-ar}
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  RANLIB=$ac_ct_RANLIB
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+
+ALL_LINGUAS=
+# If we haven't got the data from the intl directory,
+# assume NLS is disabled.
+USE_NLS=no
+LIBINTL=
+LIBINTL_DEP=
+INCINTL=
+XGETTEXT=
+GMSGFMT=
+POSUB=
+
+if test -f  ../../intl/config.intl; then
+  .  ../../intl/config.intl
+fi
+echo "$as_me:$LINENO: checking whether NLS is requested" >&5
+echo $ECHO_N "checking whether NLS is requested... $ECHO_C" >&6
+if test x"$USE_NLS" != xyes; then
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+else
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_NLS 1
+_ACEOF
+
+
+  echo "$as_me:$LINENO: checking for catalogs to be installed" >&5
+echo $ECHO_N "checking for catalogs to be installed... $ECHO_C" >&6
+  # Look for .po and .gmo files in the source directory.
+  CATALOGS=
+  XLINGUAS=
+  for cat in $srcdir/po/*.gmo $srcdir/po/*.po; do
+    # If there aren't any .gmo files the shell will give us the
+    # literal string "../path/to/srcdir/po/*.gmo" which has to be
+    # weeded out.
+    case "$cat" in *\**)
+      continue;;
+    esac
+    # The quadruple backslash is collapsed to a double backslash
+    # by the backticks, then collapsed again by the double quotes,
+    # leaving us with one backslash in the sed expression (right
+    # before the dot that mustn't act as a wildcard).
+    cat=`echo $cat | sed -e "s!$srcdir/po/!!" -e "s!\\\\.po!.gmo!"`
+    lang=`echo $cat | sed -e "s!\\\\.gmo!!"`
+    # The user is allowed to set LINGUAS to a list of languages to
+    # install catalogs for.  If it's empty that means "all of them."
+    if test "x$LINGUAS" = x; then
+      CATALOGS="$CATALOGS $cat"
+      XLINGUAS="$XLINGUAS $lang"
+    else
+      case "$LINGUAS" in *$lang*)
+        CATALOGS="$CATALOGS $cat"
+        XLINGUAS="$XLINGUAS $lang"
+        ;;
+      esac
+    fi
+  done
+  LINGUAS="$XLINGUAS"
+  echo "$as_me:$LINENO: result: $LINGUAS" >&5
+echo "${ECHO_T}$LINGUAS" >&6
+
+
+    DATADIRNAME=share
+
+  INSTOBJEXT=.mo
+
+  GENCAT=gencat
+
+  CATOBJEXT=.gmo
+
+fi
+
+# Check for common headers.
+# FIXME: Seems to me this can cause problems for i386-windows hosts.
+# At one point there were hardcoded AC_DEFINE's if ${host} = i386-*-windows*.
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+
+for ac_header in stdlib.h string.h strings.h unistd.h time.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in sys/time.h sys/resource.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in fcntl.h fpu_control.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+for ac_header in dlfcn.h errno.h sys/stat.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+for ac_func in getrusage time sigaction __setfpucw
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+# Check for socket libraries
+
+echo "$as_me:$LINENO: checking for bind in -lsocket" >&5
+echo $ECHO_N "checking for bind in -lsocket... $ECHO_C" >&6
+if test "${ac_cv_lib_socket_bind+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char bind ();
+int
+main ()
+{
+bind ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_bind=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_socket_bind=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_socket_bind" >&5
+echo "${ECHO_T}$ac_cv_lib_socket_bind" >&6
+if test $ac_cv_lib_socket_bind = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSOCKET 1
+_ACEOF
+
+  LIBS="-lsocket $LIBS"
+
+fi
+
+
+echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
+echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBNSL 1
+_ACEOF
+
+  LIBS="-lnsl $LIBS"
+
+fi
+
+
+# BFD conditionally uses zlib, so we must link it in if libbfd does, by
+# using the same condition.
+echo "$as_me:$LINENO: checking for library containing zlibVersion" >&5
+echo $ECHO_N "checking for library containing zlibVersion... $ECHO_C" >&6
+if test "${ac_cv_search_zlibVersion+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_zlibVersion=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char zlibVersion ();
+int
+main ()
+{
+zlibVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_zlibVersion="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_zlibVersion" = no; then
+  for ac_lib in z; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char zlibVersion ();
+int
+main ()
+{
+zlibVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_zlibVersion="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_zlibVersion" >&5
+echo "${ECHO_T}$ac_cv_search_zlibVersion" >&6
+if test "$ac_cv_search_zlibVersion" != no; then
+  test "$ac_cv_search_zlibVersion" = "none required" || LIBS="$ac_cv_search_zlibVersion $LIBS"
+
+for ac_header in zlib.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+fi
+
+
+. ${srcdir}/../../bfd/configure.host
+
+
+
+USE_MAINTAINER_MODE=no
+# Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then
+  enableval="$enable_maintainer_mode"
+  case "${enableval}" in
+  yes)	MAINT="" USE_MAINTAINER_MODE=yes ;;
+  no)	MAINT="#" ;;
+  *)	{ { echo "$as_me:$LINENO: error: \"--enable-maintainer-mode does not take a value\"" >&5
+echo "$as_me: error: \"--enable-maintainer-mode does not take a value\"" >&2;}
+   { (exit 1); exit 1; }; }; MAINT="#" ;;
+esac
+if test x"$silent" != x"yes" && test x"$MAINT" = x""; then
+  echo "Setting maintainer mode" 6>&1
+fi
+else
+  MAINT="#"
+fi;
+
+
+# Check whether --enable-sim-bswap or --disable-sim-bswap was given.
+if test "${enable_sim_bswap+set}" = set; then
+  enableval="$enable_sim_bswap"
+  case "${enableval}" in
+  yes)	sim_bswap="-DWITH_BSWAP=1 -DUSE_BSWAP=1";;
+  no)	sim_bswap="-DWITH_BSWAP=0";;
+  *)	{ { echo "$as_me:$LINENO: error: \"--enable-sim-bswap does not take a value\"" >&5
+echo "$as_me: error: \"--enable-sim-bswap does not take a value\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_bswap="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_bswap" != x""; then
+  echo "Setting bswap flags = $sim_bswap" 6>&1
+fi
+else
+  sim_bswap=""
+fi;
+
+
+# Check whether --enable-sim-cflags or --disable-sim-cflags was given.
+if test "${enable_sim_cflags+set}" = set; then
+  enableval="$enable_sim_cflags"
+  case "${enableval}" in
+  yes)	 sim_cflags="-O2 -fomit-frame-pointer";;
+  trace) { { echo "$as_me:$LINENO: error: \"Please use --enable-sim-debug instead.\"" >&5
+echo "$as_me: error: \"Please use --enable-sim-debug instead.\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_cflags="";;
+  no)	 sim_cflags="";;
+  *)	 sim_cflags=`echo "${enableval}" | sed -e "s/,/ /g"`;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_cflags" != x""; then
+  echo "Setting sim cflags = $sim_cflags" 6>&1
+fi
+else
+  sim_cflags=""
+fi;
+
+
+# Check whether --enable-sim-debug or --disable-sim-debug was given.
+if test "${enable_sim_debug+set}" = set; then
+  enableval="$enable_sim_debug"
+  case "${enableval}" in
+  yes) sim_debug="-DDEBUG=7 -DWITH_DEBUG=7";;
+  no)  sim_debug="-DDEBUG=0 -DWITH_DEBUG=0";;
+  *)   sim_debug="-DDEBUG='(${enableval})' -DWITH_DEBUG='(${enableval})'";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_debug" != x""; then
+  echo "Setting sim debug = $sim_debug" 6>&1
+fi
+else
+  sim_debug=""
+fi;
+
+
+# Check whether --enable-sim-stdio or --disable-sim-stdio was given.
+if test "${enable_sim_stdio+set}" = set; then
+  enableval="$enable_sim_stdio"
+  case "${enableval}" in
+  yes)	sim_stdio="-DWITH_STDIO=DO_USE_STDIO";;
+  no)	sim_stdio="-DWITH_STDIO=DONT_USE_STDIO";;
+  *)	{ { echo "$as_me:$LINENO: error: \"Unknown value $enableval passed to --enable-sim-stdio\"" >&5
+echo "$as_me: error: \"Unknown value $enableval passed to --enable-sim-stdio\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_stdio="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_stdio" != x""; then
+  echo "Setting stdio flags = $sim_stdio" 6>&1
+fi
+else
+  sim_stdio=""
+fi;
+
+
+# Check whether --enable-sim-trace or --disable-sim-trace was given.
+if test "${enable_sim_trace+set}" = set; then
+  enableval="$enable_sim_trace"
+  case "${enableval}" in
+  yes)	sim_trace="-DTRACE=1 -DWITH_TRACE=-1";;
+  no)	sim_trace="-DTRACE=0 -DWITH_TRACE=0";;
+  [-0-9]*)
+	sim_trace="-DTRACE='(${enableval})' -DWITH_TRACE='(${enableval})'";;
+  [a-z]*)
+	sim_trace=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_trace" = x; then
+	    sim_trace="-DWITH_TRACE='(TRACE_$x"
+	  else
+	    sim_trace="${sim_trace}|TRACE_$x"
+	  fi
+	done
+	sim_trace="$sim_trace)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_trace" != x""; then
+  echo "Setting sim trace = $sim_trace" 6>&1
+fi
+else
+  sim_trace=""
+fi;
+
+
+# Check whether --enable-sim-profile or --disable-sim-profile was given.
+if test "${enable_sim_profile+set}" = set; then
+  enableval="$enable_sim_profile"
+  case "${enableval}" in
+  yes)	sim_profile="-DPROFILE=1 -DWITH_PROFILE=-1";;
+  no)	sim_profile="-DPROFILE=0 -DWITH_PROFILE=0";;
+  [-0-9]*)
+	sim_profile="-DPROFILE='(${enableval})' -DWITH_PROFILE='(${enableval})'";;
+  [a-z]*)
+	sim_profile=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_profile" = x; then
+	    sim_profile="-DWITH_PROFILE='(PROFILE_$x"
+	  else
+	    sim_profile="${sim_profile}|PROFILE_$x"
+	  fi
+	done
+	sim_profile="$sim_profile)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_profile" != x""; then
+  echo "Setting sim profile = $sim_profile" 6>&1
+fi
+else
+  sim_profile="-DPROFILE=1 -DWITH_PROFILE=-1"
+fi;
+
+
+
+# Check whether --with-pkgversion or --without-pkgversion was given.
+if test "${with_pkgversion+set}" = set; then
+  withval="$with_pkgversion"
+  case "$withval" in
+      yes) { { echo "$as_me:$LINENO: error: package version not specified" >&5
+echo "$as_me: error: package version not specified" >&2;}
+   { (exit 1); exit 1; }; } ;;
+      no)  PKGVERSION= ;;
+      *)   PKGVERSION="($withval) " ;;
+     esac
+else
+  PKGVERSION="(GDB) "
+
+fi;
+
+
+
+
+# Check whether --with-bugurl or --without-bugurl was given.
+if test "${with_bugurl+set}" = set; then
+  withval="$with_bugurl"
+  case "$withval" in
+      yes) { { echo "$as_me:$LINENO: error: bug URL not specified" >&5
+echo "$as_me: error: bug URL not specified" >&2;}
+   { (exit 1); exit 1; }; } ;;
+      no)  BUGURL=
+	   ;;
+      *)   BUGURL="$withval"
+	   ;;
+     esac
+else
+  BUGURL="http://www.gnu.org/software/gdb/bugs/"
+
+fi;
+  case ${BUGURL} in
+  "")
+    REPORT_BUGS_TO=
+    REPORT_BUGS_TEXI=
+    ;;
+  *)
+    REPORT_BUGS_TO="<$BUGURL>"
+    REPORT_BUGS_TEXI=@uref{`echo "$BUGURL" | sed 's/@/@@/g'`}
+    ;;
+  esac;
+
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define PKGVERSION "$PKGVERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define REPORT_BUGS_TO "$REPORT_BUGS_TO"
+_ACEOF
+
+
+echo "$as_me:$LINENO: checking return type of signal handlers" >&5
+echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
+if test "${ac_cv_type_signal+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+# undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int
+main ()
+{
+int i;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_signal=void
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_signal=int
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
+echo "${ECHO_T}$ac_cv_type_signal" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define RETSIGTYPE $ac_cv_type_signal
+_ACEOF
+
+
+
+
+
+sim_link_files=
+sim_link_links=
+
+sim_link_links=tconfig.h
+if test -f ${srcdir}/tconfig.in
+then
+  sim_link_files=tconfig.in
+else
+  sim_link_files=../common/tconfig.in
+fi
+
+# targ-vals.def points to the libc macro description file.
+case "${target}" in
+*-*-*) TARG_VALS_DEF=../common/nltvals.def ;;
+esac
+sim_link_files="${sim_link_files} ${TARG_VALS_DEF}"
+sim_link_links="${sim_link_links} targ-vals.def"
+
+
+
+ac_sources="$sim_link_files"
+ac_dests="$sim_link_links"
+while test -n "$ac_sources"; do
+  set $ac_dests; ac_dest=$1; shift; ac_dests=$*
+  set $ac_sources; ac_source=$1; shift; ac_sources=$*
+  ac_config_links_1="$ac_config_links_1 $ac_dest:$ac_source"
+done
+          ac_config_links="$ac_config_links $ac_config_links_1"
+
+cgen_breaks=""
+if grep CGEN_MAINT $srcdir/Makefile.in >/dev/null; then
+cgen_breaks="break cgen_rtx_error";
+fi
+
+          ac_config_files="$ac_config_files Makefile.sim:Makefile.in"
+
+          ac_config_files="$ac_config_files Make-common.sim:../common/Make-common.in"
+
+          ac_config_files="$ac_config_files .gdbinit:../common/gdbinit.in"
+
+          ac_config_commands="$ac_config_commands Makefile"
+
+          ac_config_commands="$ac_config_commands stamp-h"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+		   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration links:
+$config_links
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+INSTALL="$INSTALL"
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile.sim" ) CONFIG_FILES="$CONFIG_FILES Makefile.sim:Makefile.in" ;;
+  "Make-common.sim" ) CONFIG_FILES="$CONFIG_FILES Make-common.sim:../common/Make-common.in" ;;
+  ".gdbinit" ) CONFIG_FILES="$CONFIG_FILES .gdbinit:../common/gdbinit.in" ;;
+  "$ac_config_links_1" ) CONFIG_LINKS="$CONFIG_LINKS $ac_config_links_1" ;;
+  "Makefile" ) CONFIG_COMMANDS="$CONFIG_COMMANDS Makefile" ;;
+  "stamp-h" ) CONFIG_COMMANDS="$CONFIG_COMMANDS stamp-h" ;;
+  "config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS config.h:config.in" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_LINKS+set}" = set || CONFIG_LINKS=$config_links
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@sim_environment@,$sim_environment,;t t
+s,@sim_alignment@,$sim_alignment,;t t
+s,@sim_assert@,$sim_assert,;t t
+s,@sim_bitsize@,$sim_bitsize,;t t
+s,@sim_endian@,$sim_endian,;t t
+s,@sim_hostendian@,$sim_hostendian,;t t
+s,@sim_float@,$sim_float,;t t
+s,@sim_scache@,$sim_scache,;t t
+s,@sim_default_model@,$sim_default_model,;t t
+s,@sim_hw_cflags@,$sim_hw_cflags,;t t
+s,@sim_hw_objs@,$sim_hw_objs,;t t
+s,@sim_hw@,$sim_hw,;t t
+s,@sim_inline@,$sim_inline,;t t
+s,@sim_packages@,$sim_packages,;t t
+s,@sim_regparm@,$sim_regparm,;t t
+s,@sim_reserved_bits@,$sim_reserved_bits,;t t
+s,@sim_smp@,$sim_smp,;t t
+s,@sim_stdcall@,$sim_stdcall,;t t
+s,@sim_xor_endian@,$sim_xor_endian,;t t
+s,@WARN_CFLAGS@,$WARN_CFLAGS,;t t
+s,@WERROR_CFLAGS@,$WERROR_CFLAGS,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@CC@,$CC,;t t
+s,@CFLAGS@,$CFLAGS,;t t
+s,@LDFLAGS@,$LDFLAGS,;t t
+s,@CPPFLAGS@,$CPPFLAGS,;t t
+s,@ac_ct_CC@,$ac_ct_CC,;t t
+s,@EXEEXT@,$EXEEXT,;t t
+s,@OBJEXT@,$OBJEXT,;t t
+s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+s,@CC_FOR_BUILD@,$CC_FOR_BUILD,;t t
+s,@HDEFINES@,$HDEFINES,;t t
+s,@AR@,$AR,;t t
+s,@RANLIB@,$RANLIB,;t t
+s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+s,@USE_NLS@,$USE_NLS,;t t
+s,@LIBINTL@,$LIBINTL,;t t
+s,@LIBINTL_DEP@,$LIBINTL_DEP,;t t
+s,@INCINTL@,$INCINTL,;t t
+s,@XGETTEXT@,$XGETTEXT,;t t
+s,@GMSGFMT@,$GMSGFMT,;t t
+s,@POSUB@,$POSUB,;t t
+s,@CATALOGS@,$CATALOGS,;t t
+s,@DATADIRNAME@,$DATADIRNAME,;t t
+s,@INSTOBJEXT@,$INSTOBJEXT,;t t
+s,@GENCAT@,$GENCAT,;t t
+s,@CATOBJEXT@,$CATOBJEXT,;t t
+s,@CPP@,$CPP,;t t
+s,@EGREP@,$EGREP,;t t
+s,@MAINT@,$MAINT,;t t
+s,@sim_bswap@,$sim_bswap,;t t
+s,@sim_cflags@,$sim_cflags,;t t
+s,@sim_debug@,$sim_debug,;t t
+s,@sim_stdio@,$sim_stdio,;t t
+s,@sim_trace@,$sim_trace,;t t
+s,@sim_profile@,$sim_profile,;t t
+s,@PKGVERSION@,$PKGVERSION,;t t
+s,@REPORT_BUGS_TO@,$REPORT_BUGS_TO,;t t
+s,@REPORT_BUGS_TEXI@,$REPORT_BUGS_TEXI,;t t
+s,@cgen_breaks@,$cgen_breaks,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_HEADER section.
+#
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
+ac_dB='[	 ].*$,\1#\2'
+ac_dC=' '
+ac_dD=',;t'
+# ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
+ac_uB='$,\1#\2define\3'
+ac_uC=' '
+ac_uD=',;t'
+
+for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  test x"$ac_file" != x- && { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  # Remove the trailing spaces.
+  sed 's/[	 ]*$//' $ac_file_inputs >$tmp/in
+
+_ACEOF
+
+# Transform confdefs.h into two sed scripts, `conftest.defines' and
+# `conftest.undefs', that substitutes the proper values into
+# config.h.in to produce config.h.  The first handles `#define'
+# templates, and the second `#undef' templates.
+# And first: Protect against being on the right side of a sed subst in
+# config.status.  Protect against being in an unquoted here document
+# in config.status.
+rm -f conftest.defines conftest.undefs
+# Using a here document instead of a string reduces the quoting nightmare.
+# Putting comments in sed scripts is not portable.
+#
+# `end' is used to avoid that the second main sed command (meant for
+# 0-ary CPP macros) applies to n-ary macro definitions.
+# See the Autoconf documentation for `clear'.
+cat >confdef2sed.sed <<\_ACEOF
+s/[\\&,]/\\&/g
+s,[\\$`],\\&,g
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*\)\(([^)]*)\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+t end
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+: end
+_ACEOF
+# If some macros were called several times there might be several times
+# the same #defines, which is useless.  Nevertheless, we may not want to
+# sort them, since we want the *last* AC-DEFINE to be honored.
+uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
+sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
+rm -f confdef2sed.sed
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >>conftest.undefs <<\_ACEOF
+s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+_ACEOF
+
+# Break up conftest.defines because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
+echo '  if grep "^[	 ]*#[	 ]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
+echo '  :' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.defines >/dev/null
+do
+  # Write a limited-size here document to $tmp/defines.sed.
+  echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#define' lines.
+  echo '/^[	 ]*#[	 ]*define/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/defines.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
+  rm -f conftest.defines
+  mv conftest.tail conftest.defines
+done
+rm -f conftest.defines
+echo '  fi # grep' >>$CONFIG_STATUS
+echo >>$CONFIG_STATUS
+
+# Break up conftest.undefs because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.undefs >/dev/null
+do
+  # Write a limited-size here document to $tmp/undefs.sed.
+  echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#undef'
+  echo '/^[	 ]*#[	 ]*undef/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
+  rm -f conftest.undefs
+  mv conftest.tail conftest.undefs
+done
+rm -f conftest.undefs
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    echo "/* Generated by configure.  */" >$tmp/config.h
+  else
+    echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
+  fi
+  cat $tmp/in >>$tmp/config.h
+  rm -f $tmp/in
+  if test x"$ac_file" != x-; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+      rm -f $ac_file
+      mv $tmp/config.h $ac_file
+    fi
+  else
+    cat $tmp/config.h
+    rm -f $tmp/config.h
+  fi
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_LINKS section.
+#
+
+for ac_file in : $CONFIG_LINKS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+
+  { echo "$as_me:$LINENO: linking $srcdir/$ac_source to $ac_dest" >&5
+echo "$as_me: linking $srcdir/$ac_source to $ac_dest" >&6;}
+
+  if test ! -r $srcdir/$ac_source; then
+    { { echo "$as_me:$LINENO: error: $srcdir/$ac_source: file not found" >&5
+echo "$as_me: error: $srcdir/$ac_source: file not found" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  rm -f $ac_dest
+
+  # Make relative symlinks.
+  ac_dest_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dest_dir"
+  else
+    as_dir="$ac_dest_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dest_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dest_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dest_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dest_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dest_dir";;
+*)
+  case "$ac_dest_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dest_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dest_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $srcdir in
+  [\\/$]* | ?:[\\/]* ) ac_rel_source=$srcdir/$ac_source ;;
+      *) ac_rel_source=$ac_top_builddir$srcdir/$ac_source ;;
+  esac
+
+  # Try a symlink, then a hard link, then a copy.
+  ln -s $ac_rel_source $ac_dest 2>/dev/null ||
+    ln $srcdir/$ac_source $ac_dest 2>/dev/null ||
+    cp -p $srcdir/$ac_source $ac_dest ||
+    { { echo "$as_me:$LINENO: error: cannot link or copy $srcdir/$ac_source to $ac_dest" >&5
+echo "$as_me: error: cannot link or copy $srcdir/$ac_source to $ac_dest" >&2;}
+   { (exit 1); exit 1; }; }
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_COMMANDS section.
+#
+for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+  ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
+echo "$as_me: executing $ac_dest commands" >&6;}
+  case $ac_dest in
+    Makefile ) echo "Merging Makefile.sim+Make-common.sim into Makefile ..."
+ rm -f Makesim1.tmp Makesim2.tmp Makefile
+ sed -n -e '/^## COMMON_PRE_/,/^## End COMMON_PRE_/ p' <Make-common.sim >Makesim1.tmp
+ sed -n -e '/^## COMMON_POST_/,/^## End COMMON_POST_/ p' <Make-common.sim >Makesim2.tmp
+ sed -e '/^## COMMON_PRE_/ r Makesim1.tmp' \
+	-e '/^## COMMON_POST_/ r Makesim2.tmp' \
+	<Makefile.sim >Makefile
+ rm -f Makefile.sim Make-common.sim Makesim1.tmp Makesim2.tmp
+ ;;
+    stamp-h ) echo > stamp-h ;;
+  esac
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
+
diff -Naur gdb-6.8.50.20090329.orig/sim/avr/configure.ac gdb-6.8.50.20090329/sim/avr/configure.ac
--- gdb-6.8.50.20090329.orig/sim/avr/configure.ac	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/avr/configure.ac	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,12 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_PREREQ(2.59)dnl
+AC_INIT(Makefile.in)
+AC_CONFIG_HEADER(config.h:config.in)
+
+sinclude(../common/aclocal.m4)
+
+# Bugs in autoconf 2.59 break the call to SIM_AC_COMMON, hack around
+# it by inlining the macro's contents.
+sinclude(../common/common.m4)
+
+SIM_AC_OUTPUT
diff -Naur gdb-6.8.50.20090329.orig/sim/avr/interp.c gdb-6.8.50.20090329/sim/avr/interp.c
--- gdb-6.8.50.20090329.orig/sim/avr/interp.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/avr/interp.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,1848 @@
+/* Simulator for Atmel's AVR core.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   Written by Tristan Gingold, AdaCore.
+
+   This file is part of GDB, the GNU debugger.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#include "bfd.h"
+#include "gdb/callback.h"
+#include "gdb/signals.h"
+#include "libiberty.h"
+#include "gdb/remote-sim.h"
+#include "dis-asm.h"
+#include "sim-utils.h"
+
+/* As AVR is a 8/16 bits processor, define handy types.  */
+typedef unsigned short int word;
+typedef signed short int sword;
+typedef unsigned char byte;
+typedef signed char sbyte;
+
+/* Debug flag to display instructions and registers.  */
+static int tracing = 0;
+static int lock_step = 0;
+static int verbose;
+
+/* The only real register.  */
+static unsigned int pc;
+
+/* We update a cycle counter.  */
+static unsigned int cycles = 0;
+
+/* If true, the pc needs more than 2 bytes.  */
+static int avr_pc22;
+
+static struct bfd *cur_bfd;
+
+static enum sim_stop cpu_exception;
+static int cpu_signal;
+
+static SIM_OPEN_KIND sim_kind;
+static char *myname;
+static host_callback *callback;
+
+/* Max size of I space (which is always flash on avr).  */
+#define MAX_AVR_FLASH (128 * 1024)
+#define PC_MASK (MAX_AVR_FLASH - 1)
+
+/* Mac size of D space.  */
+#define MAX_AVR_SRAM (64 * 1024)
+#define SRAM_MASK (MAX_AVR_SRAM - 1)
+
+/* D space offset in ELF file.  */
+#define SRAM_VADDR 0x800000
+
+/* Simulator specific ports.  */
+#define STDIO_PORT	0x52
+#define EXIT_PORT	0x4F
+#define ABORT_PORT	0x49
+
+/* GDB defined register numbers.  */
+#define AVR_SREG_REGNUM  32
+#define AVR_SP_REGNUM    33
+#define AVR_PC_REGNUM    34
+
+/* Memory mapped registers.  */
+#define SREG	0x5F
+#define REG_SP	0x5D
+#define EIND	0x5C
+#define RAMPZ	0x5B
+
+#define REGX 0x1a
+#define REGY 0x1c
+#define REGZ 0x1e
+#define REGZ_LO 0x1e
+#define REGZ_HI 0x1f
+
+/* Sreg (status) bits.  */
+#define SREG_I 0x80
+#define SREG_T 0x40
+#define SREG_H 0x20
+#define SREG_S 0x10
+#define SREG_V 0x08
+#define SREG_N 0x04
+#define SREG_Z 0x02
+#define SREG_C 0x01
+
+/* In order to speed up emulation we use a simple approach:
+   a code is associated with each instruction.  The pre-decoding occurs
+   usually once when the instruction is first seen.
+   This works well because I&D spaces are separated.
+
+   Missing opcodes: sleep, spm, wdr (as they are mmcu dependent).
+*/
+enum avr_opcode
+  {
+    /* Opcode not yet decoded.  */
+    OP_unknown,
+    OP_bad,
+
+    OP_nop,
+
+    OP_rjmp,
+    OP_rcall,
+    OP_ret,
+    OP_reti,
+
+    OP_break,
+
+    OP_brbs,
+    OP_brbc,
+
+    OP_bset,
+    OP_bclr,
+
+    OP_bld,
+    OP_bst,
+
+    OP_sbrc,
+    OP_sbrs,
+
+    OP_eor,
+    OP_and,
+    OP_andi,
+    OP_or,
+    OP_ori,
+    OP_com,
+    OP_swap,
+    OP_neg,
+
+    OP_out,
+    OP_in,
+    OP_cbi,
+    OP_sbi,
+
+    OP_sbic,
+    OP_sbis,
+
+    OP_ldi,
+    OP_cpse,
+    OP_cp,
+    OP_cpi,
+    OP_cpc,
+    OP_sub,
+    OP_sbc,
+    OP_sbiw,
+    OP_adiw,
+    OP_add,
+    OP_adc,
+    OP_subi,
+    OP_sbci,
+    OP_inc,
+    OP_dec,
+    OP_lsr,
+    OP_ror,
+    OP_asr,
+
+    OP_mul,
+    OP_muls,
+    OP_mulsu,
+    OP_fmul,
+    OP_fmuls,
+    OP_fmulsu,
+
+    OP_mov,
+    OP_movw,
+
+    OP_push,
+    OP_pop,
+
+    OP_st_X,
+    OP_st_dec_X,
+    OP_st_X_inc,
+    OP_st_Y_inc,
+    OP_st_dec_Y,
+    OP_st_Z_inc,
+    OP_st_dec_Z,
+    OP_std_Y,
+    OP_std_Z,
+    OP_ldd_Y,
+    OP_ldd_Z,
+    OP_ld_Z_inc,
+    OP_ld_dec_Z,
+    OP_ld_Y_inc,
+    OP_ld_dec_Y,
+    OP_ld_X,
+    OP_ld_X_inc,
+    OP_ld_dec_X,
+    
+    OP_lpm,
+    OP_lpm_Z,
+    OP_lpm_inc_Z,
+    OP_elpm,
+    OP_elpm_Z,
+    OP_elpm_inc_Z,
+
+    OP_ijmp,
+    OP_icall,
+
+    OP_eijmp,
+    OP_eicall,
+
+    /* 2 words opcodes.  */
+#define OP_2words OP_jmp
+    OP_jmp,
+    OP_call,
+    OP_sts,
+    OP_lds
+  };
+
+struct avr_insn_cell
+{
+  /* The insn (16 bits).  */
+  word op;
+
+  /* Pre-decoding code.  */
+  enum avr_opcode code : 8;
+  /* One byte of additional information.  */
+  byte r;
+};
+
+/* I&D memories.  */
+static struct avr_insn_cell flash[MAX_AVR_FLASH];
+static byte sram[MAX_AVR_SRAM];
+
+void
+sim_size (int s)
+{
+}
+
+/* Sign extend a value.  */
+static int sign_ext (word val, int nb_bits)
+{
+  if (val & (1 << (nb_bits - 1)))
+    return val | (-1 << nb_bits);
+  return val;
+}
+
+/* Insn field extractors.  */
+
+/* Extract xxxx_xxxRx_xxxx_RRRR.  */
+static inline byte get_r (word op)
+{
+  return (op & 0xf) | ((op >> 5) & 0x10);
+}
+
+/* Extract xxxx_xxxxx_xxxx_RRRR.  */
+static inline byte get_r16 (word op)
+{
+  return 16 + (op & 0xf);
+}
+
+/* Extract xxxx_xxxxx_xxxx_xRRR.  */
+static inline byte get_r16_23 (word op)
+{
+  return 16 + (op & 0x7);
+}
+
+/* Extract xxxx_xxxD_DDDD_xxxx.  */
+static inline byte get_d (word op)
+{
+  return (op >> 4) & 0x1f;
+}
+
+/* Extract xxxx_xxxx_DDDD_xxxx.  */
+static inline byte get_d16 (word op)
+{
+  return 16 + ((op >> 4) & 0x0f);
+}
+
+/* Extract xxxx_xxxx_xDDD_xxxx.  */
+static inline byte get_d16_23 (word op)
+{
+  return 16 + ((op >> 4) & 0x07);
+}
+
+/* Extract xxxx_xAAx_xxxx_AAAA.  */
+static inline byte get_A (word op)
+{
+  return (op & 0x0f) | ((op & 0x600) >> 5);
+}
+
+/* Extract xxxx_xxxx_AAAA_Axxx.  */
+static inline byte get_biA (word op)
+{
+  return (op >> 3) & 0x1f;
+}
+
+/* Extract xxxx_KKKK_xxxx_KKKK.  */
+static inline byte get_K (word op)
+{
+  return (op & 0xf) | ((op & 0xf00) >> 4);
+}
+
+/* Extract xxxx_xxKK_KKKK_Kxxx.  */
+static inline int get_k (word op)
+{
+  return sign_ext ((op & 0x3f8) >> 3, 7);
+}
+
+/* Extract xxxx_xxxx_xxDD_xxxx.  */
+static inline byte get_d24 (word op)
+{
+  return 24 + ((op >> 3) & 6);
+}
+
+/* Extract xxxx_xxxx_KKxx_KKKK.  */
+static inline byte get_k6 (word op)
+{
+  return (op & 0xf) | ((op >> 2) & 0x30);
+}
+ 
+/* Extract xxQx_QQxx_xxxx_xQQQ.  */
+static inline byte get_q (word op)
+{
+  return (op & 7) | ((op >> 7) & 0x18)| ((op >> 8) & 0x20);
+}
+
+/* Extract xxxx_xxxx_xxxx_xBBB.  */
+static inline byte get_b (word op)
+{
+  return (op & 7);
+}
+
+/* AVR is little endian.  */
+static inline word
+read_word (unsigned int addr)
+{
+  return sram[addr] | (sram[addr + 1] << 8);
+}
+
+static inline void
+write_word (unsigned int addr, word w)
+{
+  sram[addr] = w;
+  sram[addr + 1] = w >> 8;
+}
+
+static inline word
+read_word_post_inc (unsigned int addr)
+{
+  word v = read_word (addr);
+  write_word (addr, v + 1);
+  return v;
+}
+
+static inline word
+read_word_pre_dec (unsigned int addr)
+{
+  word v = read_word (addr) - 1;
+  write_word (addr, v);
+  return v;
+}
+
+static void
+update_flags_logic (byte res)
+{
+  sram[SREG] &= ~(SREG_S | SREG_V | SREG_N | SREG_Z);
+  if (res == 0)
+    sram[SREG] |= SREG_Z;
+  if (res & 0x80)
+    sram[SREG] |= SREG_N | SREG_S;
+}
+
+static void
+update_flags_add (byte r, byte a, byte b)
+{
+  byte carry;
+
+  sram[SREG] &= ~(SREG_H | SREG_S | SREG_V | SREG_N | SREG_Z | SREG_C);
+  if (r & 0x80)
+    sram[SREG] |= SREG_N;
+  carry = (a & b) | (a & ~r) | (b & ~r);
+  if (carry & 0x08)
+    sram[SREG] |= SREG_H;
+  if (carry & 0x80)
+    sram[SREG] |= SREG_C;
+  if (((a & b & ~r) | (~a & ~b & r)) & 0x80)
+    sram[SREG] |= SREG_V;
+  if (!(sram[SREG] & SREG_N) ^ !(sram[SREG] & SREG_V))
+    sram[SREG] |= SREG_S;
+  if (r == 0)
+    sram[SREG] |= SREG_Z;
+}
+
+static void update_flags_sub (byte r, byte a, byte b)
+{
+  byte carry;
+
+  sram[SREG] &= ~(SREG_H | SREG_S | SREG_V | SREG_N | SREG_Z | SREG_C);
+  if (r & 0x80)
+    sram[SREG] |= SREG_N;
+  carry = (~a & b) | (b & r) | (r & ~a);
+  if (carry & 0x08)
+    sram[SREG] |= SREG_H;
+  if (carry & 0x80)
+    sram[SREG] |= SREG_C;
+  if (((a & ~b & ~r) | (~a & b & r)) & 0x80)
+    sram[SREG] |= SREG_V;
+  if (!(sram[SREG] & SREG_N) ^ !(sram[SREG] & SREG_V))
+    sram[SREG] |= SREG_S;
+  /* Note: Z is not set.  */
+}
+
+static enum avr_opcode
+decode (unsigned int pc)
+{
+  word op1 = flash[pc].op;
+
+  switch ((op1 >> 12) & 0x0f)
+    {
+    case 0x0:
+      switch ((op1 >> 10) & 0x3)
+        {
+        case 0x0:
+          switch ((op1 >> 8) & 0x3)
+            {
+            case 0x0:
+              if (op1 == 0)
+                return OP_nop;
+              break;
+            case 0x1:
+              return OP_movw;
+            case 0x2:
+              return OP_muls;
+            case 0x3:
+              if (op1 & 0x80)
+                {
+                  if (op1 & 0x08)
+                    return OP_fmulsu;
+                  else
+                    return OP_fmuls;
+                }
+              else
+                {
+                  if (op1 & 0x08)
+                    return OP_fmul;
+                  else
+                    return OP_mulsu;
+                }
+            }
+          break;
+        case 0x1:
+          return OP_cpc;
+        case 0x2:
+          flash[pc].r = SREG_C;
+          return OP_sbc;
+        case 0x3:
+          flash[pc].r = 0;
+          return OP_add;
+        }
+      break;
+    case 0x1:
+      switch ((op1 >> 10) & 0x3)
+        {
+        case 0x0:
+          return OP_cpse;
+        case 0x1:
+          return OP_cp;
+        case 0x2:
+          flash[pc].r = 0;
+          return OP_sub;
+        case 0x3:
+          flash[pc].r = SREG_C;
+          return OP_adc;
+        }
+      break;
+    case 0x2:
+      switch ((op1 >> 10) & 0x3)
+        {
+        case 0x0:
+          return OP_and;
+        case 0x1:
+          return OP_eor;
+        case 0x2:
+          return OP_or;
+        case 0x3:
+          return OP_mov;
+        }
+      break;
+    case 0x3:
+      return OP_cpi;
+    case 0x4:
+      return OP_sbci;
+    case 0x5:
+      return OP_subi;
+    case 0x6:
+      return OP_ori;
+    case 0x7:
+      return OP_andi;
+    case 0x8:
+    case 0xa:
+      if (op1 & 0x0200)
+        {
+          if (op1 & 0x0008)
+            {
+              flash[pc].r = get_q (op1);
+              return OP_std_Y;
+            }
+          else
+            {
+              flash[pc].r = get_q (op1);
+              return OP_std_Z;
+            }
+        }
+      else
+        {
+          if (op1 & 0x0008)
+            {
+              flash[pc].r = get_q (op1);
+              return OP_ldd_Y;
+            }
+          else
+            {
+              flash[pc].r = get_q (op1);
+              return OP_ldd_Z;
+            }
+        }
+      return;
+    case 0x9: /* 9xxx */
+      switch ((op1 >> 8) & 0xf)
+        {
+        case 0x0:
+        case 0x1:
+          switch ((op1 >> 0) & 0xf)
+            {
+            case 0x0:
+              return OP_lds;
+            case 0x1:
+              return OP_ld_Z_inc;
+            case 0x2:
+              return OP_ld_dec_Z;
+            case 0x4:
+              return OP_lpm_Z;
+            case 0x5:
+              return OP_lpm_inc_Z;
+            case 0x6:
+              return OP_elpm_Z;
+            case 0x7:
+              return OP_elpm_inc_Z;
+            case 0x9:
+              return OP_ld_Y_inc;
+            case 0xa:
+              return OP_ld_dec_Y;
+            case 0xc:
+              return OP_ld_X;
+            case 0xd:
+              return OP_ld_X_inc;
+            case 0xe:
+              return OP_ld_dec_X;
+            case 0xf:
+              return OP_pop;
+            }
+          break;
+        case 0x2:
+        case 0x3:
+          switch ((op1 >> 0) & 0xf)
+            {
+            case 0x0:
+              return OP_sts;
+            case 0x1:
+              return OP_st_Z_inc;
+            case 0x2:
+              return OP_st_dec_Z;
+            case 0x9:
+              return OP_st_Y_inc;
+            case 0xa:
+              return OP_st_dec_Y;
+            case 0xc:
+              return OP_st_X;
+            case 0xd:
+              return OP_st_X_inc;
+            case 0xe:
+              return OP_st_dec_X;
+            case 0xf:
+              return OP_push;
+            }
+          break;
+        case 0x4:
+        case 0x5:
+          switch (op1 & 0xf)
+            {
+            case 0x0:
+              return OP_com;
+            case 0x1:
+              return OP_neg;
+            case 0x2:
+              return OP_swap;
+            case 0x3:
+              return OP_inc;
+            case 0x5:
+              flash[pc].r = 0x80;
+              return OP_asr;
+            case 0x6:
+              flash[pc].r = 0;
+              return OP_lsr;
+            case 0x7:
+              return OP_ror;
+            case 0x8: /* 9[45]x8 */
+              switch ((op1 >> 4) & 0x1f)
+                {
+                case 0x00:
+                case 0x01:
+                case 0x02:
+                case 0x03:
+                case 0x04:
+                case 0x05:
+                case 0x06:
+                case 0x07:
+                  return OP_bset;
+                case 0x08:
+                case 0x09:
+                case 0x0a:
+                case 0x0b:
+                case 0x0c:
+                case 0x0d:
+                case 0x0e:
+                case 0x0f:
+                  return OP_bclr;
+                case 0x10:
+                  return OP_ret;
+                case 0x11:
+                  return OP_reti;
+                case 0x19:
+                  return OP_break;
+                case 0x1c:
+                  return OP_lpm;
+                case 0x1d:
+                  return OP_elpm;
+                default:
+                  break;
+                }
+              break;
+            case 0x9: /* 9[45]x9 */
+              switch ((op1 >> 4) & 0x1f)
+                {
+                case 0x00:
+                  return OP_ijmp;
+                case 0x01:
+                  return OP_eijmp;
+                case 0x10:
+                  return OP_icall;
+                case 0x11:
+                  return OP_eicall;
+                default:
+                  break;
+                }
+              break;
+            case 0xa:
+              return OP_dec;
+            case 0xc:
+            case 0xd:
+              flash[pc].r = ((op1 & 0x1f0) >> 3) | (op1 & 1);
+              return OP_jmp;
+            case 0xe:
+            case 0xf:
+              flash[pc].r = ((op1 & 0x1f0) >> 3) | (op1 & 1);
+              return OP_call;
+            }
+          break;
+        case 0x6:
+          return OP_adiw;
+        case 0x7:
+          return OP_sbiw;
+        case 0x8:
+          return OP_cbi;
+        case 0x9:
+          return OP_sbic;
+        case 0xa:
+          return OP_sbi;
+        case 0xb:
+          return OP_sbis;
+        case 0xc:
+        case 0xd:
+        case 0xe:
+        case 0xf:
+          return OP_mul;
+        }
+      break;
+    case 0xb:
+      flash[pc].r = get_A (op1);
+      if (((op1 >> 11) & 1) == 0)
+        return OP_in;
+      else
+        return OP_out;
+    case 0xc:
+      return OP_rjmp;
+    case 0xd:
+      return OP_rcall;
+    case 0xe:
+      return OP_ldi;
+    case 0xf:
+      switch ((op1 >> 9) & 7)
+        {
+        case 0:
+        case 1:
+          flash[pc].r = 1 << (op1 & 7);
+          return OP_brbs;
+        case 2:
+        case 3:
+          flash[pc].r = 1 << (op1 & 7);
+          return OP_brbc;
+        case 4:
+          if ((op1 & 8) == 0)
+            {
+              flash[pc].r = 1 << (op1 & 7);
+              return OP_bld;
+            }
+          break;
+        case 5:
+          if ((op1 & 8) == 0)
+            {
+              flash[pc].r = 1 << (op1 & 7);
+              return OP_bst;
+            }
+          break;
+        case 6:
+          if ((op1 & 8) == 0)
+            {
+              flash[pc].r = 1 << (op1 & 7);
+              return OP_sbrc;
+            }
+          break;
+        case 7:
+          if ((op1 & 8) == 0)
+            {
+              flash[pc].r = 1 << (op1 & 7);
+              return OP_sbrs;
+            }
+          break;
+        }
+    }
+  sim_cb_eprintf (callback,
+                  "Unhandled instruction at pc=0x%x, op=%04x\n", pc * 2, op1);
+  return OP_bad;
+}
+
+/* Disassemble an instruction.  */
+
+static int
+disasm_read_memory (bfd_vma memaddr, bfd_byte *myaddr, unsigned int length,
+			struct disassemble_info *info)
+{
+  int res;
+
+  res = sim_read (NULL, memaddr, myaddr, length);
+  if (res != length)
+    return -1;
+  return 0;
+}
+
+/* Memory error support for an opcodes disassembler.  */
+
+static void
+disasm_perror_memory (int status, bfd_vma memaddr,
+			  struct disassemble_info *info)
+{
+  if (status != -1)
+    /* Can't happen.  */
+    info->fprintf_func (info->stream, "Unknown error %d.", status);
+  else
+    /* Actually, address between memaddr and memaddr + len was
+       out of bounds.  */
+    info->fprintf_func (info->stream,
+			"Address 0x%x is out of bounds.",
+			(int) memaddr);
+}
+
+static void
+disassemble_insn (SIM_DESC sd, SIM_ADDR pc)
+{
+  struct disassemble_info disasm_info;
+  int len;
+  int i;
+
+  INIT_DISASSEMBLE_INFO (disasm_info, callback, sim_cb_eprintf);
+
+  disasm_info.arch = bfd_get_arch (cur_bfd);
+  disasm_info.mach = bfd_get_mach (cur_bfd);
+  disasm_info.endian = BFD_ENDIAN_LITTLE;
+  disasm_info.read_memory_func = disasm_read_memory;
+  disasm_info.memory_error_func = disasm_perror_memory;
+
+  len = print_insn_avr (pc << 1, &disasm_info);
+  len = len / 2;
+  for (i = 0; i < len; i++)
+    sim_cb_eprintf (callback, " %04x", flash[pc + i].op);
+}
+
+static void
+do_call (unsigned int npc)
+{
+  unsigned int sp = read_word (REG_SP);
+
+  /* Big endian!  */
+  sram[sp--] = pc;
+  sram[sp--] = pc >> 8;
+  if (avr_pc22)
+    {
+      sram[sp--] = pc >> 16;
+      cycles++;
+    }
+  write_word (REG_SP, sp);
+  pc = npc & PC_MASK;
+  cycles += 3;
+}
+
+static int
+get_insn_length (unsigned int p)
+{
+  if (flash[p].code == OP_unknown)
+    flash[p].code = decode(p);
+  if (flash[p].code >= OP_2words)
+    return 2;
+  else
+    return 1;
+}
+
+static unsigned int
+get_z (void)
+{
+  return (sram[RAMPZ] << 16) | (sram[REGZ_HI] << 8) | sram[REGZ_LO];
+}
+
+static unsigned char
+get_lpm (unsigned int addr)
+{
+  word w;
+
+  w = flash[(addr >> 1) & PC_MASK].op;
+  if (addr & 1)
+    w >>= 8;
+  return w;
+}
+
+static void
+gen_mul (unsigned int res)
+{
+  write_word (0, res);
+  sram[SREG] &= ~(SREG_Z | SREG_C);
+  if (res == 0)
+    sram[SREG] |= SREG_Z;
+  if (res & 0x8000)
+    sram[SREG] |= SREG_C;
+  cycles++;
+}
+
+void
+sim_resume (SIM_DESC sd, int step, int signal)
+{
+  unsigned int ipc;
+
+  if (step)
+    {
+      cpu_exception = sim_stopped;
+      cpu_signal = TARGET_SIGNAL_TRAP;
+    }
+  else
+    cpu_exception = sim_running;
+
+  do
+    {
+      int code;
+      word op;
+      byte res;
+      byte r, d, vd;
+
+    again:
+      code = flash[pc].code;
+      op = flash[pc].op;
+
+
+      if ((tracing || lock_step) && code != OP_unknown)
+	{
+	  if (verbose > 0) {
+	    int flags;
+	    int i;
+	    
+	    sim_cb_eprintf (callback, "R00-07:");
+	    for (i = 0; i < 8; i++)
+	      sim_cb_eprintf (callback, " %02x", sram[i]);
+	    sim_cb_eprintf (callback, " -");
+	    for (i = 8; i < 16; i++)
+	      sim_cb_eprintf (callback, " %02x", sram[i]);
+	    sim_cb_eprintf (callback, "  SP: %02x %02x",
+                            sram[REG_SP + 1], sram[REG_SP]);
+	    sim_cb_eprintf (callback, "\n");
+	    sim_cb_eprintf (callback, "R16-31:");
+	    for (i = 16; i < 24; i++)
+	      sim_cb_eprintf (callback, " %02x", sram[i]);
+	    sim_cb_eprintf (callback, " -");
+	    for (i = 24; i < 32; i++)
+	      sim_cb_eprintf (callback, " %02x", sram[i]);
+	    sim_cb_eprintf (callback, "  ");
+	    flags = sram[SREG];
+	    for (i = 0; i < 8; i++)
+	      sim_cb_eprintf (callback, "%c",
+                              flags & (0x80 >> i) ? "ITHSVNZC"[i] : '-');
+	    sim_cb_eprintf (callback, "\n");
+	  }
+
+	  if (lock_step && !tracing)
+	    sim_cb_eprintf (callback, "%06x: %04x\n", 2 * pc, flash[pc].op);
+	  else
+	    {
+	      sim_cb_eprintf (callback, "pc=0x%06x insn=0x%04x code=%d r=%d\n",
+                              2 * pc, flash[pc].op, code, flash[pc].r);
+	      disassemble_insn (sd, pc);
+	      sim_cb_eprintf (callback, "\n");
+	    }
+	}
+
+      ipc = pc;
+      pc = (pc + 1) & PC_MASK;
+      cycles++;
+
+      switch (code)
+	{
+	case OP_unknown:
+          flash[ipc].code = decode(ipc);
+	  pc = ipc;
+	  cycles--;
+	  goto again;
+	  break;
+
+	case OP_nop:
+          break;
+
+	case OP_jmp:
+	  /* 2 words instruction, but we don't care about the pc.  */
+	  pc = ((flash[ipc].r << 16) | flash[ipc + 1].op) & PC_MASK;
+	  cycles += 2;
+	  break;
+
+	case OP_eijmp:
+	  pc = ((sram[EIND] << 16) | read_word (REGZ)) & PC_MASK;
+	  cycles += 2;
+	  break;
+
+	case OP_ijmp:
+	  pc = read_word (REGZ) & PC_MASK;
+	  cycles += 1;
+	  break;
+
+	case OP_call:
+	  /* 2 words instruction.  */
+	  pc++;
+	  do_call ((flash[ipc].r << 16) | flash[ipc + 1].op);
+	  break;
+
+	case OP_eicall:
+	  do_call ((sram[EIND] << 16) | read_word (REGZ));
+	  break;
+
+	case OP_icall:
+	  do_call (read_word (REGZ));
+	  break;
+
+	case OP_rcall:
+	  do_call (pc + sign_ext (op & 0xfff, 12));
+	  break;
+
+	case OP_reti:
+          sram[SREG] |= SREG_I;
+          /* Fall through */
+	case OP_ret:
+	  {
+	    unsigned int sp = read_word (REG_SP);
+	    if (avr_pc22)
+	      {
+		pc = sram[++sp] = pc << 16;
+		cycles++;
+	      }
+	    else
+	      pc = 0;
+	    pc |= sram[++sp] << 8;
+	    pc |= sram[++sp];
+	    write_word (REG_SP, sp);
+	  }
+	  cycles += 3;
+	  break;
+	  
+	case OP_break:
+	  /* Stop on this address.  */
+	  cpu_exception = sim_stopped;
+	  cpu_signal = TARGET_SIGNAL_TRAP;
+	  pc = ipc;
+	  break;
+
+	case OP_bld:
+	  d = get_d (op);
+	  r = flash[ipc].r;
+	  if (sram[SREG] & SREG_T)
+	    sram[d] |= r;
+	  else
+	    sram[d] &= ~r;
+	  break;
+
+	case OP_bst:
+	  if (sram[get_d (op)] & flash[ipc].r)
+	    sram[SREG] |= SREG_T;
+	  else
+	    sram[SREG] &= ~SREG_T;
+	  break;
+
+	case OP_sbrc:
+	case OP_sbrs:
+	  if (((sram[get_d (op)] & flash[ipc].r) == 0) ^ ((op & 0x0200) != 0))
+            {
+              int l = get_insn_length(pc);
+              pc += l;
+              cycles += l;
+            }
+	  break;
+
+	case OP_push:
+	  {
+	    unsigned int sp = read_word (REG_SP);
+	    sram[sp--] = sram[get_d (op)];
+	    write_word (REG_SP, sp);
+	  }
+	  cycles++;
+	  break;
+
+	case OP_pop:
+	  {
+	    unsigned int sp = read_word (REG_SP);
+	    sram[get_d (op)] = sram[++sp];
+	    write_word (REG_SP, sp);
+	  }
+	  cycles++;
+	  break;
+
+	case OP_bclr:
+	  sram[SREG] &= ~(1 << ((op >> 4) & 0x7));
+	  break;
+
+	case OP_bset:
+	  sram[SREG] |= 1 << ((op >> 4) & 0x7);
+	  break;
+
+	case OP_rjmp:
+	  pc = (pc + sign_ext (op & 0xfff, 12)) & PC_MASK;
+	  cycles++;
+	  break;
+
+	case OP_eor:
+	  d = get_d (op);
+	  res = sram[d] ^ sram[get_r (op)];
+	  sram[d] = res;
+	  update_flags_logic (res);
+	  break;
+
+	case OP_and:
+	  d = get_d (op);
+	  res = sram[d] & sram[get_r (op)];
+	  sram[d] = res;
+	  update_flags_logic (res);
+	  break;
+
+	case OP_andi:
+	  d = get_d16 (op);
+	  res = sram[d] & get_K (op);
+	  sram[d] = res;
+	  update_flags_logic (res);
+	  break;
+
+	case OP_or:
+	  d = get_d (op);
+	  res = sram[d] | sram[get_r (op)];
+	  sram[d] = res;
+	  update_flags_logic (res);
+	  break;
+
+	case OP_ori:
+	  d = get_d16 (op);
+	  res = sram[d] | get_K (op);
+	  sram[d] = res;
+	  update_flags_logic (res);
+	  break;
+
+	case OP_com:
+	  d = get_d (op);
+	  res = ~sram[d];
+	  sram[d] = res;
+	  update_flags_logic (res);
+	  sram[SREG] |= SREG_C;
+	  break;
+
+	case OP_swap:
+	  d = get_d (op);
+	  vd = sram[d];
+	  sram[d] = (vd >> 4) | (vd << 4);
+	  break;
+
+	case OP_neg:
+	  d = get_d (op);
+	  vd = sram[d];
+	  res = -vd;
+	  sram[d] = res;
+	  sram[SREG] &= ~(SREG_H | SREG_S | SREG_V | SREG_N | SREG_Z | SREG_C);
+	  if (res == 0)
+	    sram[SREG] |= SREG_Z;
+	  else
+	    sram[SREG] |= SREG_C;
+	  if (res == 0x80)
+	    sram[SREG] |= SREG_V | SREG_N;
+	  else if (res & 0x80)
+	    sram[SREG] |= SREG_N | SREG_S;
+	  if ((res | vd) & 0x08)
+	    sram[SREG] |= SREG_H;
+	  break;
+
+	case OP_inc:
+	  d = get_d (op);
+	  res = sram[d] + 1;
+	  sram[d] = res;
+	  sram[SREG] &= ~(SREG_S | SREG_V | SREG_N | SREG_Z);
+	  if (res == 0x80)
+	    sram[SREG] |= SREG_V | SREG_N;
+	  else if (res & 0x80)
+	    sram[SREG] |= SREG_N | SREG_S;
+	  else if (res == 0)
+	    sram[SREG] |= SREG_Z;
+	  break;
+
+	case OP_dec:
+	  d = get_d (op);
+	  res = sram[d] - 1;
+	  sram[d] = res;
+	  sram[SREG] &= ~(SREG_S | SREG_V | SREG_N | SREG_Z);
+	  if (res == 0x7f)
+	    sram[SREG] |= SREG_V | SREG_S;
+	  else if (res & 0x80)
+	    sram[SREG] |= SREG_N | SREG_S;
+	  else if (res == 0)
+	    sram[SREG] |= SREG_Z;
+	  break;
+
+	case OP_lsr:
+	case OP_asr:
+	  d = get_d (op);
+	  vd = sram[d];
+	  res = (vd >> 1) | (vd & flash[ipc].r);
+	  sram[d] = res;
+	  sram[SREG] &= ~(SREG_S | SREG_V | SREG_N | SREG_Z | SREG_C);
+	  if (vd & 1)
+	    sram[SREG] |= SREG_C | SREG_S;
+	  if (res & 0x80)
+	    sram[SREG] |= SREG_N;
+          if (!(sram[SREG] & SREG_N) ^ !(sram[SREG] & SREG_C))
+            sram[SREG] |= SREG_V;
+	  if (res == 0)
+	    sram[SREG] |= SREG_Z;
+	  break;
+
+	case OP_ror:
+	  d = get_d (op);
+	  vd = sram[d];
+	  res = vd >> 1 | (sram[SREG] << 7);
+	  sram[d] = res;
+	  sram[SREG] &= ~(SREG_S | SREG_V | SREG_N | SREG_Z | SREG_C);
+	  if (vd & 1)
+	    sram[SREG] |= SREG_C | SREG_S;
+	  if (res & 0x80)
+	    sram[SREG] |= SREG_N;
+          if (!(sram[SREG] & SREG_N) ^ !(sram[SREG] & SREG_C))
+            sram[SREG] |= SREG_V;
+	  if (res == 0)
+	    sram[SREG] |= SREG_Z;
+	  break;
+
+	case OP_mul:
+          gen_mul ((word)sram[get_r (op)] * (word)sram[get_d (op)]);
+	  break;
+
+	case OP_muls:
+	  gen_mul((sword)(sbyte)sram[get_r16 (op)] 
+                  * (sword)(sbyte)sram[get_d16 (op)]);
+	  break;
+
+	case OP_mulsu:
+	  gen_mul ((sword)(word)sram[get_r16_23 (op)] 
+                   * (sword)(sbyte)sram[get_d16_23 (op)]);
+	  break;
+
+	case OP_fmul:
+	  gen_mul(((word)sram[get_r16_23 (op)] 
+                   * (word)sram[get_d16_23 (op)]) << 1);
+	  break;
+
+	case OP_fmuls:
+	  gen_mul(((sword)(sbyte)sram[get_r16_23 (op)] 
+                   * (sword)(sbyte)sram[get_d16_23 (op)]) << 1);
+	  break;
+
+	case OP_fmulsu:
+	  gen_mul(((sword)(word)sram[get_r16_23 (op)] 
+                   * (sword)(sbyte)sram[get_d16_23 (op)]) << 1);
+	  break;
+
+	case OP_adc:
+	case OP_add:
+	  r = sram[get_r (op)];
+	  d = get_d (op);
+	  vd = sram[d];
+	  res = r + vd + (sram[SREG] & flash[ipc].r);
+	  sram[d] = res;
+	  update_flags_add (res, vd, r);
+	  break;
+
+	case OP_sub:
+	  d = get_d (op);
+	  vd = sram[d];
+	  r = sram[get_r (op)];
+	  res = vd - r;
+	  sram[d] = res;
+	  update_flags_sub (res, vd, r);
+	  if (res == 0)
+	    sram[SREG] |= SREG_Z;
+	  break;
+
+	case OP_sbc:
+	  {
+	    byte old = sram[SREG];
+	    d = get_d (op);
+	    vd = sram[d];
+	    r = sram[get_r (op)];
+	    res = vd - r - (old & SREG_C);
+	    sram[d] = res;
+	    update_flags_sub (res, vd, r);
+	    if (res == 0 && (old & SREG_Z))
+	      sram[SREG] |= SREG_Z;
+	  }
+	  break;
+
+	case OP_subi:
+	  d = get_d16 (op);
+	  vd = sram[d];
+	  r = get_K (op);
+	  res = vd - r;
+	  sram[d] = res;
+	  update_flags_sub (res, vd, r);
+	  if (res == 0)
+	    sram[SREG] |= SREG_Z;
+	  break;
+
+	case OP_sbci:
+	  {
+	    byte old = sram[SREG];
+
+	    d = get_d16 (op);
+	    vd = sram[d];
+	    r = get_K (op);
+	    res = vd - r - (old & SREG_C);
+	    sram[d] = res;
+	    update_flags_sub (res, vd, r);
+	    if (res == 0 && (old & SREG_Z))
+	      sram[SREG] |= SREG_Z;
+	  }
+	  break;
+
+	case OP_mov:
+	  sram[get_d (op)] = sram[get_r (op)];
+	  break;
+
+	case OP_movw:
+	  d = (op & 0xf0) >> 3;
+	  r = (op & 0x0f) << 1;
+	  sram[d] = sram[r];
+	  sram[d + 1] = sram[r + 1];
+	  break;
+
+	case OP_out:
+	  d = get_A (op) + 0x20;
+	  res = sram[get_d (op)];
+	  sram[d] = res;
+	  if (d == STDIO_PORT)
+	    putchar (res);
+	  else if (d == EXIT_PORT)
+	    {
+	      cpu_exception = sim_exited;
+	      cpu_signal = 0;
+	      return;
+	    }
+	  else if (d == ABORT_PORT)
+	    {
+	      cpu_exception = sim_exited;
+	      cpu_signal = 1;
+	      return;
+	    }
+	  break;
+
+	case OP_in:
+	  d = get_A (op) + 0x20;
+	  sram[get_d (op)] = sram[d];
+	  break;
+
+        case OP_cbi:
+	  d = get_biA (op) + 0x20;
+          sram[d] &= ~(1 << get_b(op));
+          break;
+
+        case OP_sbi:
+	  d = get_biA (op) + 0x20;
+          sram[d] |= 1 << get_b(op);
+          break;
+
+        case OP_sbic:
+          if (!(sram[get_biA (op) + 0x20] & 1 << get_b(op)))
+            {
+              int l = get_insn_length(pc);
+              pc += l;
+              cycles += l;
+            }
+          break;
+
+        case OP_sbis:
+          if (sram[get_biA (op) + 0x20] & 1 << get_b(op))
+            {
+              int l = get_insn_length(pc);
+              pc += l;
+              cycles += l;
+            }
+          break;
+
+	case OP_ldi:
+	  res = get_K (op);
+	  d = get_d16 (op);
+	  sram[d] = res;
+	  break;
+
+	case OP_lds:
+	  sram[get_d (op)] = sram[flash[pc].op];
+	  pc++;
+	  cycles++;
+	  break;
+
+	case OP_sts:
+	  sram[flash[pc].op] = sram[get_d (op)];
+	  pc++;
+	  cycles++;
+	  break;
+
+	case OP_cpse:
+	  if (sram[get_r (op)] == sram[get_d (op)])
+            {
+              int l = get_insn_length(pc);
+              pc += l;
+              cycles += l;
+            }
+	  break;
+
+	case OP_cp:
+	  r = sram[get_r (op)];
+	  d = sram[get_d (op)];
+	  res = d - r;
+	  update_flags_sub (res, d, r);
+	  if (res == 0)
+	    sram[SREG] |= SREG_Z;
+	  break;
+
+	case OP_cpi:
+	  r = get_K (op);
+	  d = sram[get_d16 (op)];
+	  res = d - r;
+	  update_flags_sub (res, d, r);
+	  if (res == 0)
+	    sram[SREG] |= SREG_Z;
+	  break;
+
+	case OP_cpc:
+	  {
+	    byte old = sram[SREG];
+	    d = sram[get_d (op)];
+	    r = sram[get_r (op)];
+	    res = d - r - (old & SREG_C);
+	    update_flags_sub (res, d, r);
+	    if (res == 0 && (old & SREG_Z))
+	      sram[SREG] |= SREG_Z;
+	  }
+	  break;
+
+	case OP_brbc:
+	  if (!(sram[SREG] & flash[ipc].r))
+	    {
+	      pc = (pc + get_k (op)) & PC_MASK;
+	      cycles++;
+	    }
+	  break;
+
+	case OP_brbs:
+	  if (sram[SREG] & flash[ipc].r)
+	    {
+	      pc = (pc + get_k (op)) & PC_MASK;
+	      cycles++;
+	    }
+	  break;
+
+	case OP_lpm:
+          sram[0] = get_lpm (read_word (REGZ));
+	  cycles += 2;
+	  break;
+
+	case OP_lpm_Z:
+          sram[get_d (op)] = get_lpm (read_word (REGZ));
+	  cycles += 2;
+	  break;
+
+	case OP_lpm_inc_Z:
+          sram[get_d (op)] = get_lpm (read_word_post_inc (REGZ));
+	  cycles += 2;
+	  break;
+
+	case OP_elpm:
+          sram[0] = get_lpm (get_z ());
+	  cycles += 2;
+	  break;
+
+	case OP_elpm_Z:
+          sram[get_d (op)] = get_lpm (get_z ());
+	  cycles += 2;
+	  break;
+
+	case OP_elpm_inc_Z:
+	  {
+	    unsigned int z = get_z ();
+
+	    sram[get_d (op)] = get_lpm (z);
+	    z++;
+	    sram[REGZ_LO] = z;
+	    sram[REGZ_HI] = z >> 8;
+	    sram[RAMPZ] = z >> 16;
+	  }
+	  cycles += 2;
+	  break;
+
+	case OP_ld_Z_inc:
+	  sram[get_d (op)] = sram[read_word_post_inc (REGZ) & SRAM_MASK];
+	  cycles++;
+	  break;
+
+	case OP_ld_dec_Z:
+	  sram[get_d (op)] = sram[read_word_pre_dec (REGZ) & SRAM_MASK];
+	  cycles++;
+	  break;
+
+	case OP_ld_X_inc:
+	  sram[get_d (op)] = sram[read_word_post_inc (REGX) & SRAM_MASK];
+	  cycles++;
+	  break;
+
+	case OP_ld_dec_X:
+	  sram[get_d (op)] = sram[read_word_pre_dec (REGX) & SRAM_MASK];
+	  cycles++;
+	  break;
+
+	case OP_ld_Y_inc:
+	  sram[get_d (op)] = sram[read_word_post_inc (REGY) & SRAM_MASK];
+	  cycles++;
+	  break;
+
+	case OP_ld_dec_Y:
+	  sram[get_d (op)] = sram[read_word_pre_dec (REGY) & SRAM_MASK];
+	  cycles++;
+	  break;
+
+	case OP_st_X:
+	  sram[read_word (REGX) & SRAM_MASK] = sram[get_d (op)];
+	  cycles++;
+	  break;
+
+	case OP_st_X_inc:
+	  sram[read_word_post_inc (REGX) & SRAM_MASK] = sram[get_d (op)];
+	  cycles++;
+	  break;
+
+	case OP_st_dec_X:
+	  sram[read_word_pre_dec (REGX) & SRAM_MASK] = sram[get_d (op)];
+	  cycles++;
+	  break;
+
+	case OP_st_Z_inc:
+	  sram[read_word_post_inc (REGZ) & SRAM_MASK] = sram[get_d (op)];
+	  cycles++;
+	  break;
+
+	case OP_st_dec_Z:
+	  sram[read_word_pre_dec (REGZ) & SRAM_MASK] = sram[get_d (op)];
+	  cycles++;
+	  break;
+
+	case OP_st_Y_inc:
+	  sram[read_word_post_inc (REGY) & SRAM_MASK] = sram[get_d (op)];
+	  cycles++;
+	  break;
+
+	case OP_st_dec_Y:
+	  sram[read_word_pre_dec (REGY) & SRAM_MASK] = sram[get_d (op)];
+	  cycles++;
+	  break;
+
+	case OP_std_Y:
+	  sram[read_word (REGY) + flash[ipc].r] = sram[get_d (op)];
+	  cycles++;
+	  break;
+
+	case OP_std_Z:
+	  sram[read_word (REGZ) + flash[ipc].r] = sram[get_d (op)];
+	  cycles++;
+	  break;
+
+	case OP_ldd_Z:
+	  sram[get_d (op)] = sram[read_word (REGZ) + flash[ipc].r];
+	  cycles++;
+	  break;
+
+	case OP_ldd_Y:
+	  sram[get_d (op)] = sram[read_word (REGY) + flash[ipc].r];
+	  cycles++;
+	  break;
+
+	case OP_ld_X:
+	  sram[get_d (op)] = sram[read_word (REGX) & SRAM_MASK];
+	  cycles++;
+	  break;
+
+	case OP_sbiw:
+	  {
+	    word wk = get_k6 (op);
+	    word wres;
+	    word wr;
+	    
+	    d = get_d24 (op);
+	    wr = read_word (d);
+	    wres = wr - wk;
+
+	    sram[SREG] &= ~(SREG_S | SREG_V | SREG_N | SREG_Z | SREG_C);
+	    if (wres == 0)
+	      sram[SREG] |= SREG_Z;
+	    if (wres & 0x8000)
+	      sram[SREG] |= SREG_N;
+	    if (wres & ~wr & 0x8000)
+	      sram[SREG] |= SREG_C;
+	    if (~wres & wr & 0x8000)
+	      sram[SREG] |= SREG_V;
+	    if (((~wres & wr) ^ wres) & 0x8000)
+	      sram[SREG] |= SREG_S;
+	    write_word (d, wres);
+	  }
+	  cycles++;
+	  break;
+
+	case OP_adiw:
+	  {
+	    word wk = get_k6 (op);
+	    word wres;
+	    word wr;
+	    
+	    d = get_d24 (op);
+	    wr = read_word (d);
+	    wres = wr + wk;
+
+	    sram[SREG] &= ~(SREG_S | SREG_V | SREG_N | SREG_Z | SREG_C);
+	    if (wres == 0)
+	      sram[SREG] |= SREG_Z;
+	    if (wres & 0x8000)
+	      sram[SREG] |= SREG_N;
+	    if (~wres & wr & 0x8000)
+	      sram[SREG] |= SREG_C;
+	    if (wres & ~wr & 0x8000)
+	      sram[SREG] |= SREG_V;
+	    if (((wres & ~wr) ^ wres) & 0x8000)
+	      sram[SREG] |= SREG_S;
+	    write_word (d, wres);
+	  }
+	  cycles++;
+	  break;
+
+	case OP_bad:
+	  sim_cb_eprintf (callback, "Bad instruction at pc=0x%x\n", ipc * 2);
+	  return;
+
+	default:
+	  sim_cb_eprintf (callback,
+                          "Unhandled instruction at pc=0x%x, code=%d\n",
+                          2 * ipc, code);
+	  return;
+	}
+    }
+  while (cpu_exception == sim_running);
+}
+
+
+int
+sim_trace (SIM_DESC sd)
+{
+  tracing = 1;
+  
+  sim_resume (sd, 0, 0);
+
+  tracing = 0;
+  
+  return 1;
+}
+
+int
+sim_write (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
+{
+  int osize = size;
+
+  if (addr >= 0 && addr < SRAM_VADDR)
+    {
+      if (addr & 1)
+	return 0;
+      addr /= 2;
+      while (size > 1 && addr < MAX_AVR_FLASH)
+	{
+	  flash[addr].op = buffer[0] | (buffer[1] << 8);
+	  flash[addr].code = OP_unknown;
+	  addr++;
+	  buffer += 2;
+	  size -= 2;
+	}
+      return osize - size;
+    }
+  else if (addr >= SRAM_VADDR && addr < SRAM_VADDR + MAX_AVR_SRAM)
+    {
+      addr -= SRAM_VADDR;
+      if (addr + size > MAX_AVR_SRAM)
+	size = MAX_AVR_SRAM - addr;
+      memcpy (sram + addr, buffer, size);
+      return size;
+    }
+  else
+    return 0;
+}
+
+int
+sim_read (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
+{
+  int i;
+  int osize = size;
+
+  if (addr >= 0 && addr < SRAM_VADDR)
+    {
+      if (addr & 1)
+	return 0;
+      addr /= 2;
+      while (size > 1 && addr < MAX_AVR_FLASH)
+	{
+	  buffer[0] = flash[addr].op;
+	  buffer[1] = flash[addr].op >> 8;
+	  addr++;
+	  buffer += 2;
+	  size -= 2;
+	}
+      return osize - size;
+    }
+  else if (addr >= SRAM_VADDR && addr < SRAM_VADDR + MAX_AVR_SRAM)
+    {
+      addr -= SRAM_VADDR;
+      if (addr + size > MAX_AVR_SRAM)
+	size = MAX_AVR_SRAM - addr;
+      memcpy (buffer, sram + addr, size);
+      return size;
+    }
+  else
+    {
+      /* Avoid errors.  */
+      memset (buffer, 0, size);
+      return size;
+    }
+}
+
+int
+sim_store_register (SIM_DESC sd, int rn, unsigned char *memory, int length)
+{
+  if (rn < 32 && length == 1)
+    {
+      sram[rn] = *memory;
+      return 1;
+    }
+  if (rn == AVR_SREG_REGNUM && length == 1)
+    {
+      sram[SREG] = *memory;
+      return 1;
+    }
+  if (rn == AVR_SP_REGNUM && length == 2)
+    {
+      sram[REG_SP] = memory[0];
+      sram[REG_SP + 1] = memory[1];
+      return 2;
+    }
+  if (rn == AVR_PC_REGNUM && length == 4)
+    {
+      pc = (memory[0] >> 1) | (memory[1] << 7) 
+	| (memory[2] << 15) | (memory[3] << 23);
+      pc &= PC_MASK;
+      return 4;
+    }
+  return 0;
+}
+
+int
+sim_fetch_register (SIM_DESC sd, int rn, unsigned char *memory, int length)
+{
+  if (rn < 32 && length == 1)
+    {
+      *memory = sram[rn];
+      return 1;
+    }
+  if (rn == AVR_SREG_REGNUM && length == 1)
+    {
+      *memory = sram[SREG];
+      return 1;
+    }
+  if (rn == AVR_SP_REGNUM && length == 2)
+    {
+      memory[0] = sram[REG_SP];
+      memory[1] = sram[REG_SP + 1];
+      return 2;
+    }
+  if (rn == AVR_PC_REGNUM && length == 4)
+    {
+      memory[0] = pc << 1;
+      memory[1] = pc >> 7;
+      memory[2] = pc >> 15;
+      memory[3] = pc >> 23;
+      return 4;
+    }
+  return 0;
+}
+
+void
+sim_stop_reason (SIM_DESC sd, enum sim_stop * reason,  int *sigrc)
+{
+  *reason = cpu_exception;
+  *sigrc = cpu_signal;
+}
+
+int
+sim_stop (SIM_DESC sd)
+{
+  cpu_exception = sim_stopped;
+  cpu_signal = TARGET_SIGNAL_INT;
+  return 0;
+}
+
+void
+sim_info (SIM_DESC sd, int verbose)
+{
+  callback->printf_filtered
+    (callback, "\n\n# cycles  %10u\n", cycles);
+}
+
+SIM_DESC
+sim_open (SIM_OPEN_KIND kind, host_callback *cb, struct bfd *abfd, char **argv)
+{
+  myname = argv[0];
+  callback = cb;
+  
+  cur_bfd = abfd;
+
+  /* Fudge our descriptor for now.  */
+  return (SIM_DESC) 1;
+}
+
+void
+sim_close (SIM_DESC sd, int quitting)
+{
+  /* nothing to do */
+}
+
+SIM_RC
+sim_load (SIM_DESC sd, char *prog, bfd *abfd, int from_tty)
+{
+  bfd *prog_bfd;
+
+  prog_bfd = sim_load_file (sd, myname, callback, prog, abfd,
+                            sim_kind == SIM_OPEN_DEBUG,
+                            0, sim_write);
+  if (prog_bfd == NULL)
+    return SIM_RC_FAIL;
+
+  avr_pc22 = (bfd_get_mach (prog_bfd) >= bfd_mach_avr6);
+
+  if (abfd != NULL)
+    cur_bfd = abfd;
+
+  return SIM_RC_OK;
+}
+
+SIM_RC
+sim_create_inferior (SIM_DESC sd, struct bfd *prog_bfd, char **argv, char **env)
+{
+  /* Set the initial register set.  */
+  pc = 0;
+  
+  return SIM_RC_OK;
+}
+
+void
+sim_kill (SIM_DESC sd)
+{
+  /* nothing to do */
+}
+
+void
+sim_do_command (SIM_DESC sd, char *cmd)
+{
+  /* Nothing there yet; it's all an error.  */
+  
+  if (cmd == NULL)
+    return;
+
+  if (strcmp (cmd, "verbose") == 0)
+    verbose = 2;
+  else if (strcmp (cmd, "trace") == 0)
+    tracing = 1;
+  else
+    sim_cb_eprintf (callback,
+                    "Error: \"%s\" is not a valid avr simulator command.\n",
+                    cmd);
+}
+
+void
+sim_set_callbacks (host_callback *ptr)
+{
+  callback = ptr; 
+}
diff -Naur gdb-6.8.50.20090329.orig/sim/avr/Makefile.in gdb-6.8.50.20090329/sim/avr/Makefile.in
--- gdb-6.8.50.20090329.orig/sim/avr/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/avr/Makefile.in	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,25 @@
+#    Makefile template for Configure for the AVR sim library.
+#    Copyright (C) 2009
+#    Free Software Foundation, Inc.
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+## COMMON_PRE_CONFIG_FRAG
+
+SIM_OBJS = interp.o sim-load.o
+SIM_EXTRA_LIBS = -lm
+
+## COMMON_POST_CONFIG_FRAG
+
+interp.o: interp.c
diff -Naur gdb-6.8.50.20090329.orig/sim/common/gennltvals.sh gdb-6.8.50.20090329/sim/common/gennltvals.sh
--- gdb-6.8.50.20090329.orig/sim/common/gennltvals.sh	2008-04-08 10:44:51.000000000 +0200
+++ gdb-6.8.50.20090329/sim/common/gennltvals.sh	2009-04-17 15:30:42.000000000 +0200
@@ -73,3 +73,6 @@
 $shell ${srccom}/gentvals.sh $target sys ${srcroot}/$dir \
 	"syscall.h" 'SYS_[_A-Za-z0-9]*' "${cpp}"
 
+dir=libgloss target=lm32
+$shell ${srccom}/gentvals.sh $target sys ${srcroot}/$dir \
+        "syscall.h" 'SYS_[_A-Za-z0-9]*' "${cpp}"
diff -Naur gdb-6.8.50.20090329.orig/sim/common/gentmap.c gdb-6.8.50.20090329/sim/common/gentmap.c
--- gdb-6.8.50.20090329.orig/sim/common/gentmap.c	2006-11-07 20:29:59.000000000 +0100
+++ gdb-6.8.50.20090329/sim/common/gentmap.c	2009-04-17 15:30:42.000000000 +0200
@@ -2,6 +2,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 
 struct tdefs {
   char *symbol;
diff -Naur gdb-6.8.50.20090329.orig/sim/common/nltvals.def gdb-6.8.50.20090329/sim/common/nltvals.def
--- gdb-6.8.50.20090329.orig/sim/common/nltvals.def	2008-04-08 10:44:51.000000000 +0200
+++ gdb-6.8.50.20090329/sim/common/nltvals.def	2009-04-17 15:30:42.000000000 +0200
@@ -454,3 +454,30 @@
 /* end cr16 sys target macros */
 #endif
 #endif
+#ifdef NL_TARGET_lm32
+#ifdef sys_defs
+/* from syscall.h */
+/* begin lm32 sys target macros */
+ { "SYS_argv", 13 },
+ { "SYS_argvlen", 12 },
+ { "SYS_chdir", 14 },
+ { "SYS_chmod", 16 },
+ { "SYS_close", 3 },
+ { "SYS_exit", 1 },
+ { "SYS_fstat", 10 },
+ { "SYS_getpid", 8 },
+ { "SYS_gettimeofday", 19 },
+ { "SYS_kill", 9 },
+ { "SYS_link", 21 },
+ { "SYS_lseek", 6 },
+ { "SYS_open", 2 },
+ { "SYS_read", 4 },
+ { "SYS_stat", 15 },
+ { "SYS_time", 18 },
+ { "SYS_times", 20 },
+ { "SYS_unlink", 7 },
+ { "SYS_utime", 17 },
+ { "SYS_write", 5 },
+/* end lm32 sys target macros */
+#endif
+#endif
diff -Naur gdb-6.8.50.20090329.orig/sim/configure gdb-6.8.50.20090329/sim/configure
--- gdb-6.8.50.20090329.orig/sim/configure	2008-04-08 11:15:56.000000000 +0200
+++ gdb-6.8.50.20090329/sim/configure	2009-04-17 15:30:42.000000000 +0200
@@ -273,12 +273,14 @@
 
 ac_unique_file="Makefile.in"
 ac_subdirs_all="$ac_subdirs_all arm"
+ac_subdirs_all="$ac_subdirs_all avr"
 ac_subdirs_all="$ac_subdirs_all cr16"
 ac_subdirs_all="$ac_subdirs_all cris"
 ac_subdirs_all="$ac_subdirs_all d10v"
 ac_subdirs_all="$ac_subdirs_all frv"
 ac_subdirs_all="$ac_subdirs_all h8300"
 ac_subdirs_all="$ac_subdirs_all iq2000"
+ac_subdirs_all="$ac_subdirs_all lm32"
 ac_subdirs_all="$ac_subdirs_all m32c"
 ac_subdirs_all="$ac_subdirs_all m32r"
 ac_subdirs_all="$ac_subdirs_all m68hc11"
@@ -3424,6 +3426,12 @@
 
 	   testsuite=yes
 	   ;;
+       avr*-*-*)
+
+
+subdirs="$subdirs avr"
+
+	   ;;
        cr16*-*-*)
 
 
@@ -3465,6 +3473,13 @@
 
 	   testsuite=yes
 	   ;;
+       lm32-*-*)
+
+
+subdirs="$subdirs lm32"
+
+	   testsuite=yes
+           ;;
        m32c-*-*)
 
 
diff -Naur gdb-6.8.50.20090329.orig/sim/configure.ac gdb-6.8.50.20090329/sim/configure.ac
--- gdb-6.8.50.20090329.orig/sim/configure.ac	2008-04-08 11:15:56.000000000 +0200
+++ gdb-6.8.50.20090329/sim/configure.ac	2009-04-17 15:30:42.000000000 +0200
@@ -51,6 +51,9 @@
            AC_CONFIG_SUBDIRS(arm)
 	   testsuite=yes
 	   ;;
+       avr*-*-*)
+           AC_CONFIG_SUBDIRS(avr)
+	   ;;
        cr16*-*-*)
 	   AC_CONFIG_SUBDIRS(cr16)
 	   testsuite=yes
@@ -74,6 +77,10 @@
            AC_CONFIG_SUBDIRS(iq2000)
 	   testsuite=yes
 	   ;;
+       lm32-*-*)
+           AC_CONFIG_SUBDIRS(lm32)
+	   testsuite=yes
+           ;;
        m32c-*-*)
            AC_CONFIG_SUBDIRS(m32c)
            ;;
diff -Naur gdb-6.8.50.20090329.orig/sim/erc32/configure gdb-6.8.50.20090329/sim/erc32/configure
--- gdb-6.8.50.20090329.orig/sim/erc32/configure	2008-07-11 04:35:40.000000000 +0200
+++ gdb-6.8.50.20090329/sim/erc32/configure	2009-04-17 15:30:42.000000000 +0200
@@ -309,7 +309,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS sim_environment sim_alignment sim_assert sim_bitsize sim_endian sim_hostendian sim_float sim_scache sim_default_model sim_hw_cflags sim_hw_objs sim_hw sim_inline sim_packages sim_regparm sim_reserved_bits sim_smp sim_stdcall sim_xor_endian WARN_CFLAGS WERROR_CFLAGS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CC_FOR_BUILD HDEFINES AR RANLIB ac_ct_RANLIB USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CPP EGREP MAINT sim_bswap sim_cflags sim_debug sim_stdio sim_trace sim_profile PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI TERMCAP READLINE cgen_breaks LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS sim_environment sim_alignment sim_assert sim_bitsize sim_endian sim_hostendian sim_float sim_scache sim_default_model sim_hw_cflags sim_hw_objs sim_hw sim_inline sim_packages sim_regparm sim_reserved_bits sim_smp sim_stdcall sim_xor_endian WARN_CFLAGS WERROR_CFLAGS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CC_FOR_BUILD HDEFINES AR RANLIB ac_ct_RANLIB USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CPP EGREP MAINT sim_bswap sim_cflags sim_debug sim_stdio sim_trace sim_profile PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI READLINE READLINE_DEPS READLINE_CFLAGS cgen_breaks LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -863,6 +863,7 @@
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-pkgversion=PKG   Use PKG in the version string in place of "GDB"
   --with-bugurl=URL       Direct users to URL to report a bug
+  --with-system-readline  use installed readline library
 
 Some influential environment variables:
   CC          C compiler command
@@ -1509,8 +1510,7 @@
 
 # Test for GNAT.
 # We require the gnatbind program, and a compiler driver that
-# understands Ada.  We use the user's CC setting, already found,
-# and possibly add $1 to the command-line parameters.
+# understands Ada.  We use the user's CC setting, already found.
 #
 # Sets the shell variable have_gnat to yes or no as appropriate, and
 # substitutes GNATBIND and GNATMAKE.
@@ -1537,8 +1537,6 @@
 
 
 
-
-
 # Bugs in autoconf 2.59 break the call to SIM_AC_COMMON, hack around
 # it by inlining the macro's contents.
 # This file contains common code used by all simulators.
@@ -4940,57 +4938,36 @@
 done
 
 
-# In the Cygwin environment, we need some additional flags.
-echo "$as_me:$LINENO: checking for cygwin" >&5
-echo $ECHO_N "checking for cygwin... $ECHO_C" >&6
-if test "${sim_cv_os_cygwin+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
 
-#ifdef __CYGWIN__
-lose
-#endif
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "lose" >/dev/null 2>&1; then
-  sim_cv_os_cygwin=yes
-else
-  sim_cv_os_cygwin=no
-fi
-rm -f conftest*
+# Check whether --with-system-readline or --without-system-readline was given.
+if test "${with_system_readline+set}" = set; then
+  withval="$with_system_readline"
 
-fi
-echo "$as_me:$LINENO: result: $sim_cv_os_cygwin" >&5
-echo "${ECHO_T}$sim_cv_os_cygwin" >&6
+fi;
 
-if test x$sim_cv_os_cygwin = xyes; then
-  TERMCAP='`if test -r ../../libtermcap/libtermcap.a; then echo ../../libtermcap/libtermcap.a; else echo -ltermcap; fi` -luser32'
-else
-  echo "$as_me:$LINENO: checking for main in -ltermcap" >&5
-echo $ECHO_N "checking for main in -ltermcap... $ECHO_C" >&6
-if test "${ac_cv_lib_termcap_main+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ltermcap  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
+if test "$with_system_readline" = yes; then
+  echo "$as_me:$LINENO: checking for readline" >&5
+echo $ECHO_N "checking for readline... $ECHO_C" >&6
+  save_LIBS="$LIBS"
+  LIBS="-lreadline $save_LIBS"
+  cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char add_history ();
 int
 main ()
 {
-main ();
+add_history ();
   ;
   return 0;
 }
@@ -5017,41 +4994,13 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_termcap_main=yes
+  READLINE=-lreadline
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_termcap_main=no
-fi
-rm -f conftest.err conftest.$ac_objext \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_termcap_main" >&5
-echo "${ECHO_T}$ac_cv_lib_termcap_main" >&6
-if test $ac_cv_lib_termcap_main = yes; then
-  TERMCAP=-ltermcap
-else
-  TERMCAP=""
-fi
-
-fi
-
-
-# We prefer the in-tree readline.  Top-level dependencies make sure
-# src/readline (if it's there) is configured before src/sim.
-if test -r ../../readline/Makefile; then
-  READLINE=../../readline/libreadline.a
-else
-  echo "$as_me:$LINENO: checking for readline in -lreadline" >&5
-echo $ECHO_N "checking for readline in -lreadline... $ECHO_C" >&6
-if test "${ac_cv_lib_readline_readline+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lreadline $TERMCAP $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
+ LIBS="-lreadline -lncurses $save_LIBS"
+      cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5064,11 +5013,11 @@
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char readline ();
+char add_history ();
 int
 main ()
 {
-readline ();
+add_history ();
   ;
   return 0;
 }
@@ -5095,28 +5044,34 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_readline_readline=yes
+  READLINE="-lreadline -lncurses"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_readline_readline=no
+{ { echo "$as_me:$LINENO: error: unable to detect readline" >&5
+echo "$as_me: error: unable to detect readline" >&2;}
+   { (exit 1); exit 1; }; }
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_readline_readline" >&5
-echo "${ECHO_T}$ac_cv_lib_readline_readline" >&6
-if test $ac_cv_lib_readline_readline = yes; then
-  READLINE=-lreadline
-else
-  { { echo "$as_me:$LINENO: error: the required \"readline\" library is missing" >&5
-echo "$as_me: error: the required \"readline\" library is missing" >&2;}
-   { (exit 1); exit 1; }; }
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  LIBS="$save_LIBS"
+  echo "$as_me:$LINENO: result: $READLINE" >&5
+echo "${ECHO_T}$READLINE" >&6
+  READLINE_DEPS=
+  READLINE_CFLAGS=
+else
+  READLINE='$(READLINE_DIR)/libreadline.a'
+  READLINE_DEPS='$(READLINE)'
+  READLINE_CFLAGS='-I$(READLINE_SRC)/..'
 fi
 
-fi
+
+
 
 
 ac_sources="$sim_link_files"
@@ -5839,8 +5794,9 @@
 s,@PKGVERSION@,$PKGVERSION,;t t
 s,@REPORT_BUGS_TO@,$REPORT_BUGS_TO,;t t
 s,@REPORT_BUGS_TEXI@,$REPORT_BUGS_TEXI,;t t
-s,@TERMCAP@,$TERMCAP,;t t
 s,@READLINE@,$READLINE,;t t
+s,@READLINE_DEPS@,$READLINE_DEPS,;t t
+s,@READLINE_CFLAGS@,$READLINE_CFLAGS,;t t
 s,@cgen_breaks@,$cgen_breaks,;t t
 s,@LIBOBJS@,$LIBOBJS,;t t
 s,@LTLIBOBJS@,$LTLIBOBJS,;t t
diff -Naur gdb-6.8.50.20090329.orig/sim/erc32/configure.ac gdb-6.8.50.20090329/sim/erc32/configure.ac
--- gdb-6.8.50.20090329.orig/sim/erc32/configure.ac	2006-12-20 23:35:51.000000000 +0100
+++ gdb-6.8.50.20090329/sim/erc32/configure.ac	2009-04-17 15:30:42.000000000 +0200
@@ -11,27 +11,32 @@
 
 AC_CHECK_HEADERS(stdlib.h)
 
-# In the Cygwin environment, we need some additional flags.
-AC_CACHE_CHECK([for cygwin], sim_cv_os_cygwin,
-[AC_EGREP_CPP(lose, [
-#ifdef __CYGWIN__
-lose
-#endif],[sim_cv_os_cygwin=yes],[sim_cv_os_cygwin=no])])
+AC_ARG_WITH([system-readline],
+  [AS_HELP_STRING([--with-system-readline],
+                  [use installed readline library])])
 
-if test x$sim_cv_os_cygwin = xyes; then
-  TERMCAP='`if test -r ../../libtermcap/libtermcap.a; then echo ../../libtermcap/libtermcap.a; else echo -ltermcap; fi` -luser32'
+if test "$with_system_readline" = yes; then
+  AC_MSG_CHECKING([for readline])
+  save_LIBS="$LIBS"
+  LIBS="-lreadline $save_LIBS"
+  AC_LINK_IFELSE([AC_LANG_CALL([],
+    [add_history])], [READLINE=-lreadline], 
+    [ LIBS="-lreadline -lncurses $save_LIBS"
+      AC_LINK_IFELSE([AC_LANG_CALL([],
+        [add_history])], [READLINE="-lreadline -lncurses"],
+        [AC_MSG_ERROR([unable to detect readline])])
+    ])
+  LIBS="$save_LIBS"
+  AC_MSG_RESULT($READLINE)
+  READLINE_DEPS=
+  READLINE_CFLAGS=
 else
-  AC_CHECK_LIB(termcap, main, TERMCAP=-ltermcap, TERMCAP="")
-fi
-AC_SUBST(TERMCAP)
-
-# We prefer the in-tree readline.  Top-level dependencies make sure
-# src/readline (if it's there) is configured before src/sim.
-if test -r ../../readline/Makefile; then
-  READLINE=../../readline/libreadline.a
-else
-  AC_CHECK_LIB(readline, readline, READLINE=-lreadline,
-	       AC_ERROR([the required "readline" library is missing]), $TERMCAP)
+  READLINE='$(READLINE_DIR)/libreadline.a'
+  READLINE_DEPS='$(READLINE)'
+  READLINE_CFLAGS='-I$(READLINE_SRC)/..'
 fi
 AC_SUBST(READLINE)
+AC_SUBST(READLINE_DEPS)
+AC_SUBST(READLINE_CFLAGS)
+
 SIM_AC_OUTPUT
diff -Naur gdb-6.8.50.20090329.orig/sim/erc32/erc32.c gdb-6.8.50.20090329/sim/erc32/erc32.c
--- gdb-6.8.50.20090329.orig/sim/erc32/erc32.c	2008-11-11 23:20:54.000000000 +0100
+++ gdb-6.8.50.20090329/sim/erc32/erc32.c	2009-04-17 15:30:42.000000000 +0200
@@ -414,7 +414,7 @@
     if (rom8) mec_memcfg &= ~0x20000;
     else mec_memcfg |= 0x20000;
 
-    mem_ramsz = (256 * 1024) << ((mec_memcfg >> 10) & 7);
+    mem_ramsz = (512 * 1024) << ((mec_memcfg >> 10) & 7);
     mem_romsz = (128 * 1024) << ((mec_memcfg >> 18) & 7);
 
     if (sparclite_board) {
diff -Naur gdb-6.8.50.20090329.orig/sim/erc32/Makefile.in gdb-6.8.50.20090329/sim/erc32/Makefile.in
--- gdb-6.8.50.20090329.orig/sim/erc32/Makefile.in	2009-01-14 11:53:07.000000000 +0100
+++ gdb-6.8.50.20090329/sim/erc32/Makefile.in	2009-04-17 15:30:42.000000000 +0200
@@ -19,12 +19,12 @@
 
 ## COMMON_PRE_CONFIG_FRAG
 
-TERMCAP_LIB = @TERMCAP@
+# TERMCAP_LIB = -lncurses
 READLINE_LIB = @READLINE@
 
 SIM_OBJS = exec.o erc32.o func.o help.o float.o interf.o
 SIM_EXTRA_LIBS = $(READLINE_LIB) $(TERMCAP_LIB) -lm
-SIM_EXTRA_ALL = sis
+SIM_EXTRA_ALL = sis$(EXEEXT)
 SIM_EXTRA_INSTALL = install-sis
 SIM_EXTRA_CLEAN = clean-sis
 
@@ -38,8 +38,8 @@
 # `sis' doesn't need interf.o.
 SIS_OFILES = exec.o erc32.o func.o help.o float.o
 
-sis: sis.o $(SIS_OFILES) $(COMMON_OBJS) $(LIBDEPS)
-	$(CC) $(ALL_CFLAGS) -o sis \
+sis$(EXEEXT): sis.o $(SIS_OFILES) $(COMMON_OBJS) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) -o sis$(EXEEXT) \
 	  sis.o $(SIS_OFILES) $(COMMON_OBJS) $(EXTRA_LIBS)
 
 # FIXME: This computes the build host's endianness, doesn't it?
@@ -52,11 +52,11 @@
 
 # Copy the files into directories where they will be run.
 install-sis: installdirs
-	n=`echo sis | sed '$(program_transform_name)'`; \
-	$(INSTALL_PROGRAM) sis$(EXEEXT) $(DESTDIR)$(bindir)/$$n$(EXEEXT)
+	n=`echo sis$(EXEEXT) | sed '$(program_transform_name)'`; \
+	$(INSTALL_PROGRAM) sis$(EXEEXT) $(DESTDIR)$(bindir)/$$n
 
 clean-sis:
-	rm -f sis end end.h
+	rm -f sis$(EXEEXT) end end.h
 
 configure:
 	@echo "Rebuilding configure..."
diff -Naur gdb-6.8.50.20090329.orig/sim/h8300/compile.c gdb-6.8.50.20090329/sim/h8300/compile.c
--- gdb-6.8.50.20090329.orig/sim/h8300/compile.c	2008-12-01 17:10:45.000000000 +0100
+++ gdb-6.8.50.20090329/sim/h8300/compile.c	2009-04-17 15:30:42.000000000 +0200
@@ -38,6 +38,12 @@
 # define SIGTRAP 5
 #endif
 
+#ifdef _WIN32
+#ifndef SIGBUS
+#define SIGBUS 10
+#endif
+#endif
+
 int debug;
 
 host_callback *sim_callback;
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/arch.c gdb-6.8.50.20090329/sim/lm32/arch.c
--- gdb-6.8.50.20090329.orig/sim/lm32/arch.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/arch.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,35 @@
+/* Simulator support for lm32.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sim-main.h"
+#include "bfd.h"
+
+const MACH *sim_machs[] =
+{
+#ifdef HAVE_CPU_LM32BF
+  & lm32_mach,
+#endif
+  0
+};
+
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/arch.h gdb-6.8.50.20090329/sim/lm32/arch.h
--- gdb-6.8.50.20090329.orig/sim/lm32/arch.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/arch.h	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,44 @@
+/* Simulator header for lm32.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef LM32_ARCH_H
+#define LM32_ARCH_H
+
+#define TARGET_BIG_ENDIAN 1
+
+/* Enum declaration for model types.  */
+typedef enum model_type {
+  MODEL_LM32, MODEL_MAX
+} MODEL_TYPE;
+
+#define MAX_MODELS ((int) MODEL_MAX)
+
+/* Enum declaration for unit types.  */
+typedef enum unit_type {
+  UNIT_NONE, UNIT_LM32_U_EXEC, UNIT_MAX
+} UNIT_TYPE;
+
+#define MAX_UNITS (1)
+
+#endif /* LM32_ARCH_H */
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/config.in gdb-6.8.50.20090329/sim/lm32/config.in
--- gdb-6.8.50.20090329.orig/sim/lm32/config.in	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/config.in	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,116 @@
+/* config.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+#undef AC_APPLE_UNIVERSAL_BUILD
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#undef ENABLE_NLS
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <errno.h> header file. */
+#undef HAVE_ERRNO_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the <fpu_control.h> header file. */
+#undef HAVE_FPU_CONTROL_H
+
+/* Define to 1 if you have the `getrusage' function. */
+#undef HAVE_GETRUSAGE
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+#undef HAVE_LIBNSL
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+#undef HAVE_LIBSOCKET
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `sigaction' function. */
+#undef HAVE_SIGACTION
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#undef HAVE_SYS_RESOURCE_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the `time' function. */
+#undef HAVE_TIME
+
+/* Define to 1 if you have the <time.h> header file. */
+#undef HAVE_TIME_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#undef HAVE_ZLIB_H
+
+/* Define to 1 if you have the `__setfpucw' function. */
+#undef HAVE___SETFPUCW
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Additional package description */
+#undef PKGVERSION
+
+/* Bug reporting address */
+#undef REPORT_BUGS_TO
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#undef RETSIGTYPE
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#  undef WORDS_BIGENDIAN
+# endif
+#endif
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/configure gdb-6.8.50.20090329/sim/lm32/configure
--- gdb-6.8.50.20090329.orig/sim/lm32/configure	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/configure	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,6774 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="Makefile.in"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# if HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#if HAVE_STRING_H
+# if !STDC_HEADERS && HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#if HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#if HAVE_INTTYPES_H
+# include <inttypes.h>
+#else
+# if HAVE_STDINT_H
+#  include <stdint.h>
+# endif
+#endif
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS sim_environment sim_alignment sim_assert sim_bitsize sim_endian sim_hostendian sim_float sim_scache sim_default_model sim_hw_cflags sim_hw_objs sim_hw sim_inline sim_packages sim_regparm sim_reserved_bits sim_smp sim_stdcall sim_xor_endian WARN_CFLAGS WERROR_CFLAGS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CC_FOR_BUILD HDEFINES AR RANLIB ac_ct_RANLIB USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CPP EGREP MAINT sim_bswap sim_cflags sim_debug sim_stdio sim_trace sim_profile PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI CGEN_MAINT cgendir cgen cgen_breaks LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CPP_set=${CPP+set}
+ac_env_CPP_value=$CPP
+ac_cv_env_CPP_set=${CPP+set}
+ac_cv_env_CPP_value=$CPP
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-maintainer-mode		Enable developer functionality.
+  --enable-sim-bswap			Use Host specific BSWAP instruction.
+  --enable-sim-cflags=opts		Extra CFLAGS for use in building simulator
+  --enable-sim-debug=opts		Enable debugging flags
+  --enable-sim-stdio			Specify whether to use stdio for console input/output.
+  --enable-sim-trace=opts		Enable tracing flags
+  --enable-sim-profile=opts		Enable profiling flags
+  --enable-sim-endian=endian		Specify target byte endian orientation.
+  --enable-sim-alignment=align		Specify strict,  nonstrict or forced alignment of memory accesses.
+  --enable-sim-hostendian=end		Specify host byte endian orientation.
+  --enable-sim-scache=size		Specify simulator execution cache size.
+  --enable-sim-default-model=model	Specify default model to simulate.
+  --enable-sim-environment=environment	Specify mixed, user, virtual or operating environment.
+  --enable-cgen-maint=DIR    build cgen generated files
+  --enable-sim-hardware=LIST		Specify the hardware to be included in the build.
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-pkgversion=PKG   Use PKG in the version string in place of "GDB"
+  --with-bugurl=URL       Direct users to URL to report a bug
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
+              headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+          ac_config_headers="$ac_config_headers config.h:config.in"
+
+
+# This file contains common code used by all simulators.
+#
+# SIM_AC_COMMON invokes AC macros used by all simulators and by the common
+# directory.  It is intended to be invoked before any target specific stuff.
+# SIM_AC_OUTPUT is a cover function to AC_OUTPUT to generate the Makefile.
+# It is intended to be invoked last.
+#
+# The simulator's configure.in should look like:
+#
+# dnl Process this file with autoconf to produce a configure script.
+# sinclude(../common/aclocal.m4)
+# AC_PREREQ(2.5)dnl
+# AC_INIT(Makefile.in)
+#
+# SIM_AC_COMMON
+#
+# ... target specific stuff ...
+#
+# SIM_AC_OUTPUT
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+sim_inline="-DDEFAULT_INLINE=0"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# intl sister-directory configuration rules.
+#
+
+# The idea behind this macro is that there's no need to repeat all the
+# autoconf probes done by the intl directory - it's already done them
+# for us.  In fact, there's no need even to look at the cache for the
+# answers.  All we need to do is nab a few pieces of information.
+# The intl directory is set up to make this easy, by generating a
+# small file which can be sourced as a shell script; then we produce
+# the necessary substitutions and definitions for this directory.
+
+
+
+# Autoconf M4 include file defining utility macros for complex Canadian
+# cross builds.
+
+
+
+
+
+
+
+
+
+####
+# _NCN_TOOL_PREFIXES:  Some stuff that oughtta be done in AC_CANONICAL_SYSTEM
+# or AC_INIT.
+# These demand that AC_CANONICAL_SYSTEM be called beforehand.
+
+####
+# NCN_STRICT_CHECK_TOOLS(variable, progs-to-check-for,[value-if-not-found],[path])
+# Like plain AC_CHECK_TOOLS, but require prefix if build!=host.
+
+
+####
+# NCN_STRICT_CHECK_TARGET_TOOLS(variable, progs-to-check-for,[value-if-not-found],[path])
+# Like CVS Autoconf AC_CHECK_TARGET_TOOLS, but require prefix if build!=target.
+
+
+
+# Backported from Autoconf 2.5x; can go away when and if
+# we switch.  Put the OS path separator in $PATH_SEPARATOR.
+
+
+
+
+# ACX_HAVE_GCC_FOR_TARGET
+# Check if the variable GCC_FOR_TARGET really points to a GCC binary.
+
+
+# ACX_CHECK_INSTALLED_TARGET_TOOL(VAR, PROG)
+# Searching for installed target binutils.  We need to take extra care,
+# else we may find the wrong assembler, linker, etc., and lose.
+#
+# First try --with-build-time-tools, if specified.
+#
+# For build != host, we ask the installed GCC for the name of the tool it
+# uses, and accept it if it is an absolute path.  This is because the
+# only good choice for a compiler is the same GCC version that is being
+# installed (or we couldn't make target libraries), and we assume that
+# on the host system we'll have not only the same GCC version, but also
+# the same binutils version.
+#
+# For build == host, search the same directories that the installed
+# compiler will search.  We used to do this for the assembler, linker,
+# and nm only; for simplicity of configuration, however, we extend this
+# criterion to tools (such as ar and ranlib) that are never invoked by
+# the compiler, to avoid mismatches.
+#
+# Also note we have to check MD_EXEC_PREFIX before checking the user's path
+# if build == target.  This makes the most sense only when bootstrapping,
+# but we also do so when build != host.  In this case, we hope that the
+# build and host systems will have similar contents of MD_EXEC_PREFIX.
+#
+# If we do not find a suitable binary, then try the user's path.
+
+
+###
+# AC_PROG_CPP_WERROR
+# Used for autoconf 2.5x to force AC_PREPROC_IFELSE to reject code which
+# triggers warnings from the preprocessor.  Will be in autoconf 2.58.
+# For now, using this also overrides header checks to use only the
+# preprocessor (matches 2.13 behavior; matching 2.58's behavior is a
+# bit harder from here).
+# Eventually autoconf will default to checking headers with the compiler
+# instead, and we'll have to do this differently.
+
+# AC_PROG_CPP_WERROR
+
+# Test for GNAT.
+# We require the gnatbind program, and a compiler driver that
+# understands Ada.  We use the user's CC setting, already found.
+#
+# Sets the shell variable have_gnat to yes or no as appropriate, and
+# substitutes GNATBIND and GNATMAKE.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Bugs in autoconf 2.59 break the call to SIM_AC_COMMON, hack around
+# it by inlining the macro's contents.
+# This file contains common code used by all simulators.
+#
+# common.m4 invokes AC macros used by all simulators and by the common
+# directory.  It is intended to be included before any target specific
+# stuff.  SIM_AC_OUTPUT is a cover function to AC_OUTPUT to generate
+# the Makefile.  It is intended to be invoked last.
+#
+# The simulator's configure.in should look like:
+#
+# dnl Process this file with autoconf to produce a configure script.
+# AC_PREREQ(2.5)dnl
+# AC_INIT(Makefile.in)
+# AC_CONFIG_HEADER(config.h:config.in)
+#
+# sinclude(../common/aclocal.m4)
+# sinclude(../common/common.m4)
+#
+# ... target specific stuff ...
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
+target=$ac_cv_target
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+test "$program_prefix" != NONE &&
+  program_transform_name="s,^,$program_prefix,;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s,\$,$program_suffix,;$program_transform_name"
+# Double any \ or $.  echo might interpret backslashes.
+# By default was `s,x,x', remove it if useless.
+cat <<\_ACEOF >conftest.sed
+s/[\\$]/&&/g;s/;s,x,x,$//
+_ACEOF
+program_transform_name=`echo $program_transform_name | sed -f conftest.sed`
+rm conftest.sed
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$ac_ct_CC" && break
+done
+
+  CC=$ac_ct_CC
+fi
+
+fi
+
+
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO:" \
+     "checking for C compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6
+ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
+  (eval $ac_link_default) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+	;;
+    conftest.$ac_ext )
+	# This is the source file.
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	# FIXME: I believe we export ac_cv_exeext for Libtool,
+	# but it would be cool to find out if it's true.  Does anybody
+	# maintain Libtool? --akim.
+	export ac_cv_exeext
+	break;;
+    * )
+	break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6
+
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6
+
+echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  export ac_cv_exeext
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
+if test "${ac_cv_objext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
+GCC=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
+  *)
+    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
+esac
+
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat >conftest.$ac_ext <<_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   '' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include <stdlib.h>
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
+fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+# Put a plausible default for CC_FOR_BUILD in Makefile.
+if test "x$cross_compiling" = "xno"; then
+  CC_FOR_BUILD='$(CC)'
+else
+  CC_FOR_BUILD=gcc
+fi
+
+
+
+
+AR=${AR-ar}
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  RANLIB=$ac_ct_RANLIB
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+
+ALL_LINGUAS=
+# If we haven't got the data from the intl directory,
+# assume NLS is disabled.
+USE_NLS=no
+LIBINTL=
+LIBINTL_DEP=
+INCINTL=
+XGETTEXT=
+GMSGFMT=
+POSUB=
+
+if test -f  ../../intl/config.intl; then
+  .  ../../intl/config.intl
+fi
+echo "$as_me:$LINENO: checking whether NLS is requested" >&5
+echo $ECHO_N "checking whether NLS is requested... $ECHO_C" >&6
+if test x"$USE_NLS" != xyes; then
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+else
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_NLS 1
+_ACEOF
+
+
+  echo "$as_me:$LINENO: checking for catalogs to be installed" >&5
+echo $ECHO_N "checking for catalogs to be installed... $ECHO_C" >&6
+  # Look for .po and .gmo files in the source directory.
+  CATALOGS=
+  XLINGUAS=
+  for cat in $srcdir/po/*.gmo $srcdir/po/*.po; do
+    # If there aren't any .gmo files the shell will give us the
+    # literal string "../path/to/srcdir/po/*.gmo" which has to be
+    # weeded out.
+    case "$cat" in *\**)
+      continue;;
+    esac
+    # The quadruple backslash is collapsed to a double backslash
+    # by the backticks, then collapsed again by the double quotes,
+    # leaving us with one backslash in the sed expression (right
+    # before the dot that mustn't act as a wildcard).
+    cat=`echo $cat | sed -e "s!$srcdir/po/!!" -e "s!\\\\.po!.gmo!"`
+    lang=`echo $cat | sed -e "s!\\\\.gmo!!"`
+    # The user is allowed to set LINGUAS to a list of languages to
+    # install catalogs for.  If it's empty that means "all of them."
+    if test "x$LINGUAS" = x; then
+      CATALOGS="$CATALOGS $cat"
+      XLINGUAS="$XLINGUAS $lang"
+    else
+      case "$LINGUAS" in *$lang*)
+        CATALOGS="$CATALOGS $cat"
+        XLINGUAS="$XLINGUAS $lang"
+        ;;
+      esac
+    fi
+  done
+  LINGUAS="$XLINGUAS"
+  echo "$as_me:$LINENO: result: $LINGUAS" >&5
+echo "${ECHO_T}$LINGUAS" >&6
+
+
+    DATADIRNAME=share
+
+  INSTOBJEXT=.mo
+
+  GENCAT=gencat
+
+  CATOBJEXT=.gmo
+
+fi
+
+# Check for common headers.
+# FIXME: Seems to me this can cause problems for i386-windows hosts.
+# At one point there were hardcoded AC_DEFINE's if ${host} = i386-*-windows*.
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+
+for ac_header in stdlib.h string.h strings.h unistd.h time.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in sys/time.h sys/resource.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in fcntl.h fpu_control.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+for ac_header in dlfcn.h errno.h sys/stat.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+for ac_func in getrusage time sigaction __setfpucw
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+# Check for socket libraries
+
+echo "$as_me:$LINENO: checking for bind in -lsocket" >&5
+echo $ECHO_N "checking for bind in -lsocket... $ECHO_C" >&6
+if test "${ac_cv_lib_socket_bind+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char bind ();
+int
+main ()
+{
+bind ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_bind=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_socket_bind=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_socket_bind" >&5
+echo "${ECHO_T}$ac_cv_lib_socket_bind" >&6
+if test $ac_cv_lib_socket_bind = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSOCKET 1
+_ACEOF
+
+  LIBS="-lsocket $LIBS"
+
+fi
+
+
+echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
+echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBNSL 1
+_ACEOF
+
+  LIBS="-lnsl $LIBS"
+
+fi
+
+
+# BFD conditionally uses zlib, so we must link it in if libbfd does, by
+# using the same condition.
+echo "$as_me:$LINENO: checking for library containing zlibVersion" >&5
+echo $ECHO_N "checking for library containing zlibVersion... $ECHO_C" >&6
+if test "${ac_cv_search_zlibVersion+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_zlibVersion=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char zlibVersion ();
+int
+main ()
+{
+zlibVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_zlibVersion="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_zlibVersion" = no; then
+  for ac_lib in z; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char zlibVersion ();
+int
+main ()
+{
+zlibVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_zlibVersion="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_zlibVersion" >&5
+echo "${ECHO_T}$ac_cv_search_zlibVersion" >&6
+if test "$ac_cv_search_zlibVersion" != no; then
+  test "$ac_cv_search_zlibVersion" = "none required" || LIBS="$ac_cv_search_zlibVersion $LIBS"
+
+for ac_header in zlib.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+fi
+
+
+. ${srcdir}/../../bfd/configure.host
+
+
+
+USE_MAINTAINER_MODE=no
+# Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then
+  enableval="$enable_maintainer_mode"
+  case "${enableval}" in
+  yes)	MAINT="" USE_MAINTAINER_MODE=yes ;;
+  no)	MAINT="#" ;;
+  *)	{ { echo "$as_me:$LINENO: error: \"--enable-maintainer-mode does not take a value\"" >&5
+echo "$as_me: error: \"--enable-maintainer-mode does not take a value\"" >&2;}
+   { (exit 1); exit 1; }; }; MAINT="#" ;;
+esac
+if test x"$silent" != x"yes" && test x"$MAINT" = x""; then
+  echo "Setting maintainer mode" 6>&1
+fi
+else
+  MAINT="#"
+fi;
+
+
+# Check whether --enable-sim-bswap or --disable-sim-bswap was given.
+if test "${enable_sim_bswap+set}" = set; then
+  enableval="$enable_sim_bswap"
+  case "${enableval}" in
+  yes)	sim_bswap="-DWITH_BSWAP=1 -DUSE_BSWAP=1";;
+  no)	sim_bswap="-DWITH_BSWAP=0";;
+  *)	{ { echo "$as_me:$LINENO: error: \"--enable-sim-bswap does not take a value\"" >&5
+echo "$as_me: error: \"--enable-sim-bswap does not take a value\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_bswap="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_bswap" != x""; then
+  echo "Setting bswap flags = $sim_bswap" 6>&1
+fi
+else
+  sim_bswap=""
+fi;
+
+
+# Check whether --enable-sim-cflags or --disable-sim-cflags was given.
+if test "${enable_sim_cflags+set}" = set; then
+  enableval="$enable_sim_cflags"
+  case "${enableval}" in
+  yes)	 sim_cflags="-O2 -fomit-frame-pointer";;
+  trace) { { echo "$as_me:$LINENO: error: \"Please use --enable-sim-debug instead.\"" >&5
+echo "$as_me: error: \"Please use --enable-sim-debug instead.\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_cflags="";;
+  no)	 sim_cflags="";;
+  *)	 sim_cflags=`echo "${enableval}" | sed -e "s/,/ /g"`;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_cflags" != x""; then
+  echo "Setting sim cflags = $sim_cflags" 6>&1
+fi
+else
+  sim_cflags=""
+fi;
+
+
+# Check whether --enable-sim-debug or --disable-sim-debug was given.
+if test "${enable_sim_debug+set}" = set; then
+  enableval="$enable_sim_debug"
+  case "${enableval}" in
+  yes) sim_debug="-DDEBUG=7 -DWITH_DEBUG=7";;
+  no)  sim_debug="-DDEBUG=0 -DWITH_DEBUG=0";;
+  *)   sim_debug="-DDEBUG='(${enableval})' -DWITH_DEBUG='(${enableval})'";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_debug" != x""; then
+  echo "Setting sim debug = $sim_debug" 6>&1
+fi
+else
+  sim_debug=""
+fi;
+
+
+# Check whether --enable-sim-stdio or --disable-sim-stdio was given.
+if test "${enable_sim_stdio+set}" = set; then
+  enableval="$enable_sim_stdio"
+  case "${enableval}" in
+  yes)	sim_stdio="-DWITH_STDIO=DO_USE_STDIO";;
+  no)	sim_stdio="-DWITH_STDIO=DONT_USE_STDIO";;
+  *)	{ { echo "$as_me:$LINENO: error: \"Unknown value $enableval passed to --enable-sim-stdio\"" >&5
+echo "$as_me: error: \"Unknown value $enableval passed to --enable-sim-stdio\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_stdio="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_stdio" != x""; then
+  echo "Setting stdio flags = $sim_stdio" 6>&1
+fi
+else
+  sim_stdio=""
+fi;
+
+
+# Check whether --enable-sim-trace or --disable-sim-trace was given.
+if test "${enable_sim_trace+set}" = set; then
+  enableval="$enable_sim_trace"
+  case "${enableval}" in
+  yes)	sim_trace="-DTRACE=1 -DWITH_TRACE=-1";;
+  no)	sim_trace="-DTRACE=0 -DWITH_TRACE=0";;
+  [-0-9]*)
+	sim_trace="-DTRACE='(${enableval})' -DWITH_TRACE='(${enableval})'";;
+  [a-z]*)
+	sim_trace=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_trace" = x; then
+	    sim_trace="-DWITH_TRACE='(TRACE_$x"
+	  else
+	    sim_trace="${sim_trace}|TRACE_$x"
+	  fi
+	done
+	sim_trace="$sim_trace)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_trace" != x""; then
+  echo "Setting sim trace = $sim_trace" 6>&1
+fi
+else
+  sim_trace=""
+fi;
+
+
+# Check whether --enable-sim-profile or --disable-sim-profile was given.
+if test "${enable_sim_profile+set}" = set; then
+  enableval="$enable_sim_profile"
+  case "${enableval}" in
+  yes)	sim_profile="-DPROFILE=1 -DWITH_PROFILE=-1";;
+  no)	sim_profile="-DPROFILE=0 -DWITH_PROFILE=0";;
+  [-0-9]*)
+	sim_profile="-DPROFILE='(${enableval})' -DWITH_PROFILE='(${enableval})'";;
+  [a-z]*)
+	sim_profile=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_profile" = x; then
+	    sim_profile="-DWITH_PROFILE='(PROFILE_$x"
+	  else
+	    sim_profile="${sim_profile}|PROFILE_$x"
+	  fi
+	done
+	sim_profile="$sim_profile)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_profile" != x""; then
+  echo "Setting sim profile = $sim_profile" 6>&1
+fi
+else
+  sim_profile="-DPROFILE=1 -DWITH_PROFILE=-1"
+fi;
+
+
+
+# Check whether --with-pkgversion or --without-pkgversion was given.
+if test "${with_pkgversion+set}" = set; then
+  withval="$with_pkgversion"
+  case "$withval" in
+      yes) { { echo "$as_me:$LINENO: error: package version not specified" >&5
+echo "$as_me: error: package version not specified" >&2;}
+   { (exit 1); exit 1; }; } ;;
+      no)  PKGVERSION= ;;
+      *)   PKGVERSION="($withval) " ;;
+     esac
+else
+  PKGVERSION="(GDB) "
+
+fi;
+
+
+
+
+# Check whether --with-bugurl or --without-bugurl was given.
+if test "${with_bugurl+set}" = set; then
+  withval="$with_bugurl"
+  case "$withval" in
+      yes) { { echo "$as_me:$LINENO: error: bug URL not specified" >&5
+echo "$as_me: error: bug URL not specified" >&2;}
+   { (exit 1); exit 1; }; } ;;
+      no)  BUGURL=
+	   ;;
+      *)   BUGURL="$withval"
+	   ;;
+     esac
+else
+  BUGURL="http://www.gnu.org/software/gdb/bugs/"
+
+fi;
+  case ${BUGURL} in
+  "")
+    REPORT_BUGS_TO=
+    REPORT_BUGS_TEXI=
+    ;;
+  *)
+    REPORT_BUGS_TO="<$BUGURL>"
+    REPORT_BUGS_TEXI=@uref{`echo "$BUGURL" | sed 's/@/@@/g'`}
+    ;;
+  esac;
+
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define PKGVERSION "$PKGVERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define REPORT_BUGS_TO "$REPORT_BUGS_TO"
+_ACEOF
+
+
+echo "$as_me:$LINENO: checking return type of signal handlers" >&5
+echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
+if test "${ac_cv_type_signal+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+# undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int
+main ()
+{
+int i;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_signal=void
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_signal=int
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
+echo "${ECHO_T}$ac_cv_type_signal" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define RETSIGTYPE $ac_cv_type_signal
+_ACEOF
+
+
+
+
+
+sim_link_files=
+sim_link_links=
+
+sim_link_links=tconfig.h
+if test -f ${srcdir}/tconfig.in
+then
+  sim_link_files=tconfig.in
+else
+  sim_link_files=../common/tconfig.in
+fi
+
+# targ-vals.def points to the libc macro description file.
+case "${target}" in
+*-*-*) TARG_VALS_DEF=../common/nltvals.def ;;
+esac
+sim_link_files="${sim_link_files} ${TARG_VALS_DEF}"
+sim_link_links="${sim_link_links} targ-vals.def"
+
+
+
+wire_endian="BIG_ENDIAN"
+default_endian=""
+# Check whether --enable-sim-endian or --disable-sim-endian was given.
+if test "${enable_sim_endian+set}" = set; then
+  enableval="$enable_sim_endian"
+  case "${enableval}" in
+  b*|B*) sim_endian="-DWITH_TARGET_BYTE_ORDER=BIG_ENDIAN";;
+  l*|L*) sim_endian="-DWITH_TARGET_BYTE_ORDER=LITTLE_ENDIAN";;
+  yes)	 if test x"$wire_endian" != x; then
+	   sim_endian="-DWITH_TARGET_BYTE_ORDER=${wire_endian}"
+	 else
+           if test x"$default_endian" != x; then
+	     sim_endian="-DWITH_TARGET_BYTE_ORDER=${default_endian}"
+	   else
+	     echo "No hard-wired endian for target $target" 1>&6
+	     sim_endian="-DWITH_TARGET_BYTE_ORDER=0"
+	   fi
+	 fi;;
+  no)	 if test x"$default_endian" != x; then
+	   sim_endian="-DWITH_DEFAULT_TARGET_BYTE_ORDER=${default_endian}"
+	 else
+	   if test x"$wire_endian" != x; then
+	     sim_endian="-DWITH_DEFAULT_TARGET_BYTE_ORDER=${wire_endian}"
+	   else
+	     echo "No default endian for target $target" 1>&6
+	     sim_endian="-DWITH_DEFAULT_TARGET_BYTE_ORDER=0"
+	   fi
+	 fi;;
+  *)	 { { echo "$as_me:$LINENO: error: \"Unknown value $enableval for --enable-sim-endian\"" >&5
+echo "$as_me: error: \"Unknown value $enableval for --enable-sim-endian\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_endian="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_endian" != x""; then
+  echo "Setting endian flags = $sim_endian" 6>&1
+fi
+else
+  if test x"$default_endian" != x; then
+  sim_endian="-DWITH_DEFAULT_TARGET_BYTE_ORDER=${default_endian}"
+else
+  if test x"$wire_endian" != x; then
+    sim_endian="-DWITH_TARGET_BYTE_ORDER=${wire_endian}"
+  else
+    sim_endian=
+  fi
+fi
+fi;
+wire_alignment="STRICT_ALIGNMENT"
+default_alignment="STRICT_ALIGNMENT"
+
+# Check whether --enable-sim-alignment or --disable-sim-alignment was given.
+if test "${enable_sim_alignment+set}" = set; then
+  enableval="$enable_sim_alignment"
+  case "${enableval}" in
+  strict | STRICT)       sim_alignment="-DWITH_ALIGNMENT=STRICT_ALIGNMENT";;
+  nonstrict | NONSTRICT) sim_alignment="-DWITH_ALIGNMENT=NONSTRICT_ALIGNMENT";;
+  forced | FORCED)       sim_alignment="-DWITH_ALIGNMENT=FORCED_ALIGNMENT";;
+  yes) if test x"$wire_alignment" != x; then
+	 sim_alignment="-DWITH_ALIGNMENT=${wire_alignment}"
+       else
+         if test x"$default_alignment" != x; then
+           sim_alignment="-DWITH_ALIGNMENT=${default_alignment}"
+         else
+	   echo "No hard-wired alignment for target $target" 1>&6
+	   sim_alignment="-DWITH_ALIGNMENT=0"
+         fi
+       fi;;
+  no)  if test x"$default_alignment" != x; then
+	 sim_alignment="-DWITH_DEFAULT_ALIGNMENT=${default_alignment}"
+       else
+         if test x"$wire_alignment" != x; then
+	   sim_alignment="-DWITH_DEFAULT_ALIGNMENT=${wire_alignment}"
+         else
+           echo "No default alignment for target $target" 1>&6
+           sim_alignment="-DWITH_DEFAULT_ALIGNMENT=0"
+         fi
+       fi;;
+  *)   { { echo "$as_me:$LINENO: error: \"Unknown value $enableval passed to --enable-sim-alignment\"" >&5
+echo "$as_me: error: \"Unknown value $enableval passed to --enable-sim-alignment\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_alignment="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_alignment" != x""; then
+  echo "Setting alignment flags = $sim_alignment" 6>&1
+fi
+else
+  if test x"$default_alignment" != x; then
+  sim_alignment="-DWITH_DEFAULT_ALIGNMENT=${default_alignment}"
+else
+  if test x"$wire_alignment" != x; then
+    sim_alignment="-DWITH_ALIGNMENT=${wire_alignment}"
+  else
+    sim_alignment=
+  fi
+fi
+fi;
+
+# Check whether --enable-sim-hostendian or --disable-sim-hostendian was given.
+if test "${enable_sim_hostendian+set}" = set; then
+  enableval="$enable_sim_hostendian"
+  case "${enableval}" in
+  no)	 sim_hostendian="-DWITH_HOST_BYTE_ORDER=0";;
+  b*|B*) sim_hostendian="-DWITH_HOST_BYTE_ORDER=BIG_ENDIAN";;
+  l*|L*) sim_hostendian="-DWITH_HOST_BYTE_ORDER=LITTLE_ENDIAN";;
+  *)	 { { echo "$as_me:$LINENO: error: \"Unknown value $enableval for --enable-sim-hostendian\"" >&5
+echo "$as_me: error: \"Unknown value $enableval for --enable-sim-hostendian\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_hostendian="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_hostendian" != x""; then
+  echo "Setting hostendian flags = $sim_hostendian" 6>&1
+fi
+else
+
+if test "x$cross_compiling" = "xno"; then
+  echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
+echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6
+if test "${ac_cv_c_bigendian+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # See if sys/param.h defines the BYTE_ORDER macro.
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/param.h>
+
+int
+main ()
+{
+#if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
+ bogus endian macros
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  # It does; now see whether it defined to BIG_ENDIAN or not.
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/param.h>
+
+int
+main ()
+{
+#if BYTE_ORDER != BIG_ENDIAN
+ not big endian
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_bigendian=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_c_bigendian=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+# It does not; compile a test program.
+if test "$cross_compiling" = yes; then
+  # try to guess the endianness by grepping values into an object file
+  ac_cv_c_bigendian=unknown
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
+short ascii_ii[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
+void _ascii () { char *s = (char *) ascii_mm; s = (char *) ascii_ii; }
+short ebcdic_ii[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
+short ebcdic_mm[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
+void _ebcdic () { char *s = (char *) ebcdic_mm; s = (char *) ebcdic_ii; }
+int
+main ()
+{
+ _ascii (); _ebcdic ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null ; then
+  ac_cv_c_bigendian=yes
+fi
+if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
+  if test "$ac_cv_c_bigendian" = unknown; then
+    ac_cv_c_bigendian=no
+  else
+    # finding both strings is unlikely to happen, but who knows?
+    ac_cv_c_bigendian=unknown
+  fi
+fi
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+int
+main ()
+{
+  /* Are we little or big endian?  From Harbison&Steele.  */
+  union
+  {
+    long l;
+    char c[sizeof (long)];
+  } u;
+  u.l = 1;
+  exit (u.c[sizeof (long) - 1] == 1);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_bigendian=no
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_bigendian=yes
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
+echo "${ECHO_T}$ac_cv_c_bigendian" >&6
+case $ac_cv_c_bigendian in
+  yes)
+
+cat >>confdefs.h <<\_ACEOF
+#define WORDS_BIGENDIAN 1
+_ACEOF
+ ;;
+  no)
+     ;;
+  *)
+    { { echo "$as_me:$LINENO: error: unknown endianness
+presetting ac_cv_c_bigendian=no (or yes) will help" >&5
+echo "$as_me: error: unknown endianness
+presetting ac_cv_c_bigendian=no (or yes) will help" >&2;}
+   { (exit 1); exit 1; }; } ;;
+esac
+
+  if test $ac_cv_c_bigendian = yes; then
+    sim_hostendian="-DWITH_HOST_BYTE_ORDER=BIG_ENDIAN"
+  else
+    sim_hostendian="-DWITH_HOST_BYTE_ORDER=LITTLE_ENDIAN"
+  fi
+else
+  sim_hostendian="-DWITH_HOST_BYTE_ORDER=0"
+fi
+fi;
+
+default_sim_scache="16384"
+# Check whether --enable-sim-scache or --disable-sim-scache was given.
+if test "${enable_sim_scache+set}" = set; then
+  enableval="$enable_sim_scache"
+  case "${enableval}" in
+  yes)	sim_scache="-DWITH_SCACHE=${default_sim_scache}";;
+  no)	sim_scache="-DWITH_SCACHE=0" ;;
+  [0-9]*) sim_scache="-DWITH_SCACHE=${enableval}";;
+  *)	{ { echo "$as_me:$LINENO: error: \"Bad value $enableval passed to --enable-sim-scache\"" >&5
+echo "$as_me: error: \"Bad value $enableval passed to --enable-sim-scache\"" >&2;}
+   { (exit 1); exit 1; }; };
+	sim_scache="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_scache" != x""; then
+  echo "Setting scache size = $sim_scache" 6>&1
+fi
+else
+  sim_scache="-DWITH_SCACHE=${default_sim_scache}"
+fi;
+
+
+default_sim_default_model="lm32"
+# Check whether --enable-sim-default-model or --disable-sim-default-model was given.
+if test "${enable_sim_default_model+set}" = set; then
+  enableval="$enable_sim_default_model"
+  case "${enableval}" in
+  yes|no) { { echo "$as_me:$LINENO: error: \"Missing argument to --enable-sim-default-model\"" >&5
+echo "$as_me: error: \"Missing argument to --enable-sim-default-model\"" >&2;}
+   { (exit 1); exit 1; }; };;
+  *)	sim_default_model="-DWITH_DEFAULT_MODEL='\"${enableval}\"'";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_default_model" != x""; then
+  echo "Setting default model = $sim_default_model" 6>&1
+fi
+else
+  sim_default_model="-DWITH_DEFAULT_MODEL='\"${default_sim_default_model}\"'"
+fi;
+
+
+# Check whether --enable-sim-environment or --disable-sim-environment was given.
+if test "${enable_sim_environment+set}" = set; then
+  enableval="$enable_sim_environment"
+  case "${enableval}" in
+  all | ALL)             sim_environment="-DWITH_ENVIRONMENT=ALL_ENVIRONMENT";;
+  user | USER)           sim_environment="-DWITH_ENVIRONMENT=USER_ENVIRONMENT";;
+  virtual | VIRTUAL)     sim_environment="-DWITH_ENVIRONMENT=VIRTUAL_ENVIRONMENT";;
+  operating | OPERATING) sim_environment="-DWITH_ENVIRONMENT=OPERATING_ENVIRONMENT";;
+  *)   { { echo "$as_me:$LINENO: error: \"Unknown value $enableval passed to --enable-sim-environment\"" >&5
+echo "$as_me: error: \"Unknown value $enableval passed to --enable-sim-environment\"" >&2;}
+   { (exit 1); exit 1; }; };
+       sim_environment="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_environment" != x""; then
+  echo "Setting sim environment = $sim_environment" 6>&1
+fi
+else
+  sim_environment="-DWITH_ENVIRONMENT=ALL_ENVIRONMENT"
+fi;
+
+cgen_maint=no
+cgen=guile
+cgendir='$(srcdir)/../../cgen'
+# Check whether --enable-cgen-maint or --disable-cgen-maint was given.
+if test "${enable_cgen_maint+set}" = set; then
+  enableval="$enable_cgen_maint"
+  case "${enableval}" in
+  yes)	cgen_maint=yes ;;
+  no)	cgen_maint=no ;;
+  *)
+	# argument is cgen install directory (not implemented yet).
+	# Having a `share' directory might be more appropriate for the .scm,
+	# .cpu, etc. files.
+	cgendir=${cgen_maint}/lib/cgen
+	cgen=guile
+	;;
+esac
+fi; if test x${cgen_maint} != xno ; then
+  CGEN_MAINT=''
+else
+  CGEN_MAINT='#'
+fi
+
+
+
+
+
+if test x"yes" = x"yes"; then
+  sim_hw_p=yes
+else
+  sim_hw_p=no
+fi
+if test ""; then
+  hardware="core pal glue"
+else
+  hardware="core pal glue lm32cpu lm32timer lm32uart"
+fi
+sim_hw_cflags="-DWITH_HW=1"
+sim_hw="$hardware"
+sim_hw_objs="\$(SIM_COMMON_HW_OBJS) `echo $sim_hw | sed -e 's/\([^ ][^ ]*\)/dv-\1.o/g'`"
+# Check whether --enable-sim-hardware or --disable-sim-hardware was given.
+if test "${enable_sim_hardware+set}" = set; then
+  enableval="$enable_sim_hardware"
+
+case "${enableval}" in
+  yes)	sim_hw_p=yes;;
+  no)	sim_hw_p=no;;
+  ,*)   sim_hw_p=yes; hardware="${hardware} `echo ${enableval} | sed -e 's/,/ /'`";;
+  *,)   sim_hw_p=yes; hardware="`echo ${enableval} | sed -e 's/,/ /'` ${hardware}";;
+  *)	sim_hw_p=yes; hardware="`echo ${enableval} | sed -e 's/,/ /'`"'';;
+esac
+if test "$sim_hw_p" != yes; then
+  sim_hw_objs=
+  sim_hw_cflags="-DWITH_HW=0"
+  sim_hw=
+else
+  sim_hw_cflags="-DWITH_HW=1"
+  # remove duplicates
+  sim_hw=""
+  sim_hw_objs="\$(SIM_COMMON_HW_OBJS)"
+  for i in $hardware ; do
+    case " $sim_hw " in
+      *" $i "*) ;;
+      *) sim_hw="$sim_hw $i" ; sim_hw_objs="$sim_hw_objs dv-$i.o";;
+    esac
+  done
+fi
+if test x"$silent" != x"yes" && test "$sim_hw_p" = "yes"; then
+  echo "Setting hardware to $sim_hw_cflags, $sim_hw, $sim_hw_objs"
+fi
+else
+
+if test "$sim_hw_p" != yes; then
+  sim_hw_objs=
+  sim_hw_cflags="-DWITH_HW=0"
+  sim_hw=
+fi
+if test x"$silent" != x"yes"; then
+  echo "Setting hardware to $sim_hw_cflags, $sim_hw, $sim_hw_objs"
+fi
+fi;
+
+
+ac_sources="$sim_link_files"
+ac_dests="$sim_link_links"
+while test -n "$ac_sources"; do
+  set $ac_dests; ac_dest=$1; shift; ac_dests=$*
+  set $ac_sources; ac_source=$1; shift; ac_sources=$*
+  ac_config_links_1="$ac_config_links_1 $ac_dest:$ac_source"
+done
+          ac_config_links="$ac_config_links $ac_config_links_1"
+
+cgen_breaks=""
+if grep CGEN_MAINT $srcdir/Makefile.in >/dev/null; then
+cgen_breaks="break cgen_rtx_error";
+fi
+
+          ac_config_files="$ac_config_files Makefile.sim:Makefile.in"
+
+          ac_config_files="$ac_config_files Make-common.sim:../common/Make-common.in"
+
+          ac_config_files="$ac_config_files .gdbinit:../common/gdbinit.in"
+
+          ac_config_commands="$ac_config_commands Makefile"
+
+          ac_config_commands="$ac_config_commands stamp-h"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+		   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration links:
+$config_links
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+INSTALL="$INSTALL"
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile.sim" ) CONFIG_FILES="$CONFIG_FILES Makefile.sim:Makefile.in" ;;
+  "Make-common.sim" ) CONFIG_FILES="$CONFIG_FILES Make-common.sim:../common/Make-common.in" ;;
+  ".gdbinit" ) CONFIG_FILES="$CONFIG_FILES .gdbinit:../common/gdbinit.in" ;;
+  "$ac_config_links_1" ) CONFIG_LINKS="$CONFIG_LINKS $ac_config_links_1" ;;
+  "Makefile" ) CONFIG_COMMANDS="$CONFIG_COMMANDS Makefile" ;;
+  "stamp-h" ) CONFIG_COMMANDS="$CONFIG_COMMANDS stamp-h" ;;
+  "config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS config.h:config.in" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_LINKS+set}" = set || CONFIG_LINKS=$config_links
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@sim_environment@,$sim_environment,;t t
+s,@sim_alignment@,$sim_alignment,;t t
+s,@sim_assert@,$sim_assert,;t t
+s,@sim_bitsize@,$sim_bitsize,;t t
+s,@sim_endian@,$sim_endian,;t t
+s,@sim_hostendian@,$sim_hostendian,;t t
+s,@sim_float@,$sim_float,;t t
+s,@sim_scache@,$sim_scache,;t t
+s,@sim_default_model@,$sim_default_model,;t t
+s,@sim_hw_cflags@,$sim_hw_cflags,;t t
+s,@sim_hw_objs@,$sim_hw_objs,;t t
+s,@sim_hw@,$sim_hw,;t t
+s,@sim_inline@,$sim_inline,;t t
+s,@sim_packages@,$sim_packages,;t t
+s,@sim_regparm@,$sim_regparm,;t t
+s,@sim_reserved_bits@,$sim_reserved_bits,;t t
+s,@sim_smp@,$sim_smp,;t t
+s,@sim_stdcall@,$sim_stdcall,;t t
+s,@sim_xor_endian@,$sim_xor_endian,;t t
+s,@WARN_CFLAGS@,$WARN_CFLAGS,;t t
+s,@WERROR_CFLAGS@,$WERROR_CFLAGS,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@CC@,$CC,;t t
+s,@CFLAGS@,$CFLAGS,;t t
+s,@LDFLAGS@,$LDFLAGS,;t t
+s,@CPPFLAGS@,$CPPFLAGS,;t t
+s,@ac_ct_CC@,$ac_ct_CC,;t t
+s,@EXEEXT@,$EXEEXT,;t t
+s,@OBJEXT@,$OBJEXT,;t t
+s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+s,@CC_FOR_BUILD@,$CC_FOR_BUILD,;t t
+s,@HDEFINES@,$HDEFINES,;t t
+s,@AR@,$AR,;t t
+s,@RANLIB@,$RANLIB,;t t
+s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+s,@USE_NLS@,$USE_NLS,;t t
+s,@LIBINTL@,$LIBINTL,;t t
+s,@LIBINTL_DEP@,$LIBINTL_DEP,;t t
+s,@INCINTL@,$INCINTL,;t t
+s,@XGETTEXT@,$XGETTEXT,;t t
+s,@GMSGFMT@,$GMSGFMT,;t t
+s,@POSUB@,$POSUB,;t t
+s,@CATALOGS@,$CATALOGS,;t t
+s,@DATADIRNAME@,$DATADIRNAME,;t t
+s,@INSTOBJEXT@,$INSTOBJEXT,;t t
+s,@GENCAT@,$GENCAT,;t t
+s,@CATOBJEXT@,$CATOBJEXT,;t t
+s,@CPP@,$CPP,;t t
+s,@EGREP@,$EGREP,;t t
+s,@MAINT@,$MAINT,;t t
+s,@sim_bswap@,$sim_bswap,;t t
+s,@sim_cflags@,$sim_cflags,;t t
+s,@sim_debug@,$sim_debug,;t t
+s,@sim_stdio@,$sim_stdio,;t t
+s,@sim_trace@,$sim_trace,;t t
+s,@sim_profile@,$sim_profile,;t t
+s,@PKGVERSION@,$PKGVERSION,;t t
+s,@REPORT_BUGS_TO@,$REPORT_BUGS_TO,;t t
+s,@REPORT_BUGS_TEXI@,$REPORT_BUGS_TEXI,;t t
+s,@CGEN_MAINT@,$CGEN_MAINT,;t t
+s,@cgendir@,$cgendir,;t t
+s,@cgen@,$cgen,;t t
+s,@cgen_breaks@,$cgen_breaks,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_HEADER section.
+#
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
+ac_dB='[	 ].*$,\1#\2'
+ac_dC=' '
+ac_dD=',;t'
+# ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
+ac_uB='$,\1#\2define\3'
+ac_uC=' '
+ac_uD=',;t'
+
+for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  test x"$ac_file" != x- && { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  # Remove the trailing spaces.
+  sed 's/[	 ]*$//' $ac_file_inputs >$tmp/in
+
+_ACEOF
+
+# Transform confdefs.h into two sed scripts, `conftest.defines' and
+# `conftest.undefs', that substitutes the proper values into
+# config.h.in to produce config.h.  The first handles `#define'
+# templates, and the second `#undef' templates.
+# And first: Protect against being on the right side of a sed subst in
+# config.status.  Protect against being in an unquoted here document
+# in config.status.
+rm -f conftest.defines conftest.undefs
+# Using a here document instead of a string reduces the quoting nightmare.
+# Putting comments in sed scripts is not portable.
+#
+# `end' is used to avoid that the second main sed command (meant for
+# 0-ary CPP macros) applies to n-ary macro definitions.
+# See the Autoconf documentation for `clear'.
+cat >confdef2sed.sed <<\_ACEOF
+s/[\\&,]/\\&/g
+s,[\\$`],\\&,g
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*\)\(([^)]*)\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+t end
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+: end
+_ACEOF
+# If some macros were called several times there might be several times
+# the same #defines, which is useless.  Nevertheless, we may not want to
+# sort them, since we want the *last* AC-DEFINE to be honored.
+uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
+sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
+rm -f confdef2sed.sed
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >>conftest.undefs <<\_ACEOF
+s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+_ACEOF
+
+# Break up conftest.defines because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
+echo '  if grep "^[	 ]*#[	 ]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
+echo '  :' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.defines >/dev/null
+do
+  # Write a limited-size here document to $tmp/defines.sed.
+  echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#define' lines.
+  echo '/^[	 ]*#[	 ]*define/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/defines.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
+  rm -f conftest.defines
+  mv conftest.tail conftest.defines
+done
+rm -f conftest.defines
+echo '  fi # grep' >>$CONFIG_STATUS
+echo >>$CONFIG_STATUS
+
+# Break up conftest.undefs because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.undefs >/dev/null
+do
+  # Write a limited-size here document to $tmp/undefs.sed.
+  echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#undef'
+  echo '/^[	 ]*#[	 ]*undef/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
+  rm -f conftest.undefs
+  mv conftest.tail conftest.undefs
+done
+rm -f conftest.undefs
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    echo "/* Generated by configure.  */" >$tmp/config.h
+  else
+    echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
+  fi
+  cat $tmp/in >>$tmp/config.h
+  rm -f $tmp/in
+  if test x"$ac_file" != x-; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+      rm -f $ac_file
+      mv $tmp/config.h $ac_file
+    fi
+  else
+    cat $tmp/config.h
+    rm -f $tmp/config.h
+  fi
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_LINKS section.
+#
+
+for ac_file in : $CONFIG_LINKS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+
+  { echo "$as_me:$LINENO: linking $srcdir/$ac_source to $ac_dest" >&5
+echo "$as_me: linking $srcdir/$ac_source to $ac_dest" >&6;}
+
+  if test ! -r $srcdir/$ac_source; then
+    { { echo "$as_me:$LINENO: error: $srcdir/$ac_source: file not found" >&5
+echo "$as_me: error: $srcdir/$ac_source: file not found" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  rm -f $ac_dest
+
+  # Make relative symlinks.
+  ac_dest_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dest_dir"
+  else
+    as_dir="$ac_dest_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dest_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dest_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dest_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dest_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dest_dir";;
+*)
+  case "$ac_dest_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dest_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dest_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $srcdir in
+  [\\/$]* | ?:[\\/]* ) ac_rel_source=$srcdir/$ac_source ;;
+      *) ac_rel_source=$ac_top_builddir$srcdir/$ac_source ;;
+  esac
+
+  # Try a symlink, then a hard link, then a copy.
+  ln -s $ac_rel_source $ac_dest 2>/dev/null ||
+    ln $srcdir/$ac_source $ac_dest 2>/dev/null ||
+    cp -p $srcdir/$ac_source $ac_dest ||
+    { { echo "$as_me:$LINENO: error: cannot link or copy $srcdir/$ac_source to $ac_dest" >&5
+echo "$as_me: error: cannot link or copy $srcdir/$ac_source to $ac_dest" >&2;}
+   { (exit 1); exit 1; }; }
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_COMMANDS section.
+#
+for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+  ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
+echo "$as_me: executing $ac_dest commands" >&6;}
+  case $ac_dest in
+    Makefile ) echo "Merging Makefile.sim+Make-common.sim into Makefile ..."
+ rm -f Makesim1.tmp Makesim2.tmp Makefile
+ sed -n -e '/^## COMMON_PRE_/,/^## End COMMON_PRE_/ p' <Make-common.sim >Makesim1.tmp
+ sed -n -e '/^## COMMON_POST_/,/^## End COMMON_POST_/ p' <Make-common.sim >Makesim2.tmp
+ sed -e '/^## COMMON_PRE_/ r Makesim1.tmp' \
+	-e '/^## COMMON_POST_/ r Makesim2.tmp' \
+	<Makefile.sim >Makefile
+ rm -f Makefile.sim Make-common.sim Makesim1.tmp Makesim2.tmp
+ ;;
+    stamp-h ) echo > stamp-h ;;
+  esac
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
+
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/configure.ac gdb-6.8.50.20090329/sim/lm32/configure.ac
--- gdb-6.8.50.20090329.orig/sim/lm32/configure.ac	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/configure.ac	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,21 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_PREREQ(2.59)dnl
+AC_INIT(Makefile.in)
+AC_CONFIG_HEADER(config.h:config.in)
+
+sinclude(../common/aclocal.m4)
+
+# Bugs in autoconf 2.59 break the call to SIM_AC_COMMON, hack around
+# it by inlining the macro's contents.
+sinclude(../common/common.m4)
+
+SIM_AC_OPTION_ENDIAN(BIG_ENDIAN)
+SIM_AC_OPTION_ALIGNMENT(STRICT_ALIGNMENT,STRICT_ALIGNMENT)
+SIM_AC_OPTION_HOSTENDIAN
+SIM_AC_OPTION_SCACHE(16384)
+SIM_AC_OPTION_DEFAULT_MODEL(lm32)
+SIM_AC_OPTION_ENVIRONMENT
+SIM_AC_OPTION_CGEN_MAINT
+SIM_AC_OPTION_HARDWARE(yes,,lm32cpu lm32timer lm32uart)
+
+SIM_AC_OUTPUT
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/cpuall.h gdb-6.8.50.20090329/sim/lm32/cpuall.h
--- gdb-6.8.50.20090329.orig/sim/lm32/cpuall.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/cpuall.h	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,66 @@
+/* Simulator CPU header for lm32.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef LM32_CPUALL_H
+#define LM32_CPUALL_H
+
+/* Include files for each cpu family.  */
+
+#ifdef WANT_CPU_LM32BF
+#include "eng.h"
+#include "cgen-engine.h"
+#include "cpu.h"
+#include "decode.h"
+#endif
+
+extern const MACH lm32_mach;
+
+#ifndef WANT_CPU
+/* The ARGBUF struct.  */
+struct argbuf {
+  /* These are the baseclass definitions.  */
+  IADDR addr;
+  const IDESC *idesc;
+  char trace_p;
+  char profile_p;
+  /* ??? Temporary hack for skip insns.  */
+  char skip_count;
+  char unused;
+  /* cpu specific data follows */
+};
+#endif
+
+#ifndef WANT_CPU
+/* A cached insn.
+
+   ??? SCACHE used to contain more than just argbuf.  We could delete the
+   type entirely and always just use ARGBUF, but for future concerns and as
+   a level of abstraction it is left in.  */
+
+struct scache {
+  struct argbuf argbuf;
+};
+#endif
+
+#endif /* LM32_CPUALL_H */
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/cpu.c gdb-6.8.50.20090329/sim/lm32/cpu.c
--- gdb-6.8.50.20090329.orig/sim/lm32/cpu.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/cpu.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,85 @@
+/* Misc. support for CPU family lm32bf.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#define WANT_CPU lm32bf
+#define WANT_CPU_LM32BF
+
+#include "sim-main.h"
+#include "cgen-ops.h"
+
+/* Get the value of h-pc.  */
+
+USI
+lm32bf_h_pc_get (SIM_CPU *current_cpu)
+{
+  return CPU (h_pc);
+}
+
+/* Set a value for h-pc.  */
+
+void
+lm32bf_h_pc_set (SIM_CPU *current_cpu, USI newval)
+{
+  CPU (h_pc) = newval;
+}
+
+/* Get the value of h-gr.  */
+
+SI
+lm32bf_h_gr_get (SIM_CPU *current_cpu, UINT regno)
+{
+  return CPU (h_gr[regno]);
+}
+
+/* Set a value for h-gr.  */
+
+void
+lm32bf_h_gr_set (SIM_CPU *current_cpu, UINT regno, SI newval)
+{
+  CPU (h_gr[regno]) = newval;
+}
+
+/* Get the value of h-csr.  */
+
+SI
+lm32bf_h_csr_get (SIM_CPU *current_cpu, UINT regno)
+{
+  return CPU (h_csr[regno]);
+}
+
+/* Set a value for h-csr.  */
+
+void
+lm32bf_h_csr_set (SIM_CPU *current_cpu, UINT regno, SI newval)
+{
+  CPU (h_csr[regno]) = newval;
+}
+
+/* Record trace results for INSN.  */
+
+void
+lm32bf_record_trace_results (SIM_CPU *current_cpu, CGEN_INSN *insn,
+			    int *indices, TRACE_RECORD *tr)
+{
+}
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/cpu.h gdb-6.8.50.20090329/sim/lm32/cpu.h
--- gdb-6.8.50.20090329.orig/sim/lm32/cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/cpu.h	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,349 @@
+/* CPU family header for lm32bf.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef CPU_LM32BF_H
+#define CPU_LM32BF_H
+
+/* Maximum number of instructions that are fetched at a time.
+   This is for LIW type instructions sets (e.g. m32r).  */
+#define MAX_LIW_INSNS 1
+
+/* Maximum number of instructions that can be executed in parallel.  */
+#define MAX_PARALLEL_INSNS 1
+
+/* CPU state information.  */
+typedef struct {
+  /* Hardware elements.  */
+  struct {
+  /* Program counter */
+  USI h_pc;
+#define GET_H_PC() CPU (h_pc)
+#define SET_H_PC(x) (CPU (h_pc) = (x))
+  /* General purpose registers */
+  SI h_gr[32];
+#define GET_H_GR(a1) CPU (h_gr)[a1]
+#define SET_H_GR(a1, x) (CPU (h_gr)[a1] = (x))
+  /* Control and status registers */
+  SI h_csr[32];
+#define GET_H_CSR(a1) CPU (h_csr)[a1]
+#define SET_H_CSR(a1, x) (CPU (h_csr)[a1] = (x))
+  } hardware;
+#define CPU_CGEN_HW(cpu) (& (cpu)->cpu_data.hardware)
+} LM32BF_CPU_DATA;
+
+/* Cover fns for register access.  */
+USI lm32bf_h_pc_get (SIM_CPU *);
+void lm32bf_h_pc_set (SIM_CPU *, USI);
+SI lm32bf_h_gr_get (SIM_CPU *, UINT);
+void lm32bf_h_gr_set (SIM_CPU *, UINT, SI);
+SI lm32bf_h_csr_get (SIM_CPU *, UINT);
+void lm32bf_h_csr_set (SIM_CPU *, UINT, SI);
+
+/* These must be hand-written.  */
+extern CPUREG_FETCH_FN lm32bf_fetch_register;
+extern CPUREG_STORE_FN lm32bf_store_register;
+
+typedef struct {
+  int empty;
+} MODEL_LM32_DATA;
+
+/* Instruction argument buffer.  */
+
+union sem_fields {
+  struct { /* no operands */
+    int empty;
+  } fmt_empty;
+  struct { /*  */
+    IADDR i_call;
+  } sfmt_bi;
+  struct { /*  */
+    UINT f_csr;
+    UINT f_r1;
+  } sfmt_wcsr;
+  struct { /*  */
+    UINT f_csr;
+    UINT f_r2;
+  } sfmt_rcsr;
+  struct { /*  */
+    IADDR i_branch;
+    UINT f_r0;
+    UINT f_r1;
+  } sfmt_be;
+  struct { /*  */
+    UINT f_r0;
+    UINT f_r1;
+    UINT f_uimm;
+  } sfmt_andi;
+  struct { /*  */
+    INT f_imm;
+    UINT f_r0;
+    UINT f_r1;
+  } sfmt_addi;
+  struct { /*  */
+    UINT f_r0;
+    UINT f_r1;
+    UINT f_r2;
+    UINT f_user;
+  } sfmt_user;
+#if WITH_SCACHE_PBB
+  /* Writeback handler.  */
+  struct {
+    /* Pointer to argbuf entry for insn whose results need writing back.  */
+    const struct argbuf *abuf;
+  } write;
+  /* x-before handler */
+  struct {
+    /*const SCACHE *insns[MAX_PARALLEL_INSNS];*/
+    int first_p;
+  } before;
+  /* x-after handler */
+  struct {
+    int empty;
+  } after;
+  /* This entry is used to terminate each pbb.  */
+  struct {
+    /* Number of insns in pbb.  */
+    int insn_count;
+    /* Next pbb to execute.  */
+    SCACHE *next;
+    SCACHE *branch_target;
+  } chain;
+#endif
+};
+
+/* The ARGBUF struct.  */
+struct argbuf {
+  /* These are the baseclass definitions.  */
+  IADDR addr;
+  const IDESC *idesc;
+  char trace_p;
+  char profile_p;
+  /* ??? Temporary hack for skip insns.  */
+  char skip_count;
+  char unused;
+  /* cpu specific data follows */
+  union sem semantic;
+  int written;
+  union sem_fields fields;
+};
+
+/* A cached insn.
+
+   ??? SCACHE used to contain more than just argbuf.  We could delete the
+   type entirely and always just use ARGBUF, but for future concerns and as
+   a level of abstraction it is left in.  */
+
+struct scache {
+  struct argbuf argbuf;
+};
+
+/* Macros to simplify extraction, reading and semantic code.
+   These define and assign the local vars that contain the insn's fields.  */
+
+#define EXTRACT_IFMT_EMPTY_VARS \
+  unsigned int length;
+#define EXTRACT_IFMT_EMPTY_CODE \
+  length = 0; \
+
+#define EXTRACT_IFMT_ADD_VARS \
+  UINT f_opcode; \
+  UINT f_r0; \
+  UINT f_r1; \
+  UINT f_r2; \
+  UINT f_resv0; \
+  unsigned int length;
+#define EXTRACT_IFMT_ADD_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5); \
+  f_resv0 = EXTRACT_LSB0_UINT (insn, 32, 10, 11); \
+
+#define EXTRACT_IFMT_ADDI_VARS \
+  UINT f_opcode; \
+  UINT f_r0; \
+  UINT f_r1; \
+  INT f_imm; \
+  unsigned int length;
+#define EXTRACT_IFMT_ADDI_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16); \
+
+#define EXTRACT_IFMT_ANDI_VARS \
+  UINT f_opcode; \
+  UINT f_r0; \
+  UINT f_r1; \
+  UINT f_uimm; \
+  unsigned int length;
+#define EXTRACT_IFMT_ANDI_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_uimm = EXTRACT_LSB0_UINT (insn, 32, 15, 16); \
+
+#define EXTRACT_IFMT_ANDHII_VARS \
+  UINT f_opcode; \
+  UINT f_r0; \
+  UINT f_r1; \
+  UINT f_uimm; \
+  unsigned int length;
+#define EXTRACT_IFMT_ANDHII_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_uimm = EXTRACT_LSB0_UINT (insn, 32, 15, 16); \
+
+#define EXTRACT_IFMT_B_VARS \
+  UINT f_opcode; \
+  UINT f_r0; \
+  UINT f_r1; \
+  UINT f_r2; \
+  UINT f_resv0; \
+  unsigned int length;
+#define EXTRACT_IFMT_B_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5); \
+  f_resv0 = EXTRACT_LSB0_UINT (insn, 32, 10, 11); \
+
+#define EXTRACT_IFMT_BI_VARS \
+  UINT f_opcode; \
+  SI f_call; \
+  unsigned int length;
+#define EXTRACT_IFMT_BI_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_call = ((pc) + (((int) (((EXTRACT_LSB0_INT (insn, 32, 25, 26)) << (6))) >> (4)))); \
+
+#define EXTRACT_IFMT_BE_VARS \
+  UINT f_opcode; \
+  UINT f_r0; \
+  UINT f_r1; \
+  SI f_branch; \
+  unsigned int length;
+#define EXTRACT_IFMT_BE_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_branch = ((pc) + (((int) (((EXTRACT_LSB0_INT (insn, 32, 15, 16)) << (16))) >> (14)))); \
+
+#define EXTRACT_IFMT_ORI_VARS \
+  UINT f_opcode; \
+  UINT f_r0; \
+  UINT f_r1; \
+  UINT f_uimm; \
+  unsigned int length;
+#define EXTRACT_IFMT_ORI_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_uimm = EXTRACT_LSB0_UINT (insn, 32, 15, 16); \
+
+#define EXTRACT_IFMT_RCSR_VARS \
+  UINT f_opcode; \
+  UINT f_csr; \
+  UINT f_r1; \
+  UINT f_r2; \
+  UINT f_resv0; \
+  unsigned int length;
+#define EXTRACT_IFMT_RCSR_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_csr = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5); \
+  f_resv0 = EXTRACT_LSB0_UINT (insn, 32, 10, 11); \
+
+#define EXTRACT_IFMT_SEXTB_VARS \
+  UINT f_opcode; \
+  UINT f_r0; \
+  UINT f_r1; \
+  UINT f_r2; \
+  UINT f_resv0; \
+  unsigned int length;
+#define EXTRACT_IFMT_SEXTB_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5); \
+  f_resv0 = EXTRACT_LSB0_UINT (insn, 32, 10, 11); \
+
+#define EXTRACT_IFMT_USER_VARS \
+  UINT f_opcode; \
+  UINT f_r0; \
+  UINT f_r1; \
+  UINT f_r2; \
+  UINT f_user; \
+  unsigned int length;
+#define EXTRACT_IFMT_USER_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5); \
+  f_user = EXTRACT_LSB0_UINT (insn, 32, 10, 11); \
+
+#define EXTRACT_IFMT_WCSR_VARS \
+  UINT f_opcode; \
+  UINT f_csr; \
+  UINT f_r1; \
+  UINT f_r2; \
+  UINT f_resv0; \
+  unsigned int length;
+#define EXTRACT_IFMT_WCSR_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_csr = EXTRACT_LSB0_UINT (insn, 32, 25, 5); \
+  f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5); \
+  f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5); \
+  f_resv0 = EXTRACT_LSB0_UINT (insn, 32, 10, 11); \
+
+#define EXTRACT_IFMT_BREAK_VARS \
+  UINT f_opcode; \
+  UINT f_exception; \
+  unsigned int length;
+#define EXTRACT_IFMT_BREAK_CODE \
+  length = 4; \
+  f_opcode = EXTRACT_LSB0_UINT (insn, 32, 31, 6); \
+  f_exception = EXTRACT_LSB0_UINT (insn, 32, 25, 26); \
+
+/* Collection of various things for the trace handler to use.  */
+
+typedef struct trace_record {
+  IADDR pc;
+  /* FIXME:wip */
+} TRACE_RECORD;
+
+#endif /* CPU_LM32BF_H */
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/decode.c gdb-6.8.50.20090329/sim/lm32/decode.c
--- gdb-6.8.50.20090329.orig/sim/lm32/decode.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/decode.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,955 @@
+/* Simulator instruction decoder for lm32bf.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#define WANT_CPU lm32bf
+#define WANT_CPU_LM32BF
+
+#include "sim-main.h"
+#include "sim-assert.h"
+
+/* The instruction descriptor array.
+   This is computed at runtime.  Space for it is not malloc'd to save a
+   teensy bit of cpu in the decoder.  Moving it to malloc space is trivial
+   but won't be done until necessary (we don't currently support the runtime
+   addition of instructions nor an SMP machine with different cpus).  */
+static IDESC lm32bf_insn_data[LM32BF_INSN__MAX];
+
+/* Commas between elements are contained in the macros.
+   Some of these are conditionally compiled out.  */
+
+static const struct insn_sem lm32bf_insn_sem[] =
+{
+  { VIRTUAL_INSN_X_INVALID, LM32BF_INSN_X_INVALID, LM32BF_SFMT_EMPTY },
+  { VIRTUAL_INSN_X_AFTER, LM32BF_INSN_X_AFTER, LM32BF_SFMT_EMPTY },
+  { VIRTUAL_INSN_X_BEFORE, LM32BF_INSN_X_BEFORE, LM32BF_SFMT_EMPTY },
+  { VIRTUAL_INSN_X_CTI_CHAIN, LM32BF_INSN_X_CTI_CHAIN, LM32BF_SFMT_EMPTY },
+  { VIRTUAL_INSN_X_CHAIN, LM32BF_INSN_X_CHAIN, LM32BF_SFMT_EMPTY },
+  { VIRTUAL_INSN_X_BEGIN, LM32BF_INSN_X_BEGIN, LM32BF_SFMT_EMPTY },
+  { LM32_INSN_ADD, LM32BF_INSN_ADD, LM32BF_SFMT_ADD },
+  { LM32_INSN_ADDI, LM32BF_INSN_ADDI, LM32BF_SFMT_ADDI },
+  { LM32_INSN_AND, LM32BF_INSN_AND, LM32BF_SFMT_ADD },
+  { LM32_INSN_ANDI, LM32BF_INSN_ANDI, LM32BF_SFMT_ANDI },
+  { LM32_INSN_ANDHII, LM32BF_INSN_ANDHII, LM32BF_SFMT_ANDHII },
+  { LM32_INSN_B, LM32BF_INSN_B, LM32BF_SFMT_B },
+  { LM32_INSN_BI, LM32BF_INSN_BI, LM32BF_SFMT_BI },
+  { LM32_INSN_BE, LM32BF_INSN_BE, LM32BF_SFMT_BE },
+  { LM32_INSN_BG, LM32BF_INSN_BG, LM32BF_SFMT_BE },
+  { LM32_INSN_BGE, LM32BF_INSN_BGE, LM32BF_SFMT_BE },
+  { LM32_INSN_BGEU, LM32BF_INSN_BGEU, LM32BF_SFMT_BE },
+  { LM32_INSN_BGU, LM32BF_INSN_BGU, LM32BF_SFMT_BE },
+  { LM32_INSN_BNE, LM32BF_INSN_BNE, LM32BF_SFMT_BE },
+  { LM32_INSN_CALL, LM32BF_INSN_CALL, LM32BF_SFMT_CALL },
+  { LM32_INSN_CALLI, LM32BF_INSN_CALLI, LM32BF_SFMT_CALLI },
+  { LM32_INSN_CMPE, LM32BF_INSN_CMPE, LM32BF_SFMT_ADD },
+  { LM32_INSN_CMPEI, LM32BF_INSN_CMPEI, LM32BF_SFMT_ADDI },
+  { LM32_INSN_CMPG, LM32BF_INSN_CMPG, LM32BF_SFMT_ADD },
+  { LM32_INSN_CMPGI, LM32BF_INSN_CMPGI, LM32BF_SFMT_ADDI },
+  { LM32_INSN_CMPGE, LM32BF_INSN_CMPGE, LM32BF_SFMT_ADD },
+  { LM32_INSN_CMPGEI, LM32BF_INSN_CMPGEI, LM32BF_SFMT_ADDI },
+  { LM32_INSN_CMPGEU, LM32BF_INSN_CMPGEU, LM32BF_SFMT_ADD },
+  { LM32_INSN_CMPGEUI, LM32BF_INSN_CMPGEUI, LM32BF_SFMT_ANDI },
+  { LM32_INSN_CMPGU, LM32BF_INSN_CMPGU, LM32BF_SFMT_ADD },
+  { LM32_INSN_CMPGUI, LM32BF_INSN_CMPGUI, LM32BF_SFMT_ANDI },
+  { LM32_INSN_CMPNE, LM32BF_INSN_CMPNE, LM32BF_SFMT_ADD },
+  { LM32_INSN_CMPNEI, LM32BF_INSN_CMPNEI, LM32BF_SFMT_ADDI },
+  { LM32_INSN_DIVU, LM32BF_INSN_DIVU, LM32BF_SFMT_DIVU },
+  { LM32_INSN_LB, LM32BF_INSN_LB, LM32BF_SFMT_LB },
+  { LM32_INSN_LBU, LM32BF_INSN_LBU, LM32BF_SFMT_LB },
+  { LM32_INSN_LH, LM32BF_INSN_LH, LM32BF_SFMT_LH },
+  { LM32_INSN_LHU, LM32BF_INSN_LHU, LM32BF_SFMT_LH },
+  { LM32_INSN_LW, LM32BF_INSN_LW, LM32BF_SFMT_LW },
+  { LM32_INSN_MODU, LM32BF_INSN_MODU, LM32BF_SFMT_DIVU },
+  { LM32_INSN_MUL, LM32BF_INSN_MUL, LM32BF_SFMT_ADD },
+  { LM32_INSN_MULI, LM32BF_INSN_MULI, LM32BF_SFMT_ADDI },
+  { LM32_INSN_NOR, LM32BF_INSN_NOR, LM32BF_SFMT_ADD },
+  { LM32_INSN_NORI, LM32BF_INSN_NORI, LM32BF_SFMT_ANDI },
+  { LM32_INSN_OR, LM32BF_INSN_OR, LM32BF_SFMT_ADD },
+  { LM32_INSN_ORI, LM32BF_INSN_ORI, LM32BF_SFMT_ORI },
+  { LM32_INSN_ORHII, LM32BF_INSN_ORHII, LM32BF_SFMT_ANDHII },
+  { LM32_INSN_RCSR, LM32BF_INSN_RCSR, LM32BF_SFMT_RCSR },
+  { LM32_INSN_SB, LM32BF_INSN_SB, LM32BF_SFMT_SB },
+  { LM32_INSN_SEXTB, LM32BF_INSN_SEXTB, LM32BF_SFMT_SEXTB },
+  { LM32_INSN_SEXTH, LM32BF_INSN_SEXTH, LM32BF_SFMT_SEXTB },
+  { LM32_INSN_SH, LM32BF_INSN_SH, LM32BF_SFMT_SH },
+  { LM32_INSN_SL, LM32BF_INSN_SL, LM32BF_SFMT_SL },
+  { LM32_INSN_SLI, LM32BF_INSN_SLI, LM32BF_SFMT_ADDI },
+  { LM32_INSN_SR, LM32BF_INSN_SR, LM32BF_SFMT_SL },
+  { LM32_INSN_SRI, LM32BF_INSN_SRI, LM32BF_SFMT_ADDI },
+  { LM32_INSN_SRU, LM32BF_INSN_SRU, LM32BF_SFMT_SL },
+  { LM32_INSN_SRUI, LM32BF_INSN_SRUI, LM32BF_SFMT_ADDI },
+  { LM32_INSN_SUB, LM32BF_INSN_SUB, LM32BF_SFMT_ADD },
+  { LM32_INSN_SW, LM32BF_INSN_SW, LM32BF_SFMT_SW },
+  { LM32_INSN_USER, LM32BF_INSN_USER, LM32BF_SFMT_USER },
+  { LM32_INSN_WCSR, LM32BF_INSN_WCSR, LM32BF_SFMT_WCSR },
+  { LM32_INSN_XOR, LM32BF_INSN_XOR, LM32BF_SFMT_ADD },
+  { LM32_INSN_XORI, LM32BF_INSN_XORI, LM32BF_SFMT_ANDI },
+  { LM32_INSN_XNOR, LM32BF_INSN_XNOR, LM32BF_SFMT_ADD },
+  { LM32_INSN_XNORI, LM32BF_INSN_XNORI, LM32BF_SFMT_ANDI },
+  { LM32_INSN_BREAK, LM32BF_INSN_BREAK, LM32BF_SFMT_BREAK },
+  { LM32_INSN_SCALL, LM32BF_INSN_SCALL, LM32BF_SFMT_BREAK },
+};
+
+static const struct insn_sem lm32bf_insn_sem_invalid = {
+  VIRTUAL_INSN_X_INVALID, LM32BF_INSN_X_INVALID, LM32BF_SFMT_EMPTY
+};
+
+/* Initialize an IDESC from the compile-time computable parts.  */
+
+static INLINE void
+init_idesc (SIM_CPU *cpu, IDESC *id, const struct insn_sem *t)
+{
+  const CGEN_INSN *insn_table = CGEN_CPU_INSN_TABLE (CPU_CPU_DESC (cpu))->init_entries;
+
+  id->num = t->index;
+  id->sfmt = t->sfmt;
+  if ((int) t->type <= 0)
+    id->idata = & cgen_virtual_insn_table[- (int) t->type];
+  else
+    id->idata = & insn_table[t->type];
+  id->attrs = CGEN_INSN_ATTRS (id->idata);
+  /* Oh my god, a magic number.  */
+  id->length = CGEN_INSN_BITSIZE (id->idata) / 8;
+
+#if WITH_PROFILE_MODEL_P
+  id->timing = & MODEL_TIMING (CPU_MODEL (cpu)) [t->index];
+  {
+    SIM_DESC sd = CPU_STATE (cpu);
+    SIM_ASSERT (t->index == id->timing->num);
+  }
+#endif
+
+  /* Semantic pointers are initialized elsewhere.  */
+}
+
+/* Initialize the instruction descriptor table.  */
+
+void
+lm32bf_init_idesc_table (SIM_CPU *cpu)
+{
+  IDESC *id,*tabend;
+  const struct insn_sem *t,*tend;
+  int tabsize = LM32BF_INSN__MAX;
+  IDESC *table = lm32bf_insn_data;
+
+  memset (table, 0, tabsize * sizeof (IDESC));
+
+  /* First set all entries to the `invalid insn'.  */
+  t = & lm32bf_insn_sem_invalid;
+  for (id = table, tabend = table + tabsize; id < tabend; ++id)
+    init_idesc (cpu, id, t);
+
+  /* Now fill in the values for the chosen cpu.  */
+  for (t = lm32bf_insn_sem, tend = t + sizeof (lm32bf_insn_sem) / sizeof (*t);
+       t != tend; ++t)
+    {
+      init_idesc (cpu, & table[t->index], t);
+    }
+
+  /* Link the IDESC table into the cpu.  */
+  CPU_IDESC (cpu) = table;
+}
+
+/* Given an instruction, return a pointer to its IDESC entry.  */
+
+const IDESC *
+lm32bf_decode (SIM_CPU *current_cpu, IADDR pc,
+              CGEN_INSN_INT base_insn, CGEN_INSN_INT entire_insn,
+              ARGBUF *abuf)
+{
+  /* Result of decoder.  */
+  LM32BF_INSN_TYPE itype;
+
+  {
+    CGEN_INSN_INT insn = base_insn;
+
+    {
+      unsigned int val = (((insn >> 26) & (63 << 0)));
+      switch (val)
+      {
+      case 0 :
+        if ((entire_insn & 0xfc000000) == 0x0)
+          { itype = LM32BF_INSN_SRUI; goto extract_sfmt_addi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 1 :
+        if ((entire_insn & 0xfc000000) == 0x4000000)
+          { itype = LM32BF_INSN_NORI; goto extract_sfmt_andi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 2 :
+        if ((entire_insn & 0xfc000000) == 0x8000000)
+          { itype = LM32BF_INSN_MULI; goto extract_sfmt_addi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 3 :
+        if ((entire_insn & 0xfc000000) == 0xc000000)
+          { itype = LM32BF_INSN_SH; goto extract_sfmt_sh; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 4 :
+        if ((entire_insn & 0xfc000000) == 0x10000000)
+          { itype = LM32BF_INSN_LB; goto extract_sfmt_lb; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 5 :
+        if ((entire_insn & 0xfc000000) == 0x14000000)
+          { itype = LM32BF_INSN_SRI; goto extract_sfmt_addi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 6 :
+        if ((entire_insn & 0xfc000000) == 0x18000000)
+          { itype = LM32BF_INSN_XORI; goto extract_sfmt_andi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 7 :
+        if ((entire_insn & 0xfc000000) == 0x1c000000)
+          { itype = LM32BF_INSN_LH; goto extract_sfmt_lh; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 8 :
+        if ((entire_insn & 0xfc000000) == 0x20000000)
+          { itype = LM32BF_INSN_ANDI; goto extract_sfmt_andi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 9 :
+        if ((entire_insn & 0xfc000000) == 0x24000000)
+          { itype = LM32BF_INSN_XNORI; goto extract_sfmt_andi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 10 :
+        if ((entire_insn & 0xfc000000) == 0x28000000)
+          { itype = LM32BF_INSN_LW; goto extract_sfmt_lw; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 11 :
+        if ((entire_insn & 0xfc000000) == 0x2c000000)
+          { itype = LM32BF_INSN_LHU; goto extract_sfmt_lh; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 12 :
+        if ((entire_insn & 0xfc000000) == 0x30000000)
+          { itype = LM32BF_INSN_SB; goto extract_sfmt_sb; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 13 :
+        if ((entire_insn & 0xfc000000) == 0x34000000)
+          { itype = LM32BF_INSN_ADDI; goto extract_sfmt_addi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 14 :
+        if ((entire_insn & 0xfc000000) == 0x38000000)
+          { itype = LM32BF_INSN_ORI; goto extract_sfmt_ori; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 15 :
+        if ((entire_insn & 0xfc000000) == 0x3c000000)
+          { itype = LM32BF_INSN_SLI; goto extract_sfmt_addi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 16 :
+        if ((entire_insn & 0xfc000000) == 0x40000000)
+          { itype = LM32BF_INSN_LBU; goto extract_sfmt_lb; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 17 :
+        if ((entire_insn & 0xfc000000) == 0x44000000)
+          { itype = LM32BF_INSN_BE; goto extract_sfmt_be; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 18 :
+        if ((entire_insn & 0xfc000000) == 0x48000000)
+          { itype = LM32BF_INSN_BG; goto extract_sfmt_be; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 19 :
+        if ((entire_insn & 0xfc000000) == 0x4c000000)
+          { itype = LM32BF_INSN_BGE; goto extract_sfmt_be; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 20 :
+        if ((entire_insn & 0xfc000000) == 0x50000000)
+          { itype = LM32BF_INSN_BGEU; goto extract_sfmt_be; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 21 :
+        if ((entire_insn & 0xfc000000) == 0x54000000)
+          { itype = LM32BF_INSN_BGU; goto extract_sfmt_be; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 22 :
+        if ((entire_insn & 0xfc000000) == 0x58000000)
+          { itype = LM32BF_INSN_SW; goto extract_sfmt_sw; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 23 :
+        if ((entire_insn & 0xfc000000) == 0x5c000000)
+          { itype = LM32BF_INSN_BNE; goto extract_sfmt_be; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 24 :
+        if ((entire_insn & 0xfc000000) == 0x60000000)
+          { itype = LM32BF_INSN_ANDHII; goto extract_sfmt_andhii; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 25 :
+        if ((entire_insn & 0xfc000000) == 0x64000000)
+          { itype = LM32BF_INSN_CMPEI; goto extract_sfmt_addi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 26 :
+        if ((entire_insn & 0xfc000000) == 0x68000000)
+          { itype = LM32BF_INSN_CMPGI; goto extract_sfmt_addi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 27 :
+        if ((entire_insn & 0xfc000000) == 0x6c000000)
+          { itype = LM32BF_INSN_CMPGEI; goto extract_sfmt_addi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 28 :
+        if ((entire_insn & 0xfc000000) == 0x70000000)
+          { itype = LM32BF_INSN_CMPGEUI; goto extract_sfmt_andi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 29 :
+        if ((entire_insn & 0xfc000000) == 0x74000000)
+          { itype = LM32BF_INSN_CMPGUI; goto extract_sfmt_andi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 30 :
+        if ((entire_insn & 0xfc000000) == 0x78000000)
+          { itype = LM32BF_INSN_ORHII; goto extract_sfmt_andhii; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 31 :
+        if ((entire_insn & 0xfc000000) == 0x7c000000)
+          { itype = LM32BF_INSN_CMPNEI; goto extract_sfmt_addi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 32 :
+        if ((entire_insn & 0xfc0007ff) == 0x80000000)
+          { itype = LM32BF_INSN_SRU; goto extract_sfmt_sl; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 33 :
+        if ((entire_insn & 0xfc0007ff) == 0x84000000)
+          { itype = LM32BF_INSN_NOR; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 34 :
+        if ((entire_insn & 0xfc0007ff) == 0x88000000)
+          { itype = LM32BF_INSN_MUL; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 35 :
+        if ((entire_insn & 0xfc0007ff) == 0x8c000000)
+          { itype = LM32BF_INSN_DIVU; goto extract_sfmt_divu; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 36 :
+        if ((entire_insn & 0xfc1f07ff) == 0x90000000)
+          { itype = LM32BF_INSN_RCSR; goto extract_sfmt_rcsr; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 37 :
+        if ((entire_insn & 0xfc0007ff) == 0x94000000)
+          { itype = LM32BF_INSN_SR; goto extract_sfmt_sl; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 38 :
+        if ((entire_insn & 0xfc0007ff) == 0x98000000)
+          { itype = LM32BF_INSN_XOR; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 40 :
+        if ((entire_insn & 0xfc0007ff) == 0xa0000000)
+          { itype = LM32BF_INSN_AND; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 41 :
+        if ((entire_insn & 0xfc0007ff) == 0xa4000000)
+          { itype = LM32BF_INSN_XNOR; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 43 :
+        {
+          unsigned int val = (((insn >> 1) & (1 << 1)) | ((insn >> 0) & (1 << 0)));
+          switch (val)
+          {
+          case 0 :
+            if ((entire_insn & 0xffffffff) == 0xac000002)
+              { itype = LM32BF_INSN_BREAK; goto extract_sfmt_break; }
+            itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+          case 3 :
+            if ((entire_insn & 0xffffffff) == 0xac000007)
+              { itype = LM32BF_INSN_SCALL; goto extract_sfmt_break; }
+            itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+          default : itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+          }
+        }
+      case 44 :
+        if ((entire_insn & 0xfc1f07ff) == 0xb0000000)
+          { itype = LM32BF_INSN_SEXTB; goto extract_sfmt_sextb; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 45 :
+        if ((entire_insn & 0xfc0007ff) == 0xb4000000)
+          { itype = LM32BF_INSN_ADD; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 46 :
+        if ((entire_insn & 0xfc0007ff) == 0xb8000000)
+          { itype = LM32BF_INSN_OR; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 47 :
+        if ((entire_insn & 0xfc0007ff) == 0xbc000000)
+          { itype = LM32BF_INSN_SL; goto extract_sfmt_sl; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 48 :
+        if ((entire_insn & 0xfc1fffff) == 0xc0000000)
+          { itype = LM32BF_INSN_B; goto extract_sfmt_b; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 49 :
+        if ((entire_insn & 0xfc0007ff) == 0xc4000000)
+          { itype = LM32BF_INSN_MODU; goto extract_sfmt_divu; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 50 :
+        if ((entire_insn & 0xfc0007ff) == 0xc8000000)
+          { itype = LM32BF_INSN_SUB; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 51 :
+        if ((entire_insn & 0xfc000000) == 0xcc000000)
+          { itype = LM32BF_INSN_USER; goto extract_sfmt_user; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 52 :
+        if ((entire_insn & 0xfc00ffff) == 0xd0000000)
+          { itype = LM32BF_INSN_WCSR; goto extract_sfmt_wcsr; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 54 :
+        if ((entire_insn & 0xfc1fffff) == 0xd8000000)
+          { itype = LM32BF_INSN_CALL; goto extract_sfmt_call; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 55 :
+        if ((entire_insn & 0xfc1f07ff) == 0xdc000000)
+          { itype = LM32BF_INSN_SEXTH; goto extract_sfmt_sextb; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 56 :
+        if ((entire_insn & 0xfc000000) == 0xe0000000)
+          { itype = LM32BF_INSN_BI; goto extract_sfmt_bi; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 57 :
+        if ((entire_insn & 0xfc0007ff) == 0xe4000000)
+          { itype = LM32BF_INSN_CMPE; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 58 :
+        if ((entire_insn & 0xfc0007ff) == 0xe8000000)
+          { itype = LM32BF_INSN_CMPG; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 59 :
+        if ((entire_insn & 0xfc0007ff) == 0xec000000)
+          { itype = LM32BF_INSN_CMPGE; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 60 :
+        if ((entire_insn & 0xfc0007ff) == 0xf0000000)
+          { itype = LM32BF_INSN_CMPGEU; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 61 :
+        if ((entire_insn & 0xfc0007ff) == 0xf4000000)
+          { itype = LM32BF_INSN_CMPGU; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 62 :
+        if ((entire_insn & 0xfc000000) == 0xf8000000)
+          { itype = LM32BF_INSN_CALLI; goto extract_sfmt_calli; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      case 63 :
+        if ((entire_insn & 0xfc0007ff) == 0xfc000000)
+          { itype = LM32BF_INSN_CMPNE; goto extract_sfmt_add; }
+        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      default : itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
+      }
+    }
+  }
+
+  /* The instruction has been decoded, now extract the fields.  */
+
+ extract_sfmt_empty:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+#define FLD(f) abuf->fields.fmt_empty.f
+
+
+  /* Record the fields for the semantic handler.  */
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_empty", (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_add:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_user.f
+    UINT f_r0;
+    UINT f_r1;
+    UINT f_r2;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  FLD (f_r2) = f_r2;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_add", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_addi:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_addi.f
+    UINT f_r0;
+    UINT f_r1;
+    INT f_imm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_imm) = f_imm;
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addi", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_andi:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_andi.f
+    UINT f_r0;
+    UINT f_r1;
+    UINT f_uimm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_uimm = EXTRACT_LSB0_UINT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_r0) = f_r0;
+  FLD (f_uimm) = f_uimm;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_andi", "f_r0 0x%x", 'x', f_r0, "f_uimm 0x%x", 'x', f_uimm, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_andhii:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_andi.f
+    UINT f_r0;
+    UINT f_r1;
+    UINT f_uimm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_uimm = EXTRACT_LSB0_UINT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_uimm) = f_uimm;
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_andhii", "f_uimm 0x%x", 'x', f_uimm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_b:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_be.f
+    UINT f_r0;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_r0) = f_r0;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_b", "f_r0 0x%x", 'x', f_r0, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_bi:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_bi.f
+    SI f_call;
+
+    f_call = ((pc) + (((int) (((EXTRACT_LSB0_INT (insn, 32, 25, 26)) << (6))) >> (4))));
+
+  /* Record the fields for the semantic handler.  */
+  FLD (i_call) = f_call;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bi", "call 0x%x", 'x', f_call, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_be:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_be.f
+    UINT f_r0;
+    UINT f_r1;
+    SI f_branch;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_branch = ((pc) + (((int) (((EXTRACT_LSB0_INT (insn, 32, 15, 16)) << (16))) >> (14))));
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  FLD (i_branch) = f_branch;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_be", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "branch 0x%x", 'x', f_branch, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_call:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_be.f
+    UINT f_r0;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_r0) = f_r0;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_call", "f_r0 0x%x", 'x', f_r0, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_calli:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_bi.f
+    SI f_call;
+
+    f_call = ((pc) + (((int) (((EXTRACT_LSB0_INT (insn, 32, 25, 26)) << (6))) >> (4))));
+
+  /* Record the fields for the semantic handler.  */
+  FLD (i_call) = f_call;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_calli", "call 0x%x", 'x', f_call, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_divu:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_user.f
+    UINT f_r0;
+    UINT f_r1;
+    UINT f_r2;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  FLD (f_r2) = f_r2;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_divu", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_lb:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_addi.f
+    UINT f_r0;
+    UINT f_r1;
+    INT f_imm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_imm) = f_imm;
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_lb", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_lh:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_addi.f
+    UINT f_r0;
+    UINT f_r1;
+    INT f_imm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_imm) = f_imm;
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_lh", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_lw:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_addi.f
+    UINT f_r0;
+    UINT f_r1;
+    INT f_imm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_imm) = f_imm;
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_lw", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_ori:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_andi.f
+    UINT f_r0;
+    UINT f_r1;
+    UINT f_uimm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_uimm = EXTRACT_LSB0_UINT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_uimm) = f_uimm;
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ori", "f_uimm 0x%x", 'x', f_uimm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_rcsr:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_rcsr.f
+    UINT f_csr;
+    UINT f_r2;
+
+    f_csr = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_csr) = f_csr;
+  FLD (f_r2) = f_r2;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_rcsr", "f_csr 0x%x", 'x', f_csr, "f_r2 0x%x", 'x', f_r2, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_sb:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_addi.f
+    UINT f_r0;
+    UINT f_r1;
+    INT f_imm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_imm) = f_imm;
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sb", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_sextb:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_user.f
+    UINT f_r0;
+    UINT f_r2;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_r0) = f_r0;
+  FLD (f_r2) = f_r2;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sextb", "f_r0 0x%x", 'x', f_r0, "f_r2 0x%x", 'x', f_r2, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_sh:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_addi.f
+    UINT f_r0;
+    UINT f_r1;
+    INT f_imm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_imm) = f_imm;
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sh", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_sl:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_user.f
+    UINT f_r0;
+    UINT f_r1;
+    UINT f_r2;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  FLD (f_r2) = f_r2;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sl", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_sw:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_addi.f
+    UINT f_r0;
+    UINT f_r1;
+    INT f_imm;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_imm) = f_imm;
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sw", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_user:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_user.f
+    UINT f_r0;
+    UINT f_r1;
+    UINT f_r2;
+    UINT f_user;
+
+    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);
+    f_user = EXTRACT_LSB0_UINT (insn, 32, 10, 11);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_r0) = f_r0;
+  FLD (f_r1) = f_r1;
+  FLD (f_user) = f_user;
+  FLD (f_r2) = f_r2;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_user", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "f_user 0x%x", 'x', f_user, "f_r2 0x%x", 'x', f_r2, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_wcsr:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+    CGEN_INSN_INT insn = entire_insn;
+#define FLD(f) abuf->fields.sfmt_wcsr.f
+    UINT f_csr;
+    UINT f_r1;
+
+    f_csr = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
+    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
+
+  /* Record the fields for the semantic handler.  */
+  FLD (f_csr) = f_csr;
+  FLD (f_r1) = f_r1;
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_wcsr", "f_csr 0x%x", 'x', f_csr, "f_r1 0x%x", 'x', f_r1, (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+ extract_sfmt_break:
+  {
+    const IDESC *idesc = &lm32bf_insn_data[itype];
+#define FLD(f) abuf->fields.fmt_empty.f
+
+
+  /* Record the fields for the semantic handler.  */
+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_break", (char *) 0));
+
+#undef FLD
+    return idesc;
+  }
+
+}
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/decode.h gdb-6.8.50.20090329/sim/lm32/decode.h
--- gdb-6.8.50.20090329.orig/sim/lm32/decode.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/decode.h	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,76 @@
+/* Decode header for lm32bf.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef LM32BF_DECODE_H
+#define LM32BF_DECODE_H
+
+extern const IDESC *lm32bf_decode (SIM_CPU *, IADDR,
+                                  CGEN_INSN_INT, CGEN_INSN_INT,
+                                  ARGBUF *);
+extern void lm32bf_init_idesc_table (SIM_CPU *);
+extern void lm32bf_sem_init_idesc_table (SIM_CPU *);
+extern void lm32bf_semf_init_idesc_table (SIM_CPU *);
+
+/* Enum declaration for instructions in cpu family lm32bf.  */
+typedef enum lm32bf_insn_type {
+  LM32BF_INSN_X_INVALID, LM32BF_INSN_X_AFTER, LM32BF_INSN_X_BEFORE, LM32BF_INSN_X_CTI_CHAIN
+ , LM32BF_INSN_X_CHAIN, LM32BF_INSN_X_BEGIN, LM32BF_INSN_ADD, LM32BF_INSN_ADDI
+ , LM32BF_INSN_AND, LM32BF_INSN_ANDI, LM32BF_INSN_ANDHII, LM32BF_INSN_B
+ , LM32BF_INSN_BI, LM32BF_INSN_BE, LM32BF_INSN_BG, LM32BF_INSN_BGE
+ , LM32BF_INSN_BGEU, LM32BF_INSN_BGU, LM32BF_INSN_BNE, LM32BF_INSN_CALL
+ , LM32BF_INSN_CALLI, LM32BF_INSN_CMPE, LM32BF_INSN_CMPEI, LM32BF_INSN_CMPG
+ , LM32BF_INSN_CMPGI, LM32BF_INSN_CMPGE, LM32BF_INSN_CMPGEI, LM32BF_INSN_CMPGEU
+ , LM32BF_INSN_CMPGEUI, LM32BF_INSN_CMPGU, LM32BF_INSN_CMPGUI, LM32BF_INSN_CMPNE
+ , LM32BF_INSN_CMPNEI, LM32BF_INSN_DIVU, LM32BF_INSN_LB, LM32BF_INSN_LBU
+ , LM32BF_INSN_LH, LM32BF_INSN_LHU, LM32BF_INSN_LW, LM32BF_INSN_MODU
+ , LM32BF_INSN_MUL, LM32BF_INSN_MULI, LM32BF_INSN_NOR, LM32BF_INSN_NORI
+ , LM32BF_INSN_OR, LM32BF_INSN_ORI, LM32BF_INSN_ORHII, LM32BF_INSN_RCSR
+ , LM32BF_INSN_SB, LM32BF_INSN_SEXTB, LM32BF_INSN_SEXTH, LM32BF_INSN_SH
+ , LM32BF_INSN_SL, LM32BF_INSN_SLI, LM32BF_INSN_SR, LM32BF_INSN_SRI
+ , LM32BF_INSN_SRU, LM32BF_INSN_SRUI, LM32BF_INSN_SUB, LM32BF_INSN_SW
+ , LM32BF_INSN_USER, LM32BF_INSN_WCSR, LM32BF_INSN_XOR, LM32BF_INSN_XORI
+ , LM32BF_INSN_XNOR, LM32BF_INSN_XNORI, LM32BF_INSN_BREAK, LM32BF_INSN_SCALL
+ , LM32BF_INSN__MAX
+} LM32BF_INSN_TYPE;
+
+/* Enum declaration for semantic formats in cpu family lm32bf.  */
+typedef enum lm32bf_sfmt_type {
+  LM32BF_SFMT_EMPTY, LM32BF_SFMT_ADD, LM32BF_SFMT_ADDI, LM32BF_SFMT_ANDI
+ , LM32BF_SFMT_ANDHII, LM32BF_SFMT_B, LM32BF_SFMT_BI, LM32BF_SFMT_BE
+ , LM32BF_SFMT_CALL, LM32BF_SFMT_CALLI, LM32BF_SFMT_DIVU, LM32BF_SFMT_LB
+ , LM32BF_SFMT_LH, LM32BF_SFMT_LW, LM32BF_SFMT_ORI, LM32BF_SFMT_RCSR
+ , LM32BF_SFMT_SB, LM32BF_SFMT_SEXTB, LM32BF_SFMT_SH, LM32BF_SFMT_SL
+ , LM32BF_SFMT_SW, LM32BF_SFMT_USER, LM32BF_SFMT_WCSR, LM32BF_SFMT_BREAK
+} LM32BF_SFMT_TYPE;
+
+/* Function unit handlers (user written).  */
+
+extern int lm32bf_model_lm32_u_exec (SIM_CPU *, const IDESC *, int /*unit_num*/, int /*referenced*/);
+
+/* Profiling before/after handlers (user written) */
+
+extern void lm32bf_model_insn_before (SIM_CPU *, int /*first_p*/);
+extern void lm32bf_model_insn_after (SIM_CPU *, int /*last_p*/, int /*cycles*/);
+
+#endif /* LM32BF_DECODE_H */
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/dv-lm32cpu.c gdb-6.8.50.20090329/sim/lm32/dv-lm32cpu.c
--- gdb-6.8.50.20090329.orig/sim/lm32/dv-lm32cpu.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/dv-lm32cpu.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,239 @@
+/*  Lattice Mico32 CPU model.
+    Contributed by Jon Beniston <jon@beniston.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "hw-main.h"
+#include "sim-main.h"
+
+
+struct lm32cpu {
+  struct hw_event* event;
+};
+
+/* input port ID's */ 
+
+enum {
+  INT0_PORT, 
+  INT1_PORT, 
+  INT2_PORT, 
+  INT3_PORT,
+  INT4_PORT, 
+  INT5_PORT, 
+  INT6_PORT, 
+  INT7_PORT,
+  INT8_PORT, 
+  INT9_PORT, 
+  INT10_PORT, 
+  INT11_PORT,
+  INT12_PORT,
+  INT13_PORT,
+  INT14_PORT,
+  INT15_PORT,
+  INT16_PORT,
+  INT17_PORT,
+  INT18_PORT,
+  INT19_PORT,
+  INT20_PORT,
+  INT21_PORT,
+  INT22_PORT,
+  INT23_PORT,
+  INT24_PORT,
+  INT25_PORT,
+  INT26_PORT,
+  INT27_PORT,
+  INT28_PORT,
+  INT29_PORT,
+  INT30_PORT,
+  INT31_PORT,
+};
+
+static const struct hw_port_descriptor lm32cpu_ports[] = {
+  /* interrupt inputs */
+  { "int0", INT0_PORT, 0, input_port, },
+  { "int1", INT1_PORT, 0, input_port, },
+  { "int2", INT2_PORT, 0, input_port, },
+  { "int3", INT3_PORT, 0, input_port, },
+  { "int4", INT4_PORT, 0, input_port, },
+  { "int5", INT5_PORT, 0, input_port, },
+  { "int6", INT6_PORT, 0, input_port, },
+  { "int7", INT7_PORT, 0, input_port, },
+  { "int8", INT8_PORT, 0, input_port, },
+  { "int9", INT9_PORT, 0, input_port, },
+  { "int10", INT10_PORT, 0, input_port, },
+  { "int11", INT11_PORT, 0, input_port, },
+  { "int12", INT12_PORT, 0, input_port, },
+  { "int13", INT13_PORT, 0, input_port, },
+  { "int14", INT14_PORT, 0, input_port, },
+  { "int15", INT15_PORT, 0, input_port, },
+  { "int16", INT16_PORT, 0, input_port, },
+  { "int17", INT17_PORT, 0, input_port, },
+  { "int18", INT18_PORT, 0, input_port, },
+  { "int19", INT19_PORT, 0, input_port, },
+  { "int20", INT20_PORT, 0, input_port, },
+  { "int21", INT21_PORT, 0, input_port, },
+  { "int22", INT22_PORT, 0, input_port, },
+  { "int23", INT23_PORT, 0, input_port, },
+  { "int24", INT24_PORT, 0, input_port, },
+  { "int25", INT25_PORT, 0, input_port, },
+  { "int26", INT26_PORT, 0, input_port, },
+  { "int27", INT27_PORT, 0, input_port, },
+  { "int28", INT28_PORT, 0, input_port, },
+  { "int29", INT29_PORT, 0, input_port, },
+  { "int30", INT30_PORT, 0, input_port, },
+  { "int31", INT31_PORT, 0, input_port, },
+  { NULL, },
+};
+
+
+
+/*
+ * Finish off the partially created hw device.  Attach our local
+ * callbacks.  Wire up our port names etc 
+ */
+static hw_port_event_method lm32cpu_port_event;
+
+
+static void
+lm32cpu_finish (struct hw *me)
+{
+  struct lm32cpu *controller;
+
+  controller = HW_ZALLOC (me, struct lm32cpu);
+  set_hw_data (me, controller);
+  set_hw_ports (me, lm32cpu_ports);
+  set_hw_port_event (me, lm32cpu_port_event);
+
+  /* Initialize the pending interrupt flags */
+  controller->event = NULL;
+}
+
+
+/* An event arrives on an interrupt port */
+static unsigned int s_ui_ExtIntrs = 0;
+
+
+static void
+deliver_lm32cpu_interrupt (struct hw *me,
+			    void *data)
+{
+  static unsigned int ip, im, im_and_ip_result;
+  struct lm32cpu *controller = hw_data (me);
+  SIM_DESC sd = hw_system (me);
+  sim_cpu *cpu = STATE_CPU (sd, 0); /* NB: fix CPU 0. */
+  address_word cia = CIA_GET (cpu);
+  int interrupt = (int)data;
+
+
+  HW_TRACE ((me, "interrupt-check event"));
+
+
+  /*
+   * Determine if an external interrupt is active 
+   * and needs to cause an exception
+   */
+  im = lm32bf_h_csr_get(cpu, LM32_CSR_IM);
+  ip = lm32bf_h_csr_get(cpu, LM32_CSR_IP);
+  im_and_ip_result = im & ip;
+
+
+  if ((lm32bf_h_csr_get (cpu, LM32_CSR_IE) & 1) && (im_and_ip_result != 0)){
+    /* Save PC in exception address register */
+    lm32bf_h_gr_set (cpu, 30, lm32bf_h_pc_get (cpu));
+    /* Restart at interrupt offset in handler exception table */
+    lm32bf_h_pc_set (cpu, lm32bf_h_csr_get (cpu, LM32_CSR_EBA) + LM32_EID_INTERRUPT * 32);
+    /* Save interrupt enable and then clear */
+    lm32bf_h_csr_set (cpu, LM32_CSR_IE, 0x2);
+  }
+
+  /* reschedule soon */
+  if(controller->event != NULL)
+    hw_event_queue_deschedule(me, controller->event);
+  controller->event = NULL;
+
+
+  /* if there are external interrupts, schedule an interrupt-check again.
+   * NOTE: THIS MAKES IT VERY INEFFICIENT. INSTEAD, TRIGGER THIS
+   * CHECk_EVENT WHEN THE USER ENABLES IE OR USER MODIFIES IM REGISTERS.
+   */
+  if(s_ui_ExtIntrs != 0)
+    controller->event = hw_event_queue_schedule (me, 1, deliver_lm32cpu_interrupt, data);
+}
+
+
+
+/* Handle an event on one of the CPU's ports. */
+static void
+lm32cpu_port_event (struct hw *me,
+		     int my_port,
+		     struct hw *source,
+		     int source_port,
+		     int level)
+{
+  struct lm32cpu *controller = hw_data (me);
+  SIM_DESC sd = hw_system (me);
+  sim_cpu *cpu = STATE_CPU (sd, 0); /* NB: fix CPU 0. */
+  address_word cia = CIA_GET (cpu);
+
+
+  HW_TRACE ((me, "interrupt event on port %d, level %d", my_port, level));
+
+
+
+  /* 
+   * Activate IP if the interrupt's activated; don't do anything if
+   * the interrupt's deactivated.
+   */
+  if(level == 1){
+     /*
+     * save state of external interrupt
+     */
+     s_ui_ExtIntrs |= (1 << my_port);
+
+     /* interrupt-activated so set IP */
+     lm32bf_h_csr_set (cpu, LM32_CSR_IP, 
+                        lm32bf_h_csr_get (cpu, LM32_CSR_IP) | (1 << my_port));
+
+     /* 
+      * Since interrupt is activated, queue an immediate event
+      * to check if this interrupt is serviceable
+      */
+     if(controller->event != NULL)
+        hw_event_queue_deschedule(me, controller->event);
+
+
+     /* 
+      * Queue an immediate event to check if this interrupt must be serviced;
+      * this will happen after the current instruction is complete
+      */
+     controller->event = hw_event_queue_schedule (  me,
+                                                    0,
+                                                    deliver_lm32cpu_interrupt,
+                                                    0);
+  }else{
+     /*
+     * save state of external interrupt
+     */
+     s_ui_ExtIntrs &= ~(1 << my_port);
+  }
+}
+
+
+const struct hw_descriptor dv_lm32cpu_descriptor[] = {
+  { "lm32cpu", lm32cpu_finish, },
+  { NULL },
+};
+
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/dv-lm32timer.c gdb-6.8.50.20090329/sim/lm32/dv-lm32timer.c
--- gdb-6.8.50.20090329.orig/sim/lm32/dv-lm32timer.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/dv-lm32timer.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,228 @@
+/*  Lattice Mico32 timer model.
+    Contributed by Jon Beniston <jon@beniston.com>
+    
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "sim-main.h"
+#include "hw-main.h"
+#include "sim-assert.h"
+
+struct lm32timer {
+  unsigned base;        /* Base address of this timer */
+  unsigned limit;       /* Limit address of this timer */
+  unsigned int status;
+  unsigned int control;
+  unsigned int period;
+  unsigned int snapshot;
+  struct hw_event* event; 
+};
+
+/* Timer registers */
+#define LM32_TIMER_STATUS       0x0
+#define LM32_TIMER_CONTROL      0x4
+#define LM32_TIMER_PERIOD       0x8
+#define LM32_TIMER_SNAPSHOT     0xc
+
+/* Timer ports */
+
+enum {
+    INT_PORT
+  };
+
+static const struct hw_port_descriptor lm32timer_ports[] = {
+  { "int", INT_PORT, 0, output_port },
+  {}
+};
+
+static void
+do_timer_event (struct hw *me, void *data)
+{
+  struct lm32timer *timer = hw_data (me);
+  
+  /* Is timer started? */
+  if (timer->control & 0x4) 
+    {
+      if (timer->snapshot)
+        {
+          /* Decrement timer */
+          timer->snapshot--;
+        }
+      else if (timer->control & 1)
+        {
+          /* Restart timer */
+          timer->snapshot = timer->period;
+        }
+    }   
+  /* Generate interrupt when timer is at 0, and interrupt enable is 1 */
+  if ((timer->snapshot == 0) && (timer->control & 1))
+    {
+      /* Generate interrupt */
+      hw_port_event (me, INT_PORT, 1);
+    }    
+  /* If timer is started, schedule another event to decrement the timer again */
+  if (timer->control & 4) 
+    hw_event_queue_schedule (me, 1, do_timer_event, 0);
+}
+
+static unsigned
+lm32timer_io_write_buffer (struct hw *me,
+			  const void *source,
+			  int space,
+			  unsigned_word base,
+			  unsigned nr_bytes)
+{
+  struct lm32timer *timers = hw_data (me);
+  int timer_reg;
+  const unsigned char *source_bytes = source;
+  int value = 0;
+  
+  HW_TRACE ((me, "write to 0x%08lx length %d with 0x%x", (long) base,
+	     (int) nr_bytes, value));
+
+  if (nr_bytes == 4)
+    value = (source_bytes[0] << 24)
+          | (source_bytes[1] << 16)
+          | (source_bytes[2] << 8)
+          | (source_bytes[3]);
+  else 
+    hw_abort (me, "write with invalid number of bytes: %d", nr_bytes);
+  
+  timer_reg = base - timers->base;
+
+  switch (timer_reg) 
+    {
+      case LM32_TIMER_STATUS:
+        timers->status = value;
+        break;        
+      case LM32_TIMER_CONTROL:
+        timers->control = value;
+        if (timers->control & 0x4) 
+          {
+            /* Timer is started */
+            hw_event_queue_schedule (me, 1, do_timer_event, 0);
+          }
+        break;        
+      case LM32_TIMER_PERIOD:
+        timers->period = value;
+        break;        
+      default: 
+        hw_abort (me, "invalid register address: 0x%x.", timer_reg);  
+    }
+
+  return nr_bytes;
+}     
+
+static unsigned
+lm32timer_io_read_buffer (struct hw *me,
+			 void *dest,
+			 int space,
+			 unsigned_word base,
+			 unsigned nr_bytes)
+{			
+  struct lm32timer *timers = hw_data (me);
+  int timer_reg;
+  int value;
+  unsigned char *dest_bytes = dest;
+
+  HW_TRACE ((me, "read 0x%08lx length %d", (long) base, (int) nr_bytes));
+
+  timer_reg = base - timers->base;
+
+  switch (timer_reg) 
+    {
+      case LM32_TIMER_STATUS:
+        value = timers->status;
+        break;        
+      case LM32_TIMER_CONTROL:
+        value = timers->control;
+        break;        
+      case LM32_TIMER_PERIOD:
+        value = timers->period;
+        break;        
+      case LM32_TIMER_SNAPSHOT:
+        value = timers->snapshot;
+        break;       
+      default: 
+        hw_abort (me, "invalid register address: 0x%x.", timer_reg);  
+    }
+ 
+  if (nr_bytes == 4)
+    {
+      dest_bytes[0] = value >> 24;
+      dest_bytes[1] = value >> 16;
+      dest_bytes[2] = value >> 8;
+      dest_bytes[3] = value;
+    }
+  else 
+    hw_abort (me, "read of unsupported number of bytes: %d", nr_bytes);
+    
+  return nr_bytes;
+}     
+
+static void
+attach_lm32timer_regs (struct hw *me, struct lm32timer *timers)
+{
+  unsigned_word attach_address;
+  int attach_space;
+  unsigned attach_size;
+  reg_property_spec reg;
+
+  if (hw_find_property (me, "reg") == NULL) 
+    hw_abort (me, "Missing \"reg\" property");
+  if (!hw_find_reg_array_property (me, "reg", 0, &reg))
+    hw_abort (me, "\"reg\" property must contain three addr/size entries");
+  hw_unit_address_to_attach_address (hw_parent (me),
+					 &reg.address,
+					 &attach_space,
+					 &attach_address,
+					 me);
+  timers->base = attach_address;
+  hw_unit_size_to_attach_size (hw_parent (me),
+				   &reg.size,
+				   &attach_size, me);
+  timers->limit = attach_address + (attach_size - 1);
+  hw_attach_address (hw_parent (me),
+			 0,
+			 attach_space, attach_address, attach_size,
+			 me); 
+}
+
+static void
+lm32timer_finish (struct hw *me)
+{
+  struct lm32timer *timers;
+  int i;
+
+  timers = HW_ZALLOC (me, struct lm32timer);
+  set_hw_data (me, timers);
+  set_hw_io_read_buffer (me, lm32timer_io_read_buffer);
+  set_hw_io_write_buffer (me, lm32timer_io_write_buffer);
+  set_hw_ports (me, lm32timer_ports);
+
+  /* Attach ourself to our parent bus */
+  attach_lm32timer_regs (me, timers);
+
+  /* Initialize the timers */
+  timers->status = 0;
+  timers->control = 0;
+  timers->period = 0;
+  timers->snapshot = 0;
+}
+
+const struct hw_descriptor dv_lm32timer_descriptor[] = {
+  { "lm32timer", lm32timer_finish, },
+  { NULL },
+};
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/dv-lm32uart.c gdb-6.8.50.20090329/sim/lm32/dv-lm32uart.c
--- gdb-6.8.50.20090329.orig/sim/lm32/dv-lm32uart.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/dv-lm32uart.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,321 @@
+/*  Lattice Mico32 UART model.
+    Contributed by Jon Beniston <jon@beniston.com>
+    
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "sim-main.h"
+#include "hw-main.h"
+#include "sim-assert.h"
+
+#include <stdio.h>
+#include <sys/time.h>
+
+struct lm32uart {
+  unsigned base;        /* Base address of this UART */
+  unsigned limit;       /* Limit address of this UART */
+  unsigned char rbr;
+  unsigned char thr;
+  unsigned char ier;
+  unsigned char iir;
+  unsigned char lcr;
+  unsigned char mcr;
+  unsigned char lsr;
+  unsigned char msr;
+  unsigned char div;  
+  struct hw_event* event; 
+};
+
+/* UART registers */
+
+#define LM32_UART_RBR           0x0
+#define LM32_UART_THR           0x0
+#define LM32_UART_IER           0x4
+#define LM32_UART_IIR           0x8
+#define LM32_UART_LCR           0xc
+#define LM32_UART_MCR           0x10
+#define LM32_UART_LSR           0x14
+#define LM32_UART_MSR           0x18
+#define LM32_UART_DIV           0x1c
+
+#define LM32_UART_IER_RX_INT    0x1
+#define LM32_UART_IER_TX_INT    0x2
+
+#define MICOUART_IIR_TXRDY      0x2
+#define MICOUART_IIR_RXRDY      0x4
+
+#define LM32_UART_LSR_RX_RDY    0x01
+#define LM32_UART_LSR_TX_RDY    0x20
+
+#define LM32_UART_LCR_WLS_MASK  0x3
+#define LM32_UART_LCR_WLS_5     0x0
+#define LM32_UART_LCR_WLS_6     0x1
+#define LM32_UART_LCR_WLS_7     0x2
+#define LM32_UART_LCR_WLS_8     0x3
+
+/* UART ports */
+
+enum {
+    INT_PORT
+  };
+
+static const struct hw_port_descriptor lm32uart_ports[] = {
+  { "int", INT_PORT, 0, output_port },
+  {}
+};
+
+static void
+do_uart_tx_event (struct hw *me, void *data)
+{
+  struct lm32uart *uart = hw_data (me);
+  char c;
+  
+  /* Generate interrupt when transmission is complete */
+  if (uart->ier & LM32_UART_IER_TX_INT) {
+      /* Generate interrupt */
+      hw_port_event (me, INT_PORT, 1);
+  }
+
+  /* Indicate which interrupt has occured */  
+  uart->iir = MICOUART_IIR_TXRDY;
+
+  /* Indicate THR is empty */
+  uart->lsr |= LM32_UART_LSR_TX_RDY;
+
+  /* Output the character in the THR */
+  c = (char)uart->thr;
+
+  /* WLS field in LCR register specifies the number of bits to output */
+  switch (uart->lcr & LM32_UART_LCR_WLS_MASK) 
+    {
+    case LM32_UART_LCR_WLS_5:
+      c &= 0x1f;
+      break;
+    case LM32_UART_LCR_WLS_6:
+      c &= 0x3f;
+      break;
+    case LM32_UART_LCR_WLS_7: 
+      c &= 0x7f;
+      break;
+    }
+  printf ("%c", c);
+}
+
+static unsigned
+lm32uart_io_write_buffer (struct hw *me,
+			  const void *source,
+			  int space,
+			  unsigned_word base,
+			  unsigned nr_bytes)
+{
+  struct lm32uart *uart = hw_data (me);
+  int uart_reg;
+  const unsigned char *source_bytes = source;
+  int value = 0;
+  
+  HW_TRACE ((me, "write to 0x%08lx length %d with 0x%x", (long) base,
+	     (int) nr_bytes, value));
+
+  if (nr_bytes == 4)
+    value = (source_bytes[0] << 24)
+          | (source_bytes[1] << 16)
+          | (source_bytes[2] << 8)
+          | (source_bytes[3]);
+  else 
+    hw_abort (me, "write of unsupported number of bytes: %d.", nr_bytes);
+  
+  uart_reg = base - uart->base;
+
+  switch (uart_reg) 
+    {
+      case LM32_UART_THR:
+        /* Buffer the character to output */
+        uart->thr = value;
+
+        /* Indicate the THR is full */
+        uart->lsr &= ~LM32_UART_LSR_TX_RDY;
+
+        /* deassert interrupt when IER is loaded */
+        uart->iir &= ~MICOUART_IIR_TXRDY;
+
+        /* schedule an event to output the character */
+        hw_event_queue_schedule (me, 1, do_uart_tx_event, 0);
+
+        break;
+      case LM32_UART_IER:
+        uart->ier = value;
+	if((value & LM32_UART_IER_TX_INT) && (uart->lsr & LM32_UART_LSR_TX_RDY)){
+            /* hw_event_queue_schedule (me, 1, do_uart_tx_event, 0); */
+            uart->lsr |= LM32_UART_LSR_TX_RDY;
+            uart->iir |= MICOUART_IIR_TXRDY;
+            hw_port_event (me, INT_PORT, 1);
+        }else if((value & LM32_UART_IER_TX_INT) == 0){
+            hw_port_event (me, INT_PORT, 0);
+        }
+        break;
+      case LM32_UART_IIR:
+        uart->iir = value;
+        break;  
+      case LM32_UART_LCR:
+        uart->lcr = value;
+        break;
+      case LM32_UART_MCR:
+        uart->mcr = value;
+        break;
+      case LM32_UART_LSR:
+        uart->lsr = value;
+        break;
+      case LM32_UART_MSR:
+        uart->msr = value;
+        break;
+      case LM32_UART_DIV:
+        uart->div = value;
+        break;        
+      default: 
+        hw_abort (me, "write to invalid register address: 0x%x.", uart_reg);  
+    }
+
+  return nr_bytes;
+}     
+
+static unsigned
+lm32uart_io_read_buffer (struct hw *me,
+			 void *dest,
+			 int space,
+			 unsigned_word base,
+			 unsigned nr_bytes)
+{			
+  struct lm32uart *uart = hw_data (me);
+  int uart_reg;
+  int value;
+  unsigned char *dest_bytes = dest;
+  fd_set fd;
+  struct timeval tv;
+
+  HW_TRACE ((me, "read 0x%08lx length %d", (long) base, (int) nr_bytes));
+
+  uart_reg = base - uart->base;
+
+  switch (uart_reg) 
+    {
+      case LM32_UART_RBR:
+        value = getchar ();
+        uart->lsr &= ~LM32_UART_LSR_RX_RDY;
+        break;
+      case LM32_UART_IER:
+        value = uart->ier;
+        break; 
+      case LM32_UART_IIR:
+        value = uart->iir;
+        break;  
+      case LM32_UART_LCR:
+        value = uart->lcr;
+        break;
+      case LM32_UART_MCR:
+        value = uart->mcr;
+        break;
+      case LM32_UART_LSR:
+        /* Check to see if any data waiting in stdin */
+        FD_ZERO (&fd);
+        FD_SET (fileno (stdin), &fd);
+        tv.tv_sec = 0;
+        tv.tv_usec = 1;
+        if (select (fileno (stdin) + 1, &fd, NULL, NULL, &tv)) 
+          uart->lsr |= LM32_UART_LSR_RX_RDY;
+        value = uart->lsr;
+        break;
+      case LM32_UART_MSR:
+        value = uart->msr;
+        break;
+      case LM32_UART_DIV:
+        value = uart->div;
+        break;        
+      default: 
+        hw_abort (me, "read from invalid register address: 0x%x.", uart_reg);  
+    }
+
+  if (nr_bytes == 4)
+    {
+      dest_bytes[0] = value >> 24;
+      dest_bytes[1] = value >> 16;
+      dest_bytes[2] = value >> 8;
+      dest_bytes[3] = value;
+    }
+  else 
+    hw_abort (me, "read of unsupported number of bytes: %d", nr_bytes);
+    
+  return nr_bytes;
+}     
+
+static void
+attach_lm32uart_regs (struct hw *me, struct lm32uart *uart)
+{
+  unsigned_word attach_address;
+  int attach_space;
+  unsigned attach_size;
+  reg_property_spec reg;
+
+  if (hw_find_property (me, "reg") == NULL) 
+    hw_abort (me, "Missing \"reg\" property");
+  if (!hw_find_reg_array_property (me, "reg", 0, &reg))
+    hw_abort (me, "\"reg\" property must contain three addr/size entries");
+  hw_unit_address_to_attach_address (hw_parent (me),
+					 &reg.address,
+					 &attach_space,
+					 &attach_address,
+					 me);
+  uart->base = attach_address;
+  hw_unit_size_to_attach_size (hw_parent (me),
+				   &reg.size,
+				   &attach_size, me);
+  uart->limit = attach_address + (attach_size - 1);
+  hw_attach_address (hw_parent (me),
+			 0,
+			 attach_space, attach_address, attach_size,
+			 me); 
+}
+
+static void
+lm32uart_finish (struct hw *me)
+{
+  struct lm32uart *uart;
+  int i;
+
+  uart = HW_ZALLOC (me, struct lm32uart);
+  set_hw_data (me, uart);
+  set_hw_io_read_buffer (me, lm32uart_io_read_buffer);
+  set_hw_io_write_buffer (me, lm32uart_io_write_buffer);
+  set_hw_ports (me, lm32uart_ports);
+
+  /* Attach ourself to our parent bus */
+  attach_lm32uart_regs (me, uart);
+
+  /* Initialize the UART */
+  uart->rbr = 0;
+  uart->thr = 0;
+  uart->ier = 0;
+  uart->iir = 0;
+  uart->lcr = 0;
+  uart->mcr = 0;
+  uart->lsr = LM32_UART_LSR_TX_RDY;
+  uart->msr = 0;
+  uart->div = 0;  /* By setting to zero, characters are output immediately */
+}
+
+const struct hw_descriptor dv_lm32uart_descriptor[] = {
+  { "lm32uart", lm32uart_finish, },
+  { NULL },
+};
+
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/lm32.c gdb-6.8.50.20090329/sim/lm32/lm32.c
--- gdb-6.8.50.20090329.orig/sim/lm32/lm32.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/lm32.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,96 @@
+/* Lattice Mico32 simulator support code.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define WANT_CPU lm32bf
+#define WANT_CPU_LM32BF
+
+#include "sim-main.h"
+#include "cgen-mem.h"
+#include "cgen-ops.h"
+
+/* The contents of BUF are in target byte order.  */
+
+int
+lm32bf_fetch_register (SIM_CPU *current_cpu, int rn, unsigned char *buf, int len)
+{
+  if (rn < 32)
+    SETTSI (buf, lm32bf_h_gr_get (current_cpu, rn));
+  else
+    switch (rn)
+      {
+      case SIM_LM32_PC_REGNUM :
+	SETTSI (buf, lm32bf_h_pc_get (current_cpu));
+	break;
+      default :
+	return 0;
+      }
+
+  return -1; /*FIXME*/
+}
+
+/* The contents of BUF are in target byte order.  */
+
+int
+lm32bf_store_register (SIM_CPU *current_cpu, int rn, unsigned char *buf, int len)
+{
+  if (rn < 32)
+    lm32bf_h_gr_set (current_cpu, rn, GETTSI (buf));
+  else
+    switch (rn)
+      {
+      case SIM_LM32_PC_REGNUM :
+	lm32bf_h_pc_set (current_cpu, GETTSI (buf));
+	break;
+      default :
+	return 0;
+      }
+
+  return -1; /*FIXME*/
+}
+
+
+
+#if WITH_PROFILE_MODEL_P
+
+/* Initialize cycle counting for an insn.
+   FIRST_P is non-zero if this is the first insn in a set of parallel
+   insns.  */
+
+void
+lm32bf_model_insn_before (SIM_CPU *cpu, int first_p)
+{
+}
+
+/* Record the cycles computed for an insn.
+   LAST_P is non-zero if this is the last insn in a set of parallel insns,
+   and we update the total cycle count.
+   CYCLES is the cycle count of the insn.  */
+
+void
+lm32bf_model_insn_after (SIM_CPU *cpu, int last_p, int cycles)
+{
+}
+
+int
+lm32bf_model_lm32_u_exec (SIM_CPU *cpu, const IDESC *idesc,
+			    int unit_num, int referenced)
+{
+  return idesc->timing->units[unit_num].done;
+}
+
+#endif /* WITH_PROFILE_MODEL_P */
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/lm32-sim.h gdb-6.8.50.20090329/sim/lm32/lm32-sim.h
--- gdb-6.8.50.20090329.orig/sim/lm32/lm32-sim.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/lm32-sim.h	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,55 @@
+/* Contributed by Jon Beniston <jon@beniston.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef LM32_SIM_H
+#define LM32_SIM_H
+
+#include "gdb/sim-lm32.h"
+
+/* CSRs */
+#define LM32_CSR_IE             0
+#define LM32_CSR_IM             1
+#define LM32_CSR_IP             2
+#define LM32_CSR_ICC            3
+#define LM32_CSR_DCC            4
+#define LM32_CSR_CC             5
+#define LM32_CSR_CFG            6
+#define LM32_CSR_EBA            7
+#define LM32_CSR_DC             8
+#define LM32_CSR_DEBA           9
+#define LM32_CSR_JTX            0xe
+#define LM32_CSR_JRX            0xf
+#define LM32_CSR_BP0            0x10
+#define LM32_CSR_BP1            0x11
+#define LM32_CSR_BP2            0x12
+#define LM32_CSR_BP3            0x13
+#define LM32_CSR_WP0            0x18
+#define LM32_CSR_WP1            0x19
+#define LM32_CSR_WP2            0x1a
+#define LM32_CSR_WP3            0x1b
+
+/* Exception IDs */
+#define LM32_EID_RESET                  0
+#define LM32_EID_BREAKPOINT             1
+#define LM32_EID_INSTRUCTION_BUS_ERROR  2
+#define LM32_EID_WATCHPOINT             3
+#define LM32_EID_DATA_BUS_ERROR         4
+#define LM32_EID_DIVIDE_BY_ZERO         5
+#define LM32_EID_INTERRUPT              6
+#define LM32_EID_SYSTEM_CALL            7
+
+#endif /* LM32_SIM_H */
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/Makefile.in gdb-6.8.50.20090329/sim/lm32/Makefile.in
--- gdb-6.8.50.20090329.orig/sim/lm32/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/Makefile.in	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,92 @@
+# Makefile for Lattice Mico32 simulator.
+# Contributed by Jon Beniston <jon@beniston.com>
+
+## COMMON_PRE_CONFIG_FRAG
+
+# List of object files, less common parts.
+SIM_OBJS = \
+	$(SIM_NEW_COMMON_OBJS) \
+	sim-cpu.o \
+	sim-hload.o \
+	sim-hrw.o \
+	sim-model.o \
+	sim-reg.o \
+	sim-signal.o \
+        cgen-utils.o cgen-trace.o cgen-scache.o \
+        cgen-run.o sim-reason.o sim-engine.o sim-stop.o \
+        sim-if.o arch.o \
+        cpu.o decode.o sem.o model.o mloop.o \
+        lm32.o traps.o user.o 
+        
+# List of extra dependencies.
+# Generally this consists of simulator specific files included by sim-main.h.
+SIM_EXTRA_DEPS = $(CGEN_INCLUDE_DEPS) $(srcdir)/../../opcodes/lm32-desc.h
+
+# List of flags to always pass to $(CC).
+#SIM_EXTRA_CFLAGS =
+
+# List of main object files for `run'.
+SIM_RUN_OBJS = nrun.o
+
+SIM_EXTRA_CLEAN = lm32-clean
+
+# This selects the lm32 newlib/libgloss syscall definitions.
+NL_TARGET = -DNL_TARGET_lm32
+
+## COMMON_POST_CONFIG_FRAG
+
+arch = lm32 
+
+arch.o: arch.c $(SIM_MAIN_DEPS)
+
+traps.o: traps.c targ-vals.h $(SIM_MAIN_DEPS)
+
+sim-if.o: sim-if.c $(SIM_MAIN_DEPS) $(srcdir)/../common/sim-core.h
+
+LM32BF_INCLUDE_DEPS = \
+	$(CGEN_MAIN_CPU_DEPS) \
+	cpu.h decode.h eng.h
+
+lm32.o: lm32.c $(LM32BF_INCLUDE_DEPS)
+
+# FIXME: Use of `mono' is wip.
+mloop.c eng.h: stamp-mloop
+stamp-mloop: $(srcdir)/../common/genmloop.sh mloop.in Makefile
+	$(SHELL) $(srccom)/genmloop.sh \
+		-mono -fast -pbb -switch sem-switch.c \
+		-cpu lm32bf -infile $(srcdir)/mloop.in
+	$(SHELL) $(srcroot)/move-if-change eng.hin eng.h
+	$(SHELL) $(srcroot)/move-if-change mloop.cin mloop.c
+	touch stamp-mloop
+mloop.o: mloop.c sem-switch.c 
+
+cpu.o: cpu.c $(LM32BF_INCLUDE_DEPS)
+decode.o: decode.c $(LM32BF_INCLUDE_DEPS)
+sem.o: sem.c $(LM32BF_INCLUDE_DEPS)
+model.o: model.c $(LM32BF_INCLUDE_DEPS)
+
+lm32-clean:
+	rm -f mloop.c eng.h stamp-mloop
+	rm -f stamp-arch stamp-cpu 
+	rm -f tmp-*
+
+# cgen support, enable with --enable-cgen-maint
+CGEN_MAINT = ; @true
+# The following line is commented in or out depending upon --enable-cgen-maint.
+@CGEN_MAINT@CGEN_MAINT =
+
+stamp-arch: $(CGEN_READ_SCM) $(CGEN_ARCH_SCM) $(CGEN_CPU_DIR)/lm32.cpu
+	$(MAKE) cgen-arch $(CGEN_FLAGS_TO_PASS) mach=all \
+	  archfile=$(CGEN_CPU_DIR)/lm32.cpu \
+	  FLAGS="with-scache with-profile=fn"
+	touch stamp-arch
+arch.h arch.c cpuall.h: $(CGEN_MAINT) stamp-arch
+
+stamp-cpu: $(CGEN_READ_SCM) $(CGEN_CPU_SCM) $(CGEN_DECODE_SCM) $(CGEN_CPU_DIR)/lm32.cpu
+	$(MAKE) cgen-cpu-decode $(CGEN_FLAGS_TO_PASS) \
+	  cpu=lm32bf mach=lm32 SUFFIX= \
+	  archfile=$(CGEN_CPU_DIR)/lm32.cpu \
+	  FLAGS="with-scache with-profile=fn" \
+	  EXTRAFILES="$(CGEN_CPU_SEM) $(CGEN_CPU_SEMSW)"
+	touch stamp-cpu
+cpu.h sem.c sem-switch.c model.c decode.c decode.h: $(CGEN_MAINT) stamp-cpu
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/mloop.in gdb-6.8.50.20090329/sim/lm32/mloop.in
--- gdb-6.8.50.20090329.orig/sim/lm32/mloop.in	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/mloop.in	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,203 @@
+# Simulator main loop for lm32. -*- C -*-
+# Contributed by Jon Beniston <jon@beniston.com>
+#
+# This file is part of the GNU Simulators.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Syntax:
+# /bin/sh mainloop.in command
+#
+# Command is one of:
+#
+# init
+# support
+# extract-{simple,scache,pbb}
+# {full,fast}-exec-{simple,scache,pbb}
+#
+
+case "x$1" in
+
+xsupport)
+
+cat <<EOF
+
+static INLINE const IDESC *
+extract (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn,
+	   ARGBUF *abuf, int fast_p)
+{
+  const IDESC *id = @cpu@_decode (current_cpu, pc, insn, insn, abuf);
+
+  @cpu@_fill_argbuf (current_cpu, abuf, id, pc, fast_p);
+  if (! fast_p)
+    {
+      int trace_p = PC_IN_TRACE_RANGE_P (current_cpu, pc);
+      int profile_p = PC_IN_PROFILE_RANGE_P (current_cpu, pc);
+      @cpu@_fill_argbuf_tp (current_cpu, abuf, trace_p, profile_p);
+    }
+  return id;
+}
+
+static INLINE SEM_PC
+execute (SIM_CPU *current_cpu, SCACHE *sc, int fast_p)
+{
+  SEM_PC vpc;
+
+  if (fast_p)
+    {
+#if ! WITH_SEM_SWITCH_FAST
+#if WITH_SCACHE
+      vpc = (*sc->argbuf.semantic.sem_fast) (current_cpu, sc);
+#else
+      vpc = (*sc->argbuf.semantic.sem_fast) (current_cpu, &sc->argbuf);
+#endif
+#else
+      abort ();
+#endif /* WITH_SEM_SWITCH_FAST */
+    }
+  else
+    {
+#if ! WITH_SEM_SWITCH_FULL
+      ARGBUF *abuf = &sc->argbuf;
+      const IDESC *idesc = abuf->idesc;
+      const CGEN_INSN *idata = idesc->idata;
+#if WITH_SCACHE_PBB
+      int virtual_p = CGEN_INSN_ATTR_VALUE (idata, CGEN_INSN_VIRTUAL);
+#else
+      int virtual_p = 0;
+#endif
+      if (! virtual_p)
+	{
+	  /* FIXME: call x-before */
+	  if (ARGBUF_PROFILE_P (abuf))
+	    PROFILE_COUNT_INSN (current_cpu, abuf->addr, idesc->num);
+	  /* FIXME: Later make cover macros: PROFILE_INSN_{INIT,FINI}.  */
+	  if (PROFILE_MODEL_P (current_cpu)
+	      && ARGBUF_PROFILE_P (abuf))
+	    @cpu@_model_insn_before (current_cpu, 1 /*first_p*/);
+	  TRACE_INSN_INIT (current_cpu, abuf, 1);
+	  TRACE_INSN (current_cpu, idata,
+		      (const struct argbuf *) abuf, abuf->addr);
+	}
+#if WITH_SCACHE
+      vpc = (*sc->argbuf.semantic.sem_full) (current_cpu, sc);
+#else
+      vpc = (*sc->argbuf.semantic.sem_full) (current_cpu, abuf);
+#endif
+      if (! virtual_p)
+	{
+	  /* FIXME: call x-after */
+	  if (PROFILE_MODEL_P (current_cpu)
+	      && ARGBUF_PROFILE_P (abuf))
+	    {
+	      int cycles;
+
+	      cycles = (*idesc->timing->model_fn) (current_cpu, sc);
+	      @cpu@_model_insn_after (current_cpu, 1 /*last_p*/, cycles);
+	    }
+	  TRACE_INSN_FINI (current_cpu, abuf, 1);
+	}
+#else
+      abort ();
+#endif /* WITH_SEM_SWITCH_FULL */
+    }
+
+  return vpc;
+}
+
+EOF
+
+;;
+
+xinit)
+
+# Nothing needed.
+
+;;
+
+xextract-simple | xextract-scache)
+
+cat <<EOF
+{
+  CGEN_INSN_INT insn = GETIMEMUSI (current_cpu, vpc);
+  extract (current_cpu, vpc, insn, SEM_ARGBUF (sc), FAST_P);
+}
+EOF
+
+;;
+
+xextract-pbb)
+
+# Inputs:  current_cpu, pc, sc, max_insns, FAST_P
+# Outputs: sc, pc
+# sc must be left pointing past the last created entry.
+# pc must be left pointing past the last created entry.
+# If the pbb is terminated by a cti insn, SET_CTI_VPC(sc) must be called
+# to record the vpc of the cti insn.
+# SET_INSN_COUNT(n) must be called to record number of real insns.
+
+cat <<EOF
+{
+  const IDESC *idesc;
+  int icount = 0;
+
+  while (max_insns > 0)
+    {
+      USI insn = GETIMEMUSI (current_cpu, pc);
+      
+      idesc = extract (current_cpu, pc, insn, &sc->argbuf, FAST_P);
+      ++sc;
+      --max_insns;
+      ++icount;
+      pc += idesc->length;
+
+      if (IDESC_CTI_P (idesc))
+        {
+          SET_CTI_VPC (sc - 1);
+          break;
+        }
+    }
+
+ Finish:
+  SET_INSN_COUNT (icount);
+}
+EOF
+
+;;
+
+xfull-exec-* | xfast-exec-*)
+
+# Inputs: current_cpu, vpc, FAST_P
+# Outputs: vpc
+
+cat <<EOF
+  /* Update cycle counter */
+  SET_H_CSR (LM32_CSR_CC, GET_H_CSR (LM32_CSR_CC) + 1);
+#if (! FAST_P && WITH_SEM_SWITCH_FULL) || (FAST_P && WITH_SEM_SWITCH_FAST)
+#define DEFINE_SWITCH
+#include "sem-switch.c"
+#else
+  vpc = execute (current_cpu, vpc, FAST_P);
+#endif
+EOF
+
+;;
+
+*)
+  echo "Invalid argument to mainloop.in: $1" >&2
+  exit 1
+  ;;
+
+esac
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/model.c gdb-6.8.50.20090329/sim/lm32/model.c
--- gdb-6.8.50.20090329.orig/sim/lm32/model.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/model.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,1176 @@
+/* Simulator model support for lm32bf.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#define WANT_CPU lm32bf
+#define WANT_CPU_LM32BF
+
+#include "sim-main.h"
+
+/* The profiling data is recorded here, but is accessed via the profiling
+   mechanism.  After all, this is information for profiling.  */
+
+#if WITH_PROFILE_MODEL_P
+
+/* Model handlers for each insn.  */
+
+static int
+model_lm32_add (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_addi (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_and (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_andi (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_andhii (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_b (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_bi (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_bi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_be (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_bg (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_bge (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_bgeu (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_bgu (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_bne (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_call (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_calli (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_bi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpe (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpei (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpg (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpgi (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpge (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpgei (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpgeu (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpgeui (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpgu (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpgui (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpne (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_cmpnei (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_divu (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_lb (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_lbu (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_lh (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_lhu (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_lw (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_modu (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_mul (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_muli (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_nor (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_nori (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_or (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_ori (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_orhii (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_rcsr (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_rcsr.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sb (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sextb (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sexth (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sh (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sl (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sli (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sr (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sri (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sru (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_srui (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sub (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_sw (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_user (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_wcsr (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_wcsr.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_xor (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_xori (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_xnor (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_xnori (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_break (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+static int
+model_lm32_scall (SIM_CPU *current_cpu, void *sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
+  const IDESC * UNUSED idesc = abuf->idesc;
+  int cycles = 0;
+  {
+    int referenced = 0;
+    int UNUSED insn_referenced = abuf->written;
+    cycles += lm32bf_model_lm32_u_exec (current_cpu, idesc, 0, referenced);
+  }
+  return cycles;
+#undef FLD
+}
+
+/* We assume UNIT_NONE == 0 because the tables don't always terminate
+   entries with it.  */
+
+/* Model timing data for `lm32'.  */
+
+static const INSN_TIMING lm32_timing[] = {
+  { LM32BF_INSN_X_INVALID, 0, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_X_AFTER, 0, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_X_BEFORE, 0, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_X_CTI_CHAIN, 0, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_X_CHAIN, 0, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_X_BEGIN, 0, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_ADD, model_lm32_add, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_ADDI, model_lm32_addi, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_AND, model_lm32_and, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_ANDI, model_lm32_andi, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_ANDHII, model_lm32_andhii, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_B, model_lm32_b, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_BI, model_lm32_bi, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_BE, model_lm32_be, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_BG, model_lm32_bg, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_BGE, model_lm32_bge, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_BGEU, model_lm32_bgeu, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_BGU, model_lm32_bgu, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_BNE, model_lm32_bne, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CALL, model_lm32_call, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CALLI, model_lm32_calli, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPE, model_lm32_cmpe, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPEI, model_lm32_cmpei, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPG, model_lm32_cmpg, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPGI, model_lm32_cmpgi, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPGE, model_lm32_cmpge, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPGEI, model_lm32_cmpgei, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPGEU, model_lm32_cmpgeu, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPGEUI, model_lm32_cmpgeui, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPGU, model_lm32_cmpgu, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPGUI, model_lm32_cmpgui, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPNE, model_lm32_cmpne, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_CMPNEI, model_lm32_cmpnei, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_DIVU, model_lm32_divu, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_LB, model_lm32_lb, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_LBU, model_lm32_lbu, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_LH, model_lm32_lh, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_LHU, model_lm32_lhu, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_LW, model_lm32_lw, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_MODU, model_lm32_modu, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_MUL, model_lm32_mul, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_MULI, model_lm32_muli, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_NOR, model_lm32_nor, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_NORI, model_lm32_nori, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_OR, model_lm32_or, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_ORI, model_lm32_ori, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_ORHII, model_lm32_orhii, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_RCSR, model_lm32_rcsr, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SB, model_lm32_sb, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SEXTB, model_lm32_sextb, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SEXTH, model_lm32_sexth, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SH, model_lm32_sh, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SL, model_lm32_sl, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SLI, model_lm32_sli, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SR, model_lm32_sr, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SRI, model_lm32_sri, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SRU, model_lm32_sru, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SRUI, model_lm32_srui, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SUB, model_lm32_sub, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SW, model_lm32_sw, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_USER, model_lm32_user, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_WCSR, model_lm32_wcsr, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_XOR, model_lm32_xor, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_XORI, model_lm32_xori, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_XNOR, model_lm32_xnor, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_XNORI, model_lm32_xnori, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_BREAK, model_lm32_break, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+  { LM32BF_INSN_SCALL, model_lm32_scall, { { (int) UNIT_LM32_U_EXEC, 1, 1 } } },
+};
+
+#endif /* WITH_PROFILE_MODEL_P */
+
+static void
+lm32_model_init (SIM_CPU *cpu)
+{
+  CPU_MODEL_DATA (cpu) = (void *) zalloc (sizeof (MODEL_LM32_DATA));
+}
+
+#if WITH_PROFILE_MODEL_P
+#define TIMING_DATA(td) td
+#else
+#define TIMING_DATA(td) 0
+#endif
+
+static const MODEL lm32_models[] =
+{
+  { "lm32", & lm32_mach, MODEL_LM32, TIMING_DATA (& lm32_timing[0]), lm32_model_init },
+  { 0 }
+};
+
+/* The properties of this cpu's implementation.  */
+
+static const MACH_IMP_PROPERTIES lm32bf_imp_properties =
+{
+  sizeof (SIM_CPU),
+#if WITH_SCACHE
+  sizeof (SCACHE)
+#else
+  0
+#endif
+};
+
+
+static void
+lm32bf_prepare_run (SIM_CPU *cpu)
+{
+  if (CPU_IDESC (cpu) == NULL)
+    lm32bf_init_idesc_table (cpu);
+}
+
+static const CGEN_INSN *
+lm32bf_get_idata (SIM_CPU *cpu, int inum)
+{
+  return CPU_IDESC (cpu) [inum].idata;
+}
+
+static void
+lm32_init_cpu (SIM_CPU *cpu)
+{
+  CPU_REG_FETCH (cpu) = lm32bf_fetch_register;
+  CPU_REG_STORE (cpu) = lm32bf_store_register;
+  CPU_PC_FETCH (cpu) = lm32bf_h_pc_get;
+  CPU_PC_STORE (cpu) = lm32bf_h_pc_set;
+  CPU_GET_IDATA (cpu) = lm32bf_get_idata;
+  CPU_MAX_INSNS (cpu) = LM32BF_INSN__MAX;
+  CPU_INSN_NAME (cpu) = cgen_insn_name;
+  CPU_FULL_ENGINE_FN (cpu) = lm32bf_engine_run_full;
+#if WITH_FAST
+  CPU_FAST_ENGINE_FN (cpu) = lm32bf_engine_run_fast;
+#else
+  CPU_FAST_ENGINE_FN (cpu) = lm32bf_engine_run_full;
+#endif
+}
+
+const MACH lm32_mach =
+{
+  "lm32", "lm32", MACH_LM32,
+  32, 32, & lm32_models[0], & lm32bf_imp_properties,
+  lm32_init_cpu,
+  lm32bf_prepare_run
+};
+
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/sem.c gdb-6.8.50.20090329/sim/lm32/sem.c
--- gdb-6.8.50.20090329.orig/sim/lm32/sem.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/sem.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,1669 @@
+/* Simulator instruction semantics for lm32bf.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#define WANT_CPU lm32bf
+#define WANT_CPU_LM32BF
+
+#include "sim-main.h"
+#include "cgen-mem.h"
+#include "cgen-ops.h"
+
+#undef GET_ATTR
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_##attr)
+#else
+#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_/**/attr)
+#endif
+
+/* This is used so that we can compile two copies of the semantic code,
+   one with full feature support and one without that runs fast(er).
+   FAST_P, when desired, is defined on the command line, -DFAST_P=1.  */
+#if FAST_P
+#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_semf_,fn)
+#undef TRACE_RESULT
+#define TRACE_RESULT(cpu, abuf, name, type, val)
+#else
+#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_sem_,fn)
+#endif
+
+/* x-invalid: --invalid-- */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,x_invalid) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+    /* Update the recorded pc in the cpu state struct.
+       Only necessary for WITH_SCACHE case, but to avoid the
+       conditional compilation ....  */
+    SET_H_PC (pc);
+    /* Virtual insns have zero size.  Overwrite vpc with address of next insn
+       using the default-insn-bitsize spec.  When executing insns in parallel
+       we may want to queue the fault and continue execution.  */
+    vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+    vpc = sim_engine_invalid_insn (current_cpu, pc, vpc);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* x-after: --after-- */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,x_after) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+    lm32bf_pbb_after (current_cpu, sem_arg);
+#endif
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* x-before: --before-- */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,x_before) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+    lm32bf_pbb_before (current_cpu, sem_arg);
+#endif
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* x-cti-chain: --cti-chain-- */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,x_cti_chain) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+#ifdef DEFINE_SWITCH
+    vpc = lm32bf_pbb_cti_chain (current_cpu, sem_arg,
+			       pbb_br_type, pbb_br_npc);
+    BREAK (sem);
+#else
+    /* FIXME: Allow provision of explicit ifmt spec in insn spec.  */
+    vpc = lm32bf_pbb_cti_chain (current_cpu, sem_arg,
+			       CPU_PBB_BR_TYPE (current_cpu),
+			       CPU_PBB_BR_NPC (current_cpu));
+#endif
+#endif
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* x-chain: --chain-- */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,x_chain) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+    vpc = lm32bf_pbb_chain (current_cpu, sem_arg);
+#ifdef DEFINE_SWITCH
+    BREAK (sem);
+#endif
+#endif
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* x-begin: --begin-- */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,x_begin) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+#if defined DEFINE_SWITCH || defined FAST_P
+    /* In the switch case FAST_P is a constant, allowing several optimizations
+       in any called inline functions.  */
+    vpc = lm32bf_pbb_begin (current_cpu, FAST_P);
+#else
+#if 0 /* cgen engine can't handle dynamic fast/full switching yet.  */
+    vpc = lm32bf_pbb_begin (current_cpu, STATE_RUN_FAST_P (CPU_STATE (current_cpu)));
+#else
+    vpc = lm32bf_pbb_begin (current_cpu, 0);
+#endif
+#endif
+#endif
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* add: add $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,add) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ADDSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* addi: addi $r1,$r0,$imm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,addi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* and: and $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,and) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ANDSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* andi: andi $r1,$r0,$uimm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,andi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ANDSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* andhii: andhi $r1,$r0,$hi16 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,andhii) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ANDSI (CPU (h_gr[FLD (f_r0)]), SLLSI (FLD (f_uimm), 16));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* b: b $r0 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,b) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_b_insn (current_cpu, CPU (h_gr[FLD (f_r0)]), FLD (f_r0));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* bi: bi $call */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,bi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_bi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = EXTSISI (FLD (i_call));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* be: be $r0,$r1,$branch */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,be) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (EQSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* bg: bg $r0,$r1,$branch */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,bg) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (GTSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* bge: bge $r0,$r1,$branch */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,bge) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (GESI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* bgeu: bgeu $r0,$r1,$branch */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,bgeu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (GEUSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* bgu: bgu $r0,$r1,$branch */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,bgu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (GTUSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* bne: bne $r0,$r1,$branch */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,bne) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (NESI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* call: call $r0 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,call) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_be.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+{
+  {
+    SI opval = ADDSI (pc, 4);
+    CPU (h_gr[((UINT) 29)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+  {
+    USI opval = CPU (h_gr[FLD (f_r0)]);
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* calli: calli $call */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,calli) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_bi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+{
+  {
+    SI opval = ADDSI (pc, 4);
+    CPU (h_gr[((UINT) 29)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+  {
+    USI opval = EXTSISI (FLD (i_call));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* cmpe: cmpe $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpe) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EQSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpei: cmpei $r1,$r0,$imm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpei) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EQSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpg: cmpg $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpg) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GTSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpgi: cmpgi $r1,$r0,$imm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpgi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GTSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpge: cmpge $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpge) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GESI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpgei: cmpgei $r1,$r0,$imm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpgei) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GESI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpgeu: cmpgeu $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpgeu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GEUSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpgeui: cmpgeui $r1,$r0,$uimm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpgeui) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GEUSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpgu: cmpgu $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpgu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GTUSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpgui: cmpgui $r1,$r0,$uimm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpgui) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GTUSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpne: cmpne $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpne) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = NESI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* cmpnei: cmpnei $r1,$r0,$imm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,cmpnei) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = NESI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* divu: divu $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,divu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_divu_insn (current_cpu, pc, FLD (f_r0), FLD (f_r1), FLD (f_r2));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* lb: lb $r1,($r0+$imm) */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,lb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* lbu: lbu $r1,($r0+$imm) */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,lbu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ZEXTQISI (GETMEMQI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* lh: lh $r1,($r0+$imm) */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,lh) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* lhu: lhu $r1,($r0+$imm) */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,lhu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ZEXTHISI (GETMEMHI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* lw: lw $r1,($r0+$imm) */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,lw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GETMEMSI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm)))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* modu: modu $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,modu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_modu_insn (current_cpu, pc, FLD (f_r0), FLD (f_r1), FLD (f_r2));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* mul: mul $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,mul) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = MULSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* muli: muli $r1,$r0,$imm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,muli) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = MULSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* nor: nor $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,nor) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = INVSI (ORSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)])));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* nori: nori $r1,$r0,$uimm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,nori) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = INVSI (ORSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* or: or $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,or) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ORSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* ori: ori $r1,$r0,$lo16 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,ori) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ORSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* orhii: orhi $r1,$r0,$hi16 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,orhii) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ORSI (CPU (h_gr[FLD (f_r0)]), SLLSI (FLD (f_uimm), 16));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* rcsr: rcsr $r2,$csr */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,rcsr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_rcsr.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = CPU (h_csr[FLD (f_csr)]);
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sb: sb ($r0+$imm),$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    QI opval = CPU (h_gr[FLD (f_r1)]);
+    SETMEMQI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm)))), opval);
+    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sextb: sextb $r2,$r0 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sextb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EXTQISI (TRUNCSIQI (CPU (h_gr[FLD (f_r0)])));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sexth: sexth $r2,$r0 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sexth) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EXTHISI (TRUNCSIHI (CPU (h_gr[FLD (f_r0)])));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sh: sh ($r0+$imm),$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sh) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    HI opval = CPU (h_gr[FLD (f_r1)]);
+    SETMEMHI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm)))), opval);
+    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sl: sl $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SLLSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sli: sli $r1,$r0,$imm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sli) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SLLSI (CPU (h_gr[FLD (f_r0)]), FLD (f_imm));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sr: sr $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SRASI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sri: sri $r1,$r0,$imm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sri) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SRASI (CPU (h_gr[FLD (f_r0)]), FLD (f_imm));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sru: sru $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sru) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SRLSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* srui: srui $r1,$r0,$imm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,srui) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SRLSI (CPU (h_gr[FLD (f_r0)]), FLD (f_imm));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sub: sub $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sub) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SUBSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* sw: sw ($r0+$imm),$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,sw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_addi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = CPU (h_gr[FLD (f_r1)]);
+    SETMEMSI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm)))), opval);
+    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* user: user $r2,$r0,$r1,$user */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,user) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = lm32bf_user_insn (current_cpu, CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]), FLD (f_user));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* wcsr: wcsr $csr,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,wcsr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_wcsr.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+lm32bf_wcsr_insn (current_cpu, FLD (f_csr), CPU (h_gr[FLD (f_r1)]));
+
+  return vpc;
+#undef FLD
+}
+
+/* xor: xor $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,xor) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = XORSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* xori: xori $r1,$r0,$uimm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,xori) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = XORSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* xnor: xnor $r2,$r0,$r1 */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,xnor) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_user.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = INVSI (XORSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)])));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* xnori: xnori $r1,$r0,$uimm */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,xnori) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.sfmt_andi.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = INVSI (XORSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+  return vpc;
+#undef FLD
+}
+
+/* break: break */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,break) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_break_insn (current_cpu, pc);
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* scall: scall */
+
+static SEM_PC
+SEM_FN_NAME (lm32bf,scall) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
+{
+#define FLD(f) abuf->fields.fmt_empty.f
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_scall_insn (current_cpu, pc);
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+  return vpc;
+#undef FLD
+}
+
+/* Table of all semantic fns.  */
+
+static const struct sem_fn_desc sem_fns[] = {
+  { LM32BF_INSN_X_INVALID, SEM_FN_NAME (lm32bf,x_invalid) },
+  { LM32BF_INSN_X_AFTER, SEM_FN_NAME (lm32bf,x_after) },
+  { LM32BF_INSN_X_BEFORE, SEM_FN_NAME (lm32bf,x_before) },
+  { LM32BF_INSN_X_CTI_CHAIN, SEM_FN_NAME (lm32bf,x_cti_chain) },
+  { LM32BF_INSN_X_CHAIN, SEM_FN_NAME (lm32bf,x_chain) },
+  { LM32BF_INSN_X_BEGIN, SEM_FN_NAME (lm32bf,x_begin) },
+  { LM32BF_INSN_ADD, SEM_FN_NAME (lm32bf,add) },
+  { LM32BF_INSN_ADDI, SEM_FN_NAME (lm32bf,addi) },
+  { LM32BF_INSN_AND, SEM_FN_NAME (lm32bf,and) },
+  { LM32BF_INSN_ANDI, SEM_FN_NAME (lm32bf,andi) },
+  { LM32BF_INSN_ANDHII, SEM_FN_NAME (lm32bf,andhii) },
+  { LM32BF_INSN_B, SEM_FN_NAME (lm32bf,b) },
+  { LM32BF_INSN_BI, SEM_FN_NAME (lm32bf,bi) },
+  { LM32BF_INSN_BE, SEM_FN_NAME (lm32bf,be) },
+  { LM32BF_INSN_BG, SEM_FN_NAME (lm32bf,bg) },
+  { LM32BF_INSN_BGE, SEM_FN_NAME (lm32bf,bge) },
+  { LM32BF_INSN_BGEU, SEM_FN_NAME (lm32bf,bgeu) },
+  { LM32BF_INSN_BGU, SEM_FN_NAME (lm32bf,bgu) },
+  { LM32BF_INSN_BNE, SEM_FN_NAME (lm32bf,bne) },
+  { LM32BF_INSN_CALL, SEM_FN_NAME (lm32bf,call) },
+  { LM32BF_INSN_CALLI, SEM_FN_NAME (lm32bf,calli) },
+  { LM32BF_INSN_CMPE, SEM_FN_NAME (lm32bf,cmpe) },
+  { LM32BF_INSN_CMPEI, SEM_FN_NAME (lm32bf,cmpei) },
+  { LM32BF_INSN_CMPG, SEM_FN_NAME (lm32bf,cmpg) },
+  { LM32BF_INSN_CMPGI, SEM_FN_NAME (lm32bf,cmpgi) },
+  { LM32BF_INSN_CMPGE, SEM_FN_NAME (lm32bf,cmpge) },
+  { LM32BF_INSN_CMPGEI, SEM_FN_NAME (lm32bf,cmpgei) },
+  { LM32BF_INSN_CMPGEU, SEM_FN_NAME (lm32bf,cmpgeu) },
+  { LM32BF_INSN_CMPGEUI, SEM_FN_NAME (lm32bf,cmpgeui) },
+  { LM32BF_INSN_CMPGU, SEM_FN_NAME (lm32bf,cmpgu) },
+  { LM32BF_INSN_CMPGUI, SEM_FN_NAME (lm32bf,cmpgui) },
+  { LM32BF_INSN_CMPNE, SEM_FN_NAME (lm32bf,cmpne) },
+  { LM32BF_INSN_CMPNEI, SEM_FN_NAME (lm32bf,cmpnei) },
+  { LM32BF_INSN_DIVU, SEM_FN_NAME (lm32bf,divu) },
+  { LM32BF_INSN_LB, SEM_FN_NAME (lm32bf,lb) },
+  { LM32BF_INSN_LBU, SEM_FN_NAME (lm32bf,lbu) },
+  { LM32BF_INSN_LH, SEM_FN_NAME (lm32bf,lh) },
+  { LM32BF_INSN_LHU, SEM_FN_NAME (lm32bf,lhu) },
+  { LM32BF_INSN_LW, SEM_FN_NAME (lm32bf,lw) },
+  { LM32BF_INSN_MODU, SEM_FN_NAME (lm32bf,modu) },
+  { LM32BF_INSN_MUL, SEM_FN_NAME (lm32bf,mul) },
+  { LM32BF_INSN_MULI, SEM_FN_NAME (lm32bf,muli) },
+  { LM32BF_INSN_NOR, SEM_FN_NAME (lm32bf,nor) },
+  { LM32BF_INSN_NORI, SEM_FN_NAME (lm32bf,nori) },
+  { LM32BF_INSN_OR, SEM_FN_NAME (lm32bf,or) },
+  { LM32BF_INSN_ORI, SEM_FN_NAME (lm32bf,ori) },
+  { LM32BF_INSN_ORHII, SEM_FN_NAME (lm32bf,orhii) },
+  { LM32BF_INSN_RCSR, SEM_FN_NAME (lm32bf,rcsr) },
+  { LM32BF_INSN_SB, SEM_FN_NAME (lm32bf,sb) },
+  { LM32BF_INSN_SEXTB, SEM_FN_NAME (lm32bf,sextb) },
+  { LM32BF_INSN_SEXTH, SEM_FN_NAME (lm32bf,sexth) },
+  { LM32BF_INSN_SH, SEM_FN_NAME (lm32bf,sh) },
+  { LM32BF_INSN_SL, SEM_FN_NAME (lm32bf,sl) },
+  { LM32BF_INSN_SLI, SEM_FN_NAME (lm32bf,sli) },
+  { LM32BF_INSN_SR, SEM_FN_NAME (lm32bf,sr) },
+  { LM32BF_INSN_SRI, SEM_FN_NAME (lm32bf,sri) },
+  { LM32BF_INSN_SRU, SEM_FN_NAME (lm32bf,sru) },
+  { LM32BF_INSN_SRUI, SEM_FN_NAME (lm32bf,srui) },
+  { LM32BF_INSN_SUB, SEM_FN_NAME (lm32bf,sub) },
+  { LM32BF_INSN_SW, SEM_FN_NAME (lm32bf,sw) },
+  { LM32BF_INSN_USER, SEM_FN_NAME (lm32bf,user) },
+  { LM32BF_INSN_WCSR, SEM_FN_NAME (lm32bf,wcsr) },
+  { LM32BF_INSN_XOR, SEM_FN_NAME (lm32bf,xor) },
+  { LM32BF_INSN_XORI, SEM_FN_NAME (lm32bf,xori) },
+  { LM32BF_INSN_XNOR, SEM_FN_NAME (lm32bf,xnor) },
+  { LM32BF_INSN_XNORI, SEM_FN_NAME (lm32bf,xnori) },
+  { LM32BF_INSN_BREAK, SEM_FN_NAME (lm32bf,break) },
+  { LM32BF_INSN_SCALL, SEM_FN_NAME (lm32bf,scall) },
+  { 0, 0 }
+};
+
+/* Add the semantic fns to IDESC_TABLE.  */
+
+void
+SEM_FN_NAME (lm32bf,init_idesc_table) (SIM_CPU *current_cpu)
+{
+  IDESC *idesc_table = CPU_IDESC (current_cpu);
+  const struct sem_fn_desc *sf;
+  int mach_num = MACH_NUM (CPU_MACH (current_cpu));
+
+  for (sf = &sem_fns[0]; sf->fn != 0; ++sf)
+    {
+      const CGEN_INSN *insn = idesc_table[sf->index].idata;
+      int valid_p = (CGEN_INSN_VIRTUAL_P (insn)
+		     || CGEN_INSN_MACH_HAS_P (insn, mach_num));
+#if FAST_P
+      if (valid_p)
+	idesc_table[sf->index].sem_fast = sf->fn;
+      else
+	idesc_table[sf->index].sem_fast = SEM_FN_NAME (lm32bf,x_invalid);
+#else
+      if (valid_p)
+	idesc_table[sf->index].sem_full = sf->fn;
+      else
+	idesc_table[sf->index].sem_full = SEM_FN_NAME (lm32bf,x_invalid);
+#endif
+    }
+}
+
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/sem-switch.c gdb-6.8.50.20090329/sim/lm32/sem-switch.c
--- gdb-6.8.50.20090329.orig/sim/lm32/sem-switch.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/sem-switch.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,1554 @@
+/* Simulator instruction semantics for lm32bf.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2005 Free Software Foundation, Inc.
+
+This file is part of the GNU simulators.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifdef DEFINE_LABELS
+
+  /* The labels have the case they have because the enum of insn types
+     is all uppercase and in the non-stdc case the insn symbol is built
+     into the enum name.  */
+
+  static struct {
+    int index;
+    void *label;
+  } labels[] = {
+    { LM32BF_INSN_X_INVALID, && case_sem_INSN_X_INVALID },
+    { LM32BF_INSN_X_AFTER, && case_sem_INSN_X_AFTER },
+    { LM32BF_INSN_X_BEFORE, && case_sem_INSN_X_BEFORE },
+    { LM32BF_INSN_X_CTI_CHAIN, && case_sem_INSN_X_CTI_CHAIN },
+    { LM32BF_INSN_X_CHAIN, && case_sem_INSN_X_CHAIN },
+    { LM32BF_INSN_X_BEGIN, && case_sem_INSN_X_BEGIN },
+    { LM32BF_INSN_ADD, && case_sem_INSN_ADD },
+    { LM32BF_INSN_ADDI, && case_sem_INSN_ADDI },
+    { LM32BF_INSN_AND, && case_sem_INSN_AND },
+    { LM32BF_INSN_ANDI, && case_sem_INSN_ANDI },
+    { LM32BF_INSN_ANDHII, && case_sem_INSN_ANDHII },
+    { LM32BF_INSN_B, && case_sem_INSN_B },
+    { LM32BF_INSN_BI, && case_sem_INSN_BI },
+    { LM32BF_INSN_BE, && case_sem_INSN_BE },
+    { LM32BF_INSN_BG, && case_sem_INSN_BG },
+    { LM32BF_INSN_BGE, && case_sem_INSN_BGE },
+    { LM32BF_INSN_BGEU, && case_sem_INSN_BGEU },
+    { LM32BF_INSN_BGU, && case_sem_INSN_BGU },
+    { LM32BF_INSN_BNE, && case_sem_INSN_BNE },
+    { LM32BF_INSN_CALL, && case_sem_INSN_CALL },
+    { LM32BF_INSN_CALLI, && case_sem_INSN_CALLI },
+    { LM32BF_INSN_CMPE, && case_sem_INSN_CMPE },
+    { LM32BF_INSN_CMPEI, && case_sem_INSN_CMPEI },
+    { LM32BF_INSN_CMPG, && case_sem_INSN_CMPG },
+    { LM32BF_INSN_CMPGI, && case_sem_INSN_CMPGI },
+    { LM32BF_INSN_CMPGE, && case_sem_INSN_CMPGE },
+    { LM32BF_INSN_CMPGEI, && case_sem_INSN_CMPGEI },
+    { LM32BF_INSN_CMPGEU, && case_sem_INSN_CMPGEU },
+    { LM32BF_INSN_CMPGEUI, && case_sem_INSN_CMPGEUI },
+    { LM32BF_INSN_CMPGU, && case_sem_INSN_CMPGU },
+    { LM32BF_INSN_CMPGUI, && case_sem_INSN_CMPGUI },
+    { LM32BF_INSN_CMPNE, && case_sem_INSN_CMPNE },
+    { LM32BF_INSN_CMPNEI, && case_sem_INSN_CMPNEI },
+    { LM32BF_INSN_DIVU, && case_sem_INSN_DIVU },
+    { LM32BF_INSN_LB, && case_sem_INSN_LB },
+    { LM32BF_INSN_LBU, && case_sem_INSN_LBU },
+    { LM32BF_INSN_LH, && case_sem_INSN_LH },
+    { LM32BF_INSN_LHU, && case_sem_INSN_LHU },
+    { LM32BF_INSN_LW, && case_sem_INSN_LW },
+    { LM32BF_INSN_MODU, && case_sem_INSN_MODU },
+    { LM32BF_INSN_MUL, && case_sem_INSN_MUL },
+    { LM32BF_INSN_MULI, && case_sem_INSN_MULI },
+    { LM32BF_INSN_NOR, && case_sem_INSN_NOR },
+    { LM32BF_INSN_NORI, && case_sem_INSN_NORI },
+    { LM32BF_INSN_OR, && case_sem_INSN_OR },
+    { LM32BF_INSN_ORI, && case_sem_INSN_ORI },
+    { LM32BF_INSN_ORHII, && case_sem_INSN_ORHII },
+    { LM32BF_INSN_RCSR, && case_sem_INSN_RCSR },
+    { LM32BF_INSN_SB, && case_sem_INSN_SB },
+    { LM32BF_INSN_SEXTB, && case_sem_INSN_SEXTB },
+    { LM32BF_INSN_SEXTH, && case_sem_INSN_SEXTH },
+    { LM32BF_INSN_SH, && case_sem_INSN_SH },
+    { LM32BF_INSN_SL, && case_sem_INSN_SL },
+    { LM32BF_INSN_SLI, && case_sem_INSN_SLI },
+    { LM32BF_INSN_SR, && case_sem_INSN_SR },
+    { LM32BF_INSN_SRI, && case_sem_INSN_SRI },
+    { LM32BF_INSN_SRU, && case_sem_INSN_SRU },
+    { LM32BF_INSN_SRUI, && case_sem_INSN_SRUI },
+    { LM32BF_INSN_SUB, && case_sem_INSN_SUB },
+    { LM32BF_INSN_SW, && case_sem_INSN_SW },
+    { LM32BF_INSN_USER, && case_sem_INSN_USER },
+    { LM32BF_INSN_WCSR, && case_sem_INSN_WCSR },
+    { LM32BF_INSN_XOR, && case_sem_INSN_XOR },
+    { LM32BF_INSN_XORI, && case_sem_INSN_XORI },
+    { LM32BF_INSN_XNOR, && case_sem_INSN_XNOR },
+    { LM32BF_INSN_XNORI, && case_sem_INSN_XNORI },
+    { LM32BF_INSN_BREAK, && case_sem_INSN_BREAK },
+    { LM32BF_INSN_SCALL, && case_sem_INSN_SCALL },
+    { 0, 0 }
+  };
+  int i;
+
+  for (i = 0; labels[i].label != 0; ++i)
+    {
+#if FAST_P
+      CPU_IDESC (current_cpu) [labels[i].index].sem_fast_lab = labels[i].label;
+#else
+      CPU_IDESC (current_cpu) [labels[i].index].sem_full_lab = labels[i].label;
+#endif
+    }
+
+#undef DEFINE_LABELS
+#endif /* DEFINE_LABELS */
+
+#ifdef DEFINE_SWITCH
+
+/* If hyper-fast [well not unnecessarily slow] execution is selected, turn
+   off frills like tracing and profiling.  */
+/* FIXME: A better way would be to have TRACE_RESULT check for something
+   that can cause it to be optimized out.  Another way would be to emit
+   special handlers into the instruction "stream".  */
+
+#if FAST_P
+#undef TRACE_RESULT
+#define TRACE_RESULT(cpu, abuf, name, type, val)
+#endif
+
+#undef GET_ATTR
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_##attr)
+#else
+#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_/**/attr)
+#endif
+
+{
+
+#if WITH_SCACHE_PBB
+
+/* Branch to next handler without going around main loop.  */
+#define NEXT(vpc) goto * SEM_ARGBUF (vpc) -> semantic.sem_case
+SWITCH (sem, SEM_ARGBUF (vpc) -> semantic.sem_case)
+
+#else /* ! WITH_SCACHE_PBB */
+
+#define NEXT(vpc) BREAK (sem)
+#ifdef __GNUC__
+#if FAST_P
+  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->sem_fast_lab)
+#else
+  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->sem_full_lab)
+#endif
+#else
+  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->num)
+#endif
+
+#endif /* ! WITH_SCACHE_PBB */
+
+    {
+
+  CASE (sem, INSN_X_INVALID) : /* --invalid-- */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.fmt_empty.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+    /* Update the recorded pc in the cpu state struct.
+       Only necessary for WITH_SCACHE case, but to avoid the
+       conditional compilation ....  */
+    SET_H_PC (pc);
+    /* Virtual insns have zero size.  Overwrite vpc with address of next insn
+       using the default-insn-bitsize spec.  When executing insns in parallel
+       we may want to queue the fault and continue execution.  */
+    vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+    vpc = sim_engine_invalid_insn (current_cpu, pc, vpc);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_X_AFTER) : /* --after-- */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.fmt_empty.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+    lm32bf_pbb_after (current_cpu, sem_arg);
+#endif
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_X_BEFORE) : /* --before-- */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.fmt_empty.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+    lm32bf_pbb_before (current_cpu, sem_arg);
+#endif
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_X_CTI_CHAIN) : /* --cti-chain-- */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.fmt_empty.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+#ifdef DEFINE_SWITCH
+    vpc = lm32bf_pbb_cti_chain (current_cpu, sem_arg,
+			       pbb_br_type, pbb_br_npc);
+    BREAK (sem);
+#else
+    /* FIXME: Allow provision of explicit ifmt spec in insn spec.  */
+    vpc = lm32bf_pbb_cti_chain (current_cpu, sem_arg,
+			       CPU_PBB_BR_TYPE (current_cpu),
+			       CPU_PBB_BR_NPC (current_cpu));
+#endif
+#endif
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_X_CHAIN) : /* --chain-- */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.fmt_empty.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+    vpc = lm32bf_pbb_chain (current_cpu, sem_arg);
+#ifdef DEFINE_SWITCH
+    BREAK (sem);
+#endif
+#endif
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_X_BEGIN) : /* --begin-- */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.fmt_empty.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);
+
+  {
+#if WITH_SCACHE_PBB_LM32BF
+#if defined DEFINE_SWITCH || defined FAST_P
+    /* In the switch case FAST_P is a constant, allowing several optimizations
+       in any called inline functions.  */
+    vpc = lm32bf_pbb_begin (current_cpu, FAST_P);
+#else
+#if 0 /* cgen engine can't handle dynamic fast/full switching yet.  */
+    vpc = lm32bf_pbb_begin (current_cpu, STATE_RUN_FAST_P (CPU_STATE (current_cpu)));
+#else
+    vpc = lm32bf_pbb_begin (current_cpu, 0);
+#endif
+#endif
+#endif
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_ADD) : /* add $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ADDSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_ADDI) : /* addi $r1,$r0,$imm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_AND) : /* and $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ANDSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_ANDI) : /* andi $r1,$r0,$uimm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_andi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ANDSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_ANDHII) : /* andhi $r1,$r0,$hi16 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_andi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ANDSI (CPU (h_gr[FLD (f_r0)]), SLLSI (FLD (f_uimm), 16));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_B) : /* b $r0 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_be.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_b_insn (current_cpu, CPU (h_gr[FLD (f_r0)]), FLD (f_r0));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_BI) : /* bi $call */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_bi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = EXTSISI (FLD (i_call));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_BE) : /* be $r0,$r1,$branch */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_be.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (EQSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_BG) : /* bg $r0,$r1,$branch */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_be.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (GTSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_BGE) : /* bge $r0,$r1,$branch */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_be.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (GESI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_BGEU) : /* bgeu $r0,$r1,$branch */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_be.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (GEUSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_BGU) : /* bgu $r0,$r1,$branch */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_be.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (GTUSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_BNE) : /* bne $r0,$r1,$branch */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_be.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+if (NESI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]))) {
+  {
+    USI opval = FLD (i_branch);
+    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
+    written |= (1 << 3);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  abuf->written = written;
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CALL) : /* call $r0 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_be.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+{
+  {
+    SI opval = ADDSI (pc, 4);
+    CPU (h_gr[((UINT) 29)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+  {
+    USI opval = CPU (h_gr[FLD (f_r0)]);
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CALLI) : /* calli $call */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_bi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+{
+  {
+    SI opval = ADDSI (pc, 4);
+    CPU (h_gr[((UINT) 29)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+  {
+    USI opval = EXTSISI (FLD (i_call));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+}
+
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPE) : /* cmpe $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EQSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPEI) : /* cmpei $r1,$r0,$imm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EQSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPG) : /* cmpg $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GTSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPGI) : /* cmpgi $r1,$r0,$imm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GTSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPGE) : /* cmpge $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GESI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPGEI) : /* cmpgei $r1,$r0,$imm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GESI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPGEU) : /* cmpgeu $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GEUSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPGEUI) : /* cmpgeui $r1,$r0,$uimm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_andi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GEUSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPGU) : /* cmpgu $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GTUSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPGUI) : /* cmpgui $r1,$r0,$uimm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_andi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GTUSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPNE) : /* cmpne $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = NESI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_CMPNEI) : /* cmpnei $r1,$r0,$imm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = NESI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_DIVU) : /* divu $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_divu_insn (current_cpu, pc, FLD (f_r0), FLD (f_r1), FLD (f_r2));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_LB) : /* lb $r1,($r0+$imm) */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_LBU) : /* lbu $r1,($r0+$imm) */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ZEXTQISI (GETMEMQI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_LH) : /* lh $r1,($r0+$imm) */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_LHU) : /* lhu $r1,($r0+$imm) */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ZEXTHISI (GETMEMHI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_LW) : /* lw $r1,($r0+$imm) */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = GETMEMSI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm)))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_MODU) : /* modu $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_modu_insn (current_cpu, pc, FLD (f_r0), FLD (f_r1), FLD (f_r2));
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_MUL) : /* mul $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = MULSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_MULI) : /* muli $r1,$r0,$imm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = MULSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_NOR) : /* nor $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = INVSI (ORSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)])));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_NORI) : /* nori $r1,$r0,$uimm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_andi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = INVSI (ORSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_OR) : /* or $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ORSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_ORI) : /* ori $r1,$r0,$lo16 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_andi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ORSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_ORHII) : /* orhi $r1,$r0,$hi16 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_andi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = ORSI (CPU (h_gr[FLD (f_r0)]), SLLSI (FLD (f_uimm), 16));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_RCSR) : /* rcsr $r2,$csr */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_rcsr.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = CPU (h_csr[FLD (f_csr)]);
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SB) : /* sb ($r0+$imm),$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    QI opval = CPU (h_gr[FLD (f_r1)]);
+    SETMEMQI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm)))), opval);
+    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SEXTB) : /* sextb $r2,$r0 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EXTQISI (TRUNCSIQI (CPU (h_gr[FLD (f_r0)])));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SEXTH) : /* sexth $r2,$r0 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = EXTHISI (TRUNCSIHI (CPU (h_gr[FLD (f_r0)])));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SH) : /* sh ($r0+$imm),$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    HI opval = CPU (h_gr[FLD (f_r1)]);
+    SETMEMHI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm)))), opval);
+    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SL) : /* sl $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SLLSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SLI) : /* sli $r1,$r0,$imm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SLLSI (CPU (h_gr[FLD (f_r0)]), FLD (f_imm));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SR) : /* sr $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SRASI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SRI) : /* sri $r1,$r0,$imm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SRASI (CPU (h_gr[FLD (f_r0)]), FLD (f_imm));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SRU) : /* sru $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SRLSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SRUI) : /* srui $r1,$r0,$imm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SRLSI (CPU (h_gr[FLD (f_r0)]), FLD (f_imm));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SUB) : /* sub $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = SUBSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SW) : /* sw ($r0+$imm),$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_addi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = CPU (h_gr[FLD (f_r1)]);
+    SETMEMSI (current_cpu, pc, ADDSI (CPU (h_gr[FLD (f_r0)]), EXTHISI (TRUNCSIHI (FLD (f_imm)))), opval);
+    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_USER) : /* user $r2,$r0,$r1,$user */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = lm32bf_user_insn (current_cpu, CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]), FLD (f_user));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_WCSR) : /* wcsr $csr,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_wcsr.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+lm32bf_wcsr_insn (current_cpu, FLD (f_csr), CPU (h_gr[FLD (f_r1)]));
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_XOR) : /* xor $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = XORSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)]));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_XORI) : /* xori $r1,$r0,$uimm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_andi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = XORSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm)));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_XNOR) : /* xnor $r2,$r0,$r1 */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_user.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = INVSI (XORSI (CPU (h_gr[FLD (f_r0)]), CPU (h_gr[FLD (f_r1)])));
+    CPU (h_gr[FLD (f_r2)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_XNORI) : /* xnori $r1,$r0,$uimm */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.sfmt_andi.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    SI opval = INVSI (XORSI (CPU (h_gr[FLD (f_r0)]), ZEXTSISI (FLD (f_uimm))));
+    CPU (h_gr[FLD (f_r1)]) = opval;
+    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
+  }
+
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_BREAK) : /* break */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.fmt_empty.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_break_insn (current_cpu, pc);
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+  CASE (sem, INSN_SCALL) : /* scall */
+{
+  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
+  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
+#define FLD(f) abuf->fields.fmt_empty.f
+  int UNUSED written = 0;
+  IADDR UNUSED pc = abuf->addr;
+  SEM_BRANCH_INIT
+  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
+
+  {
+    USI opval = lm32bf_scall_insn (current_cpu, pc);
+    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
+    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
+  }
+
+  SEM_BRANCH_FINI (vpc);
+#undef FLD
+}
+  NEXT (vpc);
+
+
+    }
+  ENDSWITCH (sem) /* End of semantic switch.  */
+
+  /* At this point `vpc' contains the next insn to execute.  */
+}
+
+#undef DEFINE_SWITCH
+#endif /* DEFINE_SWITCH */
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/sim-if.c gdb-6.8.50.20090329/sim/lm32/sim-if.c
--- gdb-6.8.50.20090329.orig/sim/lm32/sim-if.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/sim-if.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,286 @@
+/* Main simulator entry points specific to Lattice Mico32.
+   Written by Jon Beniston <jon@beniston.com>
+   
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "sim-main.h"
+#include "sim-options.h"
+#include "libiberty.h"
+#include "bfd.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+static void free_state (SIM_DESC);
+static void print_lm32_misc_cpu (SIM_CPU *cpu, int verbose);
+static DECLARE_OPTION_HANDLER (lm32_option_handler);
+
+enum {
+  OPTION_ENDIAN = OPTION_START,
+};
+
+/* GDB passes -E, even though it's fixed, so we have to handle it here. common code only handles it if SIM_HAVE_BIENDIAN is defined, which it isn't for lm32 */
+static const OPTION lm32_options[] =
+{
+  { {"endian", required_argument, NULL, OPTION_ENDIAN},
+      'E', "big", "Set endianness",
+      lm32_option_handler },
+  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
+};
+
+/* Records simulator descriptor so utilities like lm32_dump_regs can be
+   called from gdb.  */
+SIM_DESC current_state;
+
+/* Cover function of sim_state_free to free the cpu buffers as well.  */
+
+static void
+free_state (SIM_DESC sd)
+{
+  if (STATE_MODULES (sd) != NULL)
+    sim_module_uninstall (sd);
+  sim_cpu_free_all (sd);
+  sim_state_free (sd);
+}
+
+/* Find memory range used by program */
+
+static unsigned long 
+find_base (bfd *prog_bfd)
+{
+  int found;
+  unsigned long base = ~(0UL);
+  asection *s;
+
+  found = 0;
+  for (s = prog_bfd->sections; s; s = s->next)
+    {
+      if (   (strcmp (bfd_get_section_name (prog_bfd, s), ".boot") == 0)
+          || (strcmp (bfd_get_section_name (prog_bfd, s), ".text") == 0)
+          || (strcmp (bfd_get_section_name (prog_bfd, s), ".data") == 0)
+          || (strcmp (bfd_get_section_name (prog_bfd, s), ".bss") == 0)
+         ) 
+        {
+          if (!found) 
+            {
+              base = bfd_get_section_vma (prog_bfd, s);
+              found = 1;
+            } 
+          else 
+            base = bfd_get_section_vma (prog_bfd, s) < base ? bfd_get_section_vma (prog_bfd, s) : base;
+        }
+    }
+  return base & ~(0xffffUL);
+}
+
+static unsigned long 
+find_limit (bfd *prog_bfd)
+{
+  struct bfd_symbol **asymbols;
+  long symsize;
+  long symbol_count;
+  long s;
+
+  symsize = bfd_get_symtab_upper_bound (prog_bfd);
+  if (symsize < 0)
+    return 0;
+  asymbols = (asymbol **) xmalloc (symsize);
+  symbol_count = bfd_canonicalize_symtab (prog_bfd, asymbols);
+  if (symbol_count < 0)
+    return 0;
+		
+  for (s = 0; s < symbol_count; s++) 
+    {
+      if (!strcmp (asymbols[s]->name, "_fstack")) 
+        return (asymbols[s]->value + 65536) & ~(0xffffUL);
+    }
+  return 0;
+}
+
+/* Handle lm32 specific options */
+
+static SIM_RC
+lm32_option_handler (sd, cpu, opt, arg, is_command)
+     SIM_DESC sd;
+     sim_cpu *cpu;
+     int opt;
+     char *arg;
+     int is_command;
+{
+  return SIM_RC_OK;
+}
+
+/* Create an instance of the simulator.  */
+
+SIM_DESC
+sim_open (kind, callback, abfd, argv)
+     SIM_OPEN_KIND kind;
+     host_callback *callback;
+     struct bfd *abfd;
+     char **argv;
+{
+  SIM_DESC sd = sim_state_alloc (kind, callback);
+  char c;
+  int i;
+  unsigned long base, limit;
+
+  /* The cpu data is kept in a separately allocated chunk of memory.  */
+  if (sim_cpu_alloc_all (sd, 1, cgen_cpu_max_extra_bytes ()) != SIM_RC_OK)
+    {
+      free_state (sd);
+      return 0;
+    }
+
+  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
+    {
+      free_state (sd);
+      return 0;
+    }
+  sim_add_option_table (sd, NULL, lm32_options);
+
+  /* getopt will print the error message so we just have to exit if this fails.
+     FIXME: Hmmm...  in the case of gdb we need getopt to call
+     print_filtered.  */
+  if (sim_parse_args (sd, argv) != SIM_RC_OK)
+    {
+      free_state (sd);
+      return 0;
+    }
+
+#if 0
+  /* Allocate a handler for I/O devices
+     if no memory for that range has been allocated by the user.
+     All are allocated in one chunk to keep things from being
+     unnecessarily complicated.  */
+  if (sim_core_read_buffer (sd, NULL, read_map, &c, LM32_DEVICE_ADDR, 1) == 0)
+    sim_core_attach (sd, NULL,
+		     0 /*level*/,
+		     access_read_write,
+		     0 /*space ???*/,
+		     LM32_DEVICE_ADDR, LM32_DEVICE_LEN /*nr_bytes*/,
+		     0 /*modulo*/,
+		     &lm32_devices,
+		     NULL /*buffer*/);
+#endif
+
+  /* check for/establish the reference program image */
+  if (sim_analyze_program (sd,
+			   (STATE_PROG_ARGV (sd) != NULL
+			    ? *STATE_PROG_ARGV (sd)
+			    : NULL),
+			   abfd) != SIM_RC_OK)
+    {
+      free_state (sd);
+      return 0;
+    }
+
+  /* Check to see if memory exists at programs start address */
+  if (sim_core_read_buffer (sd, NULL, read_map, &c, STATE_START_ADDR (sd), 1) == 0)
+    {
+      if (STATE_PROG_BFD (sd) != NULL) {
+        /* It doesn't, so we should try to allocate enough memory to hold program */
+        base = find_base (STATE_PROG_BFD (sd));
+        limit = find_limit (STATE_PROG_BFD (sd));
+        if (limit == 0) 
+          {
+            sim_io_eprintf (sd, "Failed to find symbol _fstack in program. You must specify memory regions with --memory-region.\n");
+            free_state (sd);
+            return 0;
+          }
+        /*sim_io_printf (sd, "Allocating memory at 0x%x size 0x%x\n", base, limit);*/
+        sim_do_commandf (sd, "memory region 0x%x,0x%x", base, limit);
+      }
+    }
+
+  /* Establish any remaining configuration options.  */
+  if (sim_config (sd) != SIM_RC_OK)
+    {
+      free_state (sd);
+      return 0;
+    }
+
+  if (sim_post_argv_init (sd) != SIM_RC_OK)
+    {
+      free_state (sd);
+      return 0;
+    }
+
+  /* Open a copy of the cpu descriptor table.  */
+  {
+    CGEN_CPU_DESC cd = lm32_cgen_cpu_open_1 (STATE_ARCHITECTURE (sd)->printable_name,
+					     CGEN_ENDIAN_BIG);
+    for (i = 0; i < MAX_NR_PROCESSORS; ++i)
+      {
+	SIM_CPU *cpu = STATE_CPU (sd, i);
+	CPU_CPU_DESC (cpu) = cd;
+	CPU_DISASSEMBLER (cpu) = sim_cgen_disassemble_insn;
+      }
+    lm32_cgen_init_dis (cd);
+  }
+
+  /* Initialize various cgen things not done by common framework.
+     Must be done after lm32_cgen_cpu_open.  */
+  cgen_init (sd);
+
+  /* Store in a global so things like lm32_dump_regs can be invoked
+     from the gdb command line.  */
+  current_state = sd;
+
+  return sd;
+}
+
+void
+sim_close (sd, quitting)
+     SIM_DESC sd;
+     int quitting;
+{
+  lm32_cgen_cpu_close (CPU_CPU_DESC (STATE_CPU (sd, 0)));
+  sim_module_uninstall (sd);
+}
+
+SIM_RC
+sim_create_inferior (sd, abfd, argv, envp)
+     SIM_DESC sd;
+     struct bfd *abfd;
+     char **argv;
+     char **envp;
+{
+  SIM_CPU *current_cpu = STATE_CPU (sd, 0);
+  SIM_ADDR addr;
+
+  if (abfd != NULL)
+    addr = bfd_get_start_address (abfd);
+  else
+    addr = 0;
+  sim_pc_set (current_cpu, addr);
+
+#if 0
+  STATE_ARGV (sd) = sim_copy_argv (argv);
+  STATE_ENVP (sd) = sim_copy_argv (envp);
+#endif
+
+  return SIM_RC_OK;
+}
+
+void
+sim_do_command (sd, cmd)
+     SIM_DESC sd;
+     char *cmd;
+{ 
+  if (sim_args_command (sd, cmd) != SIM_RC_OK)
+    sim_io_eprintf (sd, "Unknown command `%s'\n", cmd);
+}
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/sim-main.h gdb-6.8.50.20090329/sim/lm32/sim-main.h
--- gdb-6.8.50.20090329.orig/sim/lm32/sim-main.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/sim-main.h	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,98 @@
+/* Lattice Mico32 simulator support code
+   Written by Jon Beniston <jon@beniston.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Main header for the LM32 simulator.  */
+
+#ifndef SIM_MAIN_H
+#define SIM_MAIN_H
+
+#define USING_SIM_BASE_H /* FIXME: quick hack */
+
+struct _sim_cpu; /* FIXME: should be in sim-basics.h */
+typedef struct _sim_cpu SIM_CPU;
+
+#include "symcat.h"
+#include "sim-basics.h"
+#include "cgen-types.h"
+#include "lm32-desc.h"
+#include "lm32-opc.h"
+#include "arch.h"
+
+/* These must be defined before sim-base.h.  */
+typedef USI sim_cia;
+
+#define CIA_GET(cpu)     CPU_PC_GET (cpu)
+#define CIA_SET(cpu,val) CPU_PC_SET ((cpu), (val))
+
+#define SIM_ENGINE_HALT_HOOK(sd, cpu, cia) \
+do { \
+  if (cpu) /* null if ctrl-c */ \
+    sim_pc_set ((cpu), (cia)); \
+} while (0)
+#define SIM_ENGINE_RESTART_HOOK(sd, cpu, cia) \
+do { \
+  sim_pc_set ((cpu), (cia)); \
+} while (0)
+
+#include "sim-base.h"
+#include "cgen-sim.h"
+#include "lm32-sim.h"
+#include "opcode/cgen.h"
+
+/* The _sim_cpu struct.  */
+
+struct _sim_cpu {
+  /* sim/common cpu base.  */
+  sim_cpu_base base;
+
+  /* Static parts of cgen.  */
+  CGEN_CPU cgen_cpu;
+
+  /* CPU specific parts go here.
+     Note that in files that don't need to access these pieces WANT_CPU_FOO
+     won't be defined and thus these parts won't appear.  This is ok in the
+     sense that things work.  It is a source of bugs though.
+     One has to of course be careful to not take the size of this
+     struct and no structure members accessed in non-cpu specific files can
+     go after here.  Oh for a better language.  */
+#if defined (WANT_CPU_LM32BF)
+  LM32BF_CPU_DATA cpu_data;
+#endif
+ 
+};
+
+/* The sim_state struct.  */
+
+struct sim_state {
+  sim_cpu *cpu;
+#define STATE_CPU(sd, n) (/*&*/ (sd)->cpu)
+
+  CGEN_STATE cgen_state;
+
+  sim_state_base base;
+};
+
+/* Misc.  */
+
+/* Catch address exceptions.  */
+extern SIM_CORE_SIGNAL_FN lm32_core_signal;
+#define SIM_CORE_SIGNAL(SD,CPU,CIA,MAP,NR_BYTES,ADDR,TRANSFER,ERROR) \
+lm32_core_signal ((SD), (CPU), (CIA), (MAP), (NR_BYTES), (ADDR), \
+		  (TRANSFER), (ERROR))
+
+#endif /* SIM_MAIN_H */
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/tconfig.in gdb-6.8.50.20090329/sim/lm32/tconfig.in
--- gdb-6.8.50.20090329.orig/sim/lm32/tconfig.in	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/tconfig.in	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,27 @@
+/* Lattice Mico32 simulator configuration.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef LM32_TCONFIG_H
+#define LM32_TCONFIG_H
+
+/* See sim-hload.c.  We properly handle LMA.  */
+#define SIM_HANDLES_LMA 1
+
+#define WITH_SCACHE_PBB 1
+
+#endif /* LM32_TCONFIG_H */
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/traps.c gdb-6.8.50.20090329/sim/lm32/traps.c
--- gdb-6.8.50.20090329.orig/sim/lm32/traps.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/traps.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,263 @@
+/* Lattice Mico32 exception and system call support.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define WANT_CPU lm32bf
+#define WANT_CPU_LM32BF
+
+#include "sim-main.h"
+#include "lm32-sim.h"
+#include "targ-vals.h"
+   
+/* Read memory function for system call interface.  */
+
+static int
+syscall_read_mem (host_callback *cb, struct cb_syscall *sc,
+		  unsigned long taddr, char *buf, int bytes)
+{
+  SIM_DESC sd = (SIM_DESC) sc->p1;
+  SIM_CPU *cpu = (SIM_CPU *) sc->p2;
+
+  return sim_core_read_buffer (sd, cpu, read_map, buf, taddr, bytes);
+}
+
+/* Write memory function for system call interface.  */
+
+static int
+syscall_write_mem (host_callback *cb, struct cb_syscall *sc,
+		   unsigned long taddr, const char *buf, int bytes)
+{
+  SIM_DESC sd = (SIM_DESC) sc->p1;
+  SIM_CPU *cpu = (SIM_CPU *) sc->p2;
+
+  return sim_core_write_buffer (sd, cpu, write_map, buf, taddr, bytes);
+}
+
+/* Handle invalid instructions.  */ 
+   
+SEM_PC
+sim_engine_invalid_insn (SIM_CPU *current_cpu, IADDR cia, SEM_PC pc)
+{
+  SIM_DESC sd = CPU_STATE (current_cpu);
+
+  sim_engine_halt (sd, current_cpu, NULL, cia, sim_stopped, SIM_SIGILL);
+
+  return pc;
+}
+
+/* Handle divide instructions. */
+
+USI
+lm32bf_divu_insn (SIM_CPU *current_cpu, IADDR pc, USI r0, USI r1, USI r2)
+{
+  SIM_DESC sd = CPU_STATE (current_cpu);
+  host_callback *cb = STATE_CALLBACK (sd);
+
+  /* Check for divide by zero */
+  if (GET_H_GR (r1) == 0)
+    {
+      if (STATE_ENVIRONMENT (sd) != OPERATING_ENVIRONMENT)
+        sim_engine_halt (sd, current_cpu, NULL, pc, sim_stopped, SIM_SIGFPE);
+      else 
+        {
+          /* Save PC in exception address register.  */
+          SET_H_GR (30, pc);
+          /* Save and clear interrupt enable */
+          SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 1) << 1);
+          /* Branch to divide by zero exception handler.  */
+          return GET_H_CSR (LM32_CSR_EBA) + LM32_EID_DIVIDE_BY_ZERO * 32;
+        }
+    }
+  else
+    {
+      SET_H_GR (r2, (USI)GET_H_GR (r0) / (USI)GET_H_GR (r1));
+      return pc + 4;
+    }
+}
+
+USI
+lm32bf_modu_insn (SIM_CPU *current_cpu, IADDR pc, USI r0, USI r1, USI r2)
+{
+  SIM_DESC sd = CPU_STATE (current_cpu);
+  host_callback *cb = STATE_CALLBACK (sd);
+
+  /* Check for divide by zero */
+  if (GET_H_GR (r1) == 0)
+    {
+      if (STATE_ENVIRONMENT (sd) != OPERATING_ENVIRONMENT)
+        sim_engine_halt (sd, current_cpu, NULL, pc, sim_stopped, SIM_SIGFPE);
+      else 
+        {
+          /* Save PC in exception address register.  */
+          SET_H_GR (30, pc);
+          /* Save and clear interrupt enable */
+          SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 1) << 1);
+          /* Branch to divide by zero exception handler.  */
+          return  GET_H_CSR (LM32_CSR_EBA) + LM32_EID_DIVIDE_BY_ZERO * 32;
+        }
+    }
+  else
+    {
+      SET_H_GR (r2, (USI)GET_H_GR (r0) % (USI)GET_H_GR (r1));
+      return pc + 4;
+    }
+}
+
+/* Handle break instructions.  */
+
+USI
+lm32bf_break_insn (SIM_CPU *current_cpu, IADDR pc)
+{
+  SIM_DESC sd = CPU_STATE (current_cpu);
+  host_callback *cb = STATE_CALLBACK (sd);
+  /* Breakpoint.  */
+  if (STATE_ENVIRONMENT (sd) != OPERATING_ENVIRONMENT)
+    { 
+      sim_engine_halt (sd, current_cpu, NULL, pc, sim_stopped, SIM_SIGTRAP);
+      return pc;
+    }
+  else
+    {
+      /* Save PC in breakpoint address register.  */
+      SET_H_GR (31, pc);
+      /* Save and clear interrupt enable */
+      SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 1) << 2);
+      /* Branch to breakpoint exception handler.  */
+      return  GET_H_CSR (LM32_CSR_DEBA) + LM32_EID_BREAKPOINT * 32;
+    }
+}
+
+/* Handle scall instructions.  */
+
+USI
+lm32bf_scall_insn (SIM_CPU *current_cpu, IADDR pc)
+{
+  SIM_DESC sd = CPU_STATE (current_cpu);
+  host_callback *cb = STATE_CALLBACK (sd);
+
+  if (   (STATE_ENVIRONMENT (sd) != OPERATING_ENVIRONMENT)
+      || (GET_H_GR (8) == TARGET_SYS_exit)
+     ) 
+    {
+      /* Delegate system call to host O/S.  */
+      CB_SYSCALL s;
+      CB_SYSCALL_INIT (&s);
+      s.p1 = (PTR)sd;
+      s.p2 = (PTR)current_cpu;
+      s.read_mem = syscall_read_mem;
+      s.write_mem = syscall_write_mem;
+      /* Extract parameters.  */
+      s.func = GET_H_GR (8);
+      s.arg1 = GET_H_GR (1);
+      s.arg2 = GET_H_GR (2);
+      s.arg3 = GET_H_GR (3);
+      /* Halt the simulator if the requested system call is _exit.  */
+      if (s.func == TARGET_SYS_exit) 
+        sim_engine_halt (sd, current_cpu, NULL, pc, sim_exited, s.arg1);
+      /* Perform the system call.  */
+      cb_syscall (cb, &s);
+      /* Store the return value in the CPU's registers.  */
+      SET_H_GR (1, s.result);
+      SET_H_GR (2, s.result2);
+      SET_H_GR (3, s.errcode);
+      /* Skip over scall instruction.  */
+      return pc + 4;      
+    }
+  else 
+    {
+      /* Save PC in exception address register.  */
+      SET_H_GR (30, pc);
+      /* Save and clear interrupt enable */
+      SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 1) << 1);
+      /* Branch to system call exception handler.  */
+      return  GET_H_CSR (LM32_CSR_EBA) + LM32_EID_SYSTEM_CALL * 32;
+    }
+}
+
+/* Handle b instructions.  */
+
+USI
+lm32bf_b_insn (SIM_CPU *current_cpu, USI r0, USI f_r0)
+{
+  SIM_DESC sd = CPU_STATE (current_cpu);
+  host_callback *cb = STATE_CALLBACK (sd);
+  
+  /* Restore interrupt enable */
+  if (f_r0 == 30) 
+    SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 2) >> 1);
+  else if (f_r0 == 31) 
+    SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 4) >> 2);
+  return r0;  
+}
+
+/* Handle wcsr instructions.  */
+
+void
+lm32bf_wcsr_insn (SIM_CPU *current_cpu, USI f_csr, USI r1)
+{
+  SIM_DESC sd = CPU_STATE (current_cpu);
+  host_callback *cb = STATE_CALLBACK (sd);
+
+  /* Writing a 1 to IP CSR clears a bit, writing 0 has no effect */
+  if (f_csr == LM32_CSR_IP) 
+    SET_H_CSR (f_csr, GET_H_CSR (f_csr) & ~r1);
+  else
+    SET_H_CSR (f_csr, r1);
+}
+
+/* Handle signals.  */
+
+void
+lm32_core_signal (SIM_DESC sd,
+		 sim_cpu *cpu,
+		 sim_cia cia,
+		 unsigned map,
+		 int nr_bytes,
+		 address_word addr,
+		 transfer_type transfer,
+		 sim_core_signals sig)
+{
+  const char *copy = (transfer == read_transfer ? "read" : "write");
+  address_word ip = CIA_ADDR (cia);
+  SIM_CPU *current_cpu = cpu;
+  
+  switch (sig)
+    {
+    case sim_core_unmapped_signal:
+      sim_io_eprintf (sd, "core: %d byte %s to unmapped address 0x%lx at 0x%lx\n",
+		      nr_bytes, copy, (unsigned long) addr, (unsigned long) ip);
+      SET_H_GR (30, ip);
+      /* Save and clear interrupt enable */
+      SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 1) << 1);
+      CIA_SET (cpu,  GET_H_CSR (LM32_CSR_EBA) + LM32_EID_DATA_BUS_ERROR * 32);
+      sim_engine_halt (sd, cpu, NULL, LM32_EID_DATA_BUS_ERROR * 32, sim_stopped, SIM_SIGSEGV);
+      break;
+    case sim_core_unaligned_signal:
+      sim_io_eprintf (sd, "core: %d byte misaligned %s to address 0x%lx at 0x%lx\n",
+		      nr_bytes, copy, (unsigned long) addr, (unsigned long) ip);
+      SET_H_GR (30, ip);
+      /* Save and clear interrupt enable */
+      SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 1) << 1);
+      CIA_SET (cpu,  GET_H_CSR (LM32_CSR_EBA) + LM32_EID_DATA_BUS_ERROR * 32);
+      sim_engine_halt (sd, cpu, NULL, LM32_EID_DATA_BUS_ERROR * 32, sim_stopped, SIM_SIGBUS);
+      break;
+    default:
+      sim_engine_abort (sd, cpu, cia,
+			"sim_core_signal - internal error - bad switch");
+    }
+}
+
diff -Naur gdb-6.8.50.20090329.orig/sim/lm32/user.c gdb-6.8.50.20090329/sim/lm32/user.c
--- gdb-6.8.50.20090329.orig/sim/lm32/user.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.8.50.20090329/sim/lm32/user.c	2009-04-17 15:30:42.000000000 +0200
@@ -0,0 +1,28 @@
+/* Semantics for user defined instructions on the Lattice Mico32.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "sim-main.h"
+   
+/* Handle user defined instructions */
+
+UINT
+lm32bf_user_insn (SIM_CPU *current_cpu, INT r0, INT r1, UINT imm)
+{
+  /* FIXME: Should probably call code in a user supplied library.  */   
+  return 0;
+}
diff -Naur gdb-6.8.50.20090329.orig/sim/m32c/gdb-if.c gdb-6.8.50.20090329/sim/m32c/gdb-if.c
--- gdb-6.8.50.20090329.orig/sim/m32c/gdb-if.c	2009-01-14 11:53:07.000000000 +0100
+++ gdb-6.8.50.20090329/sim/m32c/gdb-if.c	2009-04-17 15:30:42.000000000 +0200
@@ -538,8 +538,12 @@
 #endif
 
     case 5:
+#ifdef SIGTRAP
       return SIGTRAP;
-
+#else
+      return SIGSEGV;
+#endif
+    
     case 10:
 #ifdef SIGBUS
       return SIGBUS;
diff -Naur gdb-6.8.50.20090329.orig/sim/m32c/Makefile.in gdb-6.8.50.20090329/sim/m32c/Makefile.in
--- gdb-6.8.50.20090329.orig/sim/m32c/Makefile.in	2009-01-14 11:53:07.000000000 +0100
+++ gdb-6.8.50.20090329/sim/m32c/Makefile.in	2009-04-17 15:30:42.000000000 +0200
@@ -55,7 +55,7 @@
 	./opc2c -l m32c.out $(srcdir)/m32c.opc > m32c.c
 
 opc2c : opc2c.o safe-fgets.o
-	$(CC) $(CFLAGS) $(LDFLAGS) $^ -o $@
+	$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $^ -o $@
 
 sample.x : $(srcdir)/sample.S $(srcdir)/sample.ld
 	../../gcc/xgcc $(CPUFLAGS) -B../../gcc/ -c $(srcdir)/sample.S -o sample.o
@@ -83,8 +83,10 @@
 mem.o : mem.h cpu.h syscalls.h
 misc.o : cpu.h misc.h
 opc2c.o : safe-fgets.h
+	$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) -o $@ -c $(srcdir)/opc2c.c
 reg.o : cpu.h
 safe-fgets.o : safe-fgets.h
+	$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) -o $@ -c $(srcdir)/safe-fgets.c
 srcdest.c : cpu.h mem.h
 syscalls.c : cpu.h mem.h syscalls.h
 
diff -Naur gdb-6.8.50.20090329.orig/sim/MAINTAINERS gdb-6.8.50.20090329/sim/MAINTAINERS
--- gdb-6.8.50.20090329.orig/sim/MAINTAINERS	2008-04-08 09:15:39.000000000 +0200
+++ gdb-6.8.50.20090329/sim/MAINTAINERS	2009-04-17 15:30:42.000000000 +0200
@@ -14,6 +14,7 @@
 frv		Dave Brolley <brolley@redhat.com>
 igen		(igen simulators)
 ppc		Andrew Cagney <ac131313@redhat.com>
+lm32            Jon Beniston <jon@beniston.com>
 m68hc11		Stephane Carrez <stcarrez@nerim.fr>
 mips		Thiemo Seufer <ths@networkno.de>
 sh		(global maintainers)
